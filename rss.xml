<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://oragekk.me/Zzh/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://oragekk.me/Zzh/rss.xml" rel="self" type="application/rss+xml"/>
    <title>ZiHao Blog</title>
    <link>https://oragekk.me/Zzh/</link>
    <description>子豪的博客</description>
    <language>zh-CN</language>
    <pubDate>Sun, 23 Jul 2023 06:59:12 GMT</pubDate>
    <lastBuildDate>Sun, 23 Jul 2023 06:59:12 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>记录</category>
    <category>Hexo</category>
    <category>React</category>
    <category>源码</category>
    <category>Vue</category>
    <category>Webpack</category>
    <category>Webscoket</category>
    <category>专业课</category>
    <category>Blog</category>
    <category>About</category>
    <category>使用指南</category>
    <category>收藏</category>
    <category>Vercel</category>
    <category>Linux</category>
    <category>浏览器</category>
    <category>GitHub</category>
    <category>Flutter</category>
    <category>Dart</category>
    <category>前端跨平台</category>
    <category>CSS</category>
    <category>JavaScript</category>
    <item>
      <title>12个实用的JS函数</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">12个实用的JS函数</source>
      <description>前言 本文收集了 12 个在日常开发中非常常用的函数，有些可能很复杂，有些可能很简单，但我相信或多或少会对大家都会有所帮助。 生成随机颜色 你的网站是否需要生成随机颜色？下面一行代码就可以实现。 const generateRandomHexColor = () =&amp;gt; `#${Math.floor(Math.random() * 0xffffff).toString(16)}`; console.log(generateRandomHexColor());</description>
      <category>记录</category>
      <pubDate>Fri, 07 Oct 2022 15:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文收集了 12 个在日常开发中非常常用的函数，有些可能很复杂，有些可能很简单，但我相信或多或少会对大家都会有所帮助。</p>
<h3> 生成随机颜色</h3>
<p>你的网站是否需要生成随机颜色？下面一行代码就可以实现。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组重排序</h3>
<p>对数组的元素进行重新排序是一项非常重要的技巧，但是原生 Array 中并没有这项功能。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 复制到剪切板</h3>
<p>复制到剪切板是一项非常实用且能够提高用户便利性的功能。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 检测暗色主题</h3>
<p>暗色主题日益普及，很多用的都会在设备中启用案模式，我们将应用程序切换到暗色主题可以提高用户体验度。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 滚动到顶部</h3>
<p>将元素滚动到顶部最简单的方法是使用 scrollIntoView。设置 block 为 start 可以滚动到顶部；设置 behavior 为 smooth 可以开启平滑滚动。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 检测元素是否在屏幕中</h3>
<p>检查元素是否在窗口中最好的方法是使用 IntersectionObserver。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 检测设备</h3>
<p>使用 navigator.userAgent 来检测网站运行在哪种平台设备上。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 隐藏元素</h3>
<p>我们可以将元素的 style.visibility 设置为 hidden，隐藏元素的可见性，但元素的空间仍然会被占用。如果设置元素的 style.display 为 none，会将元素从渲染流中删除。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 从 URL 中获取参数</h3>
<p>JavaScript 中有一个 URL 对象，通过它可以非常方便的获取 URL 中的参数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 深拷贝对象</h3>
<p>深拷贝对象非常简单，先将对象转换为字符串，再转换成对象即可。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了利用 JSON 的 API，还有更新的深拷贝对象的 structuredClone API，但并不是在所有的浏览器中都支持。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 等待函数</h3>
<p>JavaScript 提供了 setTimeout 函数，但是它并不返回 Promise 对象，所以我们没办法使用 async 作用在这个函数上，但是我们可以封装等待函数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>AJAX相关问题的解决</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">AJAX相关问题的解决</source>
      <description>AJAX 是一默认是异步的程序，AJAX 执行的时候是没有顺序性的，就在第一个接口还没有把返回的数据传入 dom 时，就已经执行其他代码了，如果在这完成之前去用 js 去获取用 ajax 加入 dom 的元素，是获取不到的，但是在一些小型的请求可通过把 ajax 中的 async=flase，设置成同步，就能够在 ajax 完全执行完成之后，在进行之后的代码，就能够用 js 获取到动态添加的内容了。 但是这不是一个好方法，只能满足小型请求是不行的 ，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止，也可以在开启异步时，在 ajax 的回调函数中去对动态添加的元素进行获取；绑定事件。这是一个挺好用的方法，</description>
      <category>记录</category>
      <pubDate>Sun, 06 Mar 2022 11:02:21 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>AJAX 是一默认是异步的程序，AJAX 执行的时候是没有顺序性的，就在第一个接口还没有把返回的数据传入 dom 时，就已经执行其他代码了，如果在这完成之前去用 js 去获取用 ajax 加入 dom 的元素，是获取不到的，但是在一些小型的请求可通过把 ajax 中的 async=flase，设置成同步，就能够在 ajax 完全执行完成之后，在进行之后的代码，就能够用 js 获取到动态添加的内容了。</p>
<p>但是这不是一个好方法，只能满足小型请求是不行的 ，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止，也可以在开启异步时，在 ajax 的回调函数中去对动态添加的元素进行获取；绑定事件。这是一个挺好用的方法，</p>
<p>还有一个方法，这不是一个好方法，但是我觉得还挺有意思，在 js 中设置一个定时器，把对动态添加的内容执行的函数放到里面，这样无论什么时候 ajax 加载完成，定时器在反复的寻找需要绑定函数的内容，找到了，就绑定；（感觉有 bug，可能和网速有关系。尽量不用）</p>
<p>之后继续学习 es6 的规则；应用到代码中，再深入了解了解 ajax，还有 jq 工具库。</p>
]]></content:encoded>
    </item>
    <item>
      <title>跨域问题</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CORS.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CORS.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">跨域问题</source>
      <description>什么是跨域 浏览器有一个重要的安全策略，称之为[同源策略] 其中，源=协议+主机+端口源=协议+主机+端口源=协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域。 比如： 源 1 源 2 是否同源 www.baidu.com www.baidu.com/news 是 http://www.baidu.com https://www.baidu.com 否 http://localhost:5000 http://localhost:7000 否 http://localhost:5000 http://127.0.0.1:5000 否 www.baidu.com baidu.com 否 同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制 同源策略对 ajax 的跨域限制的最为凶狠，默认情况下，它不允许 ajax 访问跨域资源 所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响 有多种方式解决跨域问题，常见的有：</description>
      <category>记录</category>
      <pubDate>Sun, 11 Dec 2022 08:31:40 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 什么是跨域</h3>
<p>浏览器有一个重要的安全策略，称之为[同源策略]<br>
其中，源=协议+主机+端口源=协议+主机+端口源=协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域。</p>
<p>比如：</p>
<table>
<thead>
<tr>
<th>源 1</th>
<th>源 2</th>
<th>是否同源</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a></td>
<td><a href="http://www.baidu.com/news" target="_blank" rel="noopener noreferrer">www.baidu.com/news</a></td>
<td>是</td>
</tr>
<tr>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">http://www.baidu.com</a></td>
<td><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer">https://www.baidu.com</a></td>
<td>否</td>
</tr>
<tr>
<td><a href="http://localhost:5000" target="_blank" rel="noopener noreferrer">http://localhost:5000</a></td>
<td><a href="http://localhost:7000" target="_blank" rel="noopener noreferrer">http://localhost:7000</a></td>
<td>否</td>
</tr>
<tr>
<td><a href="http://localhost:5000" target="_blank" rel="noopener noreferrer">http://localhost:5000</a></td>
<td><a href="http://127.0.0.1:5000" target="_blank" rel="noopener noreferrer">http://127.0.0.1:5000</a></td>
<td>否</td>
</tr>
<tr>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a></td>
<td><a href="http://baidu.com" target="_blank" rel="noopener noreferrer">baidu.com</a></td>
<td>否</td>
</tr>
<tr>
<td>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093517.jpg" alt="" loading="lazy"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>同源策略对 ajax 的跨域限制的最为<em>凶狠</em>，默认情况下，它不允许 ajax 访问跨域资源</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093619.jpg" alt="" loading="lazy"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响</td>
<td></td>
<td></td>
</tr>
<tr>
<td>有多种方式解决跨域问题，常见的有：</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>代理，常用</li>
<li>CORS，常用</li>
<li>JSONP<br>
无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</li>
</ul>
<h3> 跨域解决办法 1-代理</h3>
<p>对于前端开发而言，大部分的跨域问题，都是通过代理解决的</p>
<p>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</p>
<p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093737.jpg" alt="" loading="lazy"></p>
<p>在实际开发中，只需要对开发服务器稍加配置即可完成</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 解决跨域问题方法 2-JSONP</h3>
<p>在 CORS 出现之前，人们想了一种奇妙的办法来实现跨域，这就是 JSONP。<br>
要实现 JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br>
JSONP 的做法是：当需要跨域请求时，不使用 AJAX，转而生成一个 script 元素去请求服务器，由于浏览器并不阻止 script 元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段 JS 代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094003.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 跨域解决方法 3-CORS</h3>
<p>CORS 是基于 http1.1 的一种跨域解决方案，它的全称是 Cross-Origin Resource Sharing，跨域资源共享。<br>
它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094034.jpg" alt="" loading="lazy"><br>
而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p>
<p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p>
<p>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p>
<ul>
<li>简单请求</li>
<li>需要预检的请求</li>
<li>附带身份凭证的请求<br>
这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br>
下面分别说明三种请求模式的具体规范。</li>
</ul>
<p><code>简单请求</code><br>
当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p>
<h3> 简单请求的判定</h3>
<p>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p>
<ol>
<li>求方法属于下面的一种：</li>
</ol>
<ul>
<li>get</li>
<li>post</li>
<li>head</li>
</ul>
<ol start="2">
<li>请求头仅包含安全的字段，常见的安全字段如下：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>DownLink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
<ol start="3">
<li>请求头如果包含 Content-Type，仅限下面的值之一：</li>
</ol>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded<br>
<code>如果以上三个条件同时满足，浏览器判定为简单请求。</code></li>
</ul>
<h3> 简单请求的交互规范</h3>
<p>当浏览器判定某个 ajax 跨域请求是简单请求时，会发生以下的事情</p>
<ol>
<li>求头中会自动添加 Origin 字段<br>
比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域<br>
fetch('<a href="http://crossdomain.com/api/news" target="_blank" rel="noopener noreferrer">http://crossdomain.com/api/news</a>');<br>
请求发出后，请求头会是下面的格式：</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到最后一行没，Origin 字段会告诉服务器，是哪个源地址在跨域请求 2. 服务器响应头中应包含 Access-Control-Allow-Origin<br>
当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加 Access-Control-Allow-Origin 字段<br>
该字段的值可以是：</p>
<ul>
<li>*：表示我很开放，什么人我都允许访问</li>
<li>具体的源：比如<a href="http://my.com" target="_blank" rel="noopener noreferrer">http://my.com</a>，表示我就允许你访问</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设服务器做出了以下的响应：<br>
``HTTP/1.1 200 OK<br>
Date: Tue, 21 Apr 2020 08:03:35 GMT<br>
...<br>
Access-Control-Allow-Origin: <a href="http://my.com" target="_blank" rel="noopener noreferrer">http://my.com</a><br>
...</p>
<p>消息体中的数据<br>
<code>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作 下图简述了整个交互过程 ![](https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094943.jpg)</code>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。``<br>
但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>
<ul>
<li>浏览器发送预检请求，询问服务器是否允许</li>
<li>服务器允许</li>
<li>浏览器发送真实请求</li>
<li>服务器完成真实的响应<br>
比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p>
<ol>
<li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p>
<p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p>
<p>预检请求没有请求体，它包含了后续真实请求要做的事情<br>
预检请求有以下特征：</p>
<ul>
<li>请求方法为 OPTIONS</li>
<li>没有请求体</li>
<li>请求头中包含 - 请求方法为 OPTIONS<br>
没有请求体<br>
请求头中包含 - Access-Control-Request-Method：后续的真实请求将使用的请求方法 - Access-Control-Request-Headers：后续的真实请求会改动的请求头</li>
</ul>
<ol start="2">
<li>服务器允许<br>
服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p>
<ul>
<li>Access-Control-Allow-Origin：和简单请求一样，表示允许的源</li>
<li>Access-Control-Allow-Methods：表示允许的后续真实的请求方法</li>
<li>Access-Control-Allow-Headers：表示允许改动的请求头</li>
<li>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li>
</ul>
<ol start="3">
<li>浏览器发送真实请求<br>
预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>服务器响应真实请求</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，当完成预检之后，后续的处理与简单请求相同<br>
下图简述了整个交互过程<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211095559.jpg" alt="" loading="lazy"></p>
<p><code>一个额外的补充</code><br>
在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br>
<code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 学习总结</h3>
<p>本周主要还是以考试复习为重，学习了 CORS 关于跨域的产生和解决办法</p>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093517.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>electron入门</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/electron.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/electron.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">electron入门</source>
      <description>#1. 简介 官网 Electron 是由 GitHub 众多开发者开发的一个开源项目，能够使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序 2. 五分钟快速上手 2.1 安装 electron 初始化 package.json 文件 npm init</description>
      <category>记录</category>
      <pubDate>Sun, 21 May 2023 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>#1. 简介</p>
<ul>
<li><a href="https://www.electronjs.org/" target="_blank" rel="noopener noreferrer">官网</a></li>
<li>Electron 是由 GitHub 众多开发者开发的一个开源项目，能够使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</li>
</ul>
<h1> 2. 五分钟快速上手</h1>
<h2> 2.1 安装 electron</h2>
<p>初始化 package.json 文件</p>
<ul>
<li>npm init</li>
</ul>
<p>安装 electron</p>
<ul>
<li>cnpm I electron –S</li>
</ul>
<h2> 2.2 配置为入口文件</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.3 创建 main.js 文件</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.4 创建窗口</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 3. 自动刷新页面</h1>
<ul>
<li>
<p>安装插件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在入口引入插件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h1> 4. 主进程和渲染进程</h1>
<p>Electron 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为<strong>主进程</strong>。 在主进程中运行的脚本通过创建 web 页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。</p>
<p>由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它的叫<strong>渲染进程</strong>的进程中。</p>
<p>在普通的浏览器中，web 页面无法访问操作系统的原生资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。</p>
<p>ctrl+shift+i 打开渲染进程调试</p>
<p>默认打开调试</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 5. 自定义原生菜单</h1>
<h2> 5.1 自定义菜单</h2>
<p>详细文档：<a href="https://www.electronjs.org/docs/api/menu" target="_blank" rel="noopener noreferrer">https://www.electronjs.org/docs/api/menu</a></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.2 给菜单定义点击事件</h2>
<p>1、点击打开新窗口</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、点击打开浏览器</p>
<p><code>shell</code> 模块提供了集成其他桌面客户端的关联功能.</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.3 抽离菜单定义</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 打开调式</h4>
<p>mainWindow.webContents.openDevTools()</p>
<h2> 5.4 自定义顶部菜单</h2>
<ul>
<li>
<p>通过 frame 创建无边框窗口</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>自定义窗口</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加-webkit-app-region: drag;实现拖拽</p>
</li>
</ul>
<h2> 5.5 点击创建新窗口</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>能够在 html 中使用 node 方法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.6 点页面打开浏览器</h2>
<ul>
<li>
<p>html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>js</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h1> 6. 打开对话框读取文件</h1>
<h2> 6.1 读取文件</h2>
<ul>
<li>
<p>定义点击事件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>定义事件函数</p>
<p>打开对话框文档：<a href="https://www.electronjs.org/docs/api/dialog" target="_blank" rel="noopener noreferrer">https://www.electronjs.org/docs/api/dialog</a></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 6.2 保存文件</h2>
<ul>
<li>
<p>定义点击事件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>事件函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h1> 7. 定义快捷键</h1>
<h2> 7.1 主线程定义</h2>
<ul>
<li>
<p>引入</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在 ready 中注册快捷键</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>定义快捷键最大、最小、关闭窗口</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 7.2 渲染进程定义</h2>
<ul>
<li>
<p>通过 remote 注册</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h1> 8. 渲染进程和主线程通讯</h1>
<ul>
<li>
<p>定义按钮</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>事件函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>主线程定义事件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>传参</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>接收参数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h1> 09. electron 打包</h1>
<ul>
<li>
<p>安装 electron-packager</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>添加打包任务</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h1> 10 .electron 结合框架开发</h1>
<ul>
<li>
<p>利用 vue 脚手架初始化项目</p>
</li>
<li>
<p>在项目中安装 electron</p>
<p>cnpm i electron</p>
</li>
<li>
<p>添加 electron 启动配置</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>配置 main.js</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>加载 vue 项目</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h1> </h1>
]]></content:encoded>
    </item>
    <item>
      <title>git命令</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%91%BD%E4%BB%A4.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%91%BD%E4%BB%A4.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">git命令</source>
      <description>导航 — 跳到之前的分支 git checkout -</description>
      <category>记录</category>
      <pubDate>Sun, 05 Feb 2023 08:31:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 导航 — 跳到之前的分支</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 查看历史</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 回退操作</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 清理仓库</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 查看我的分支与 master 的不同</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>腾讯云_宝塔面板部署hexo</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo%E9%83%A8%E7%BD%B2.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo%E9%83%A8%E7%BD%B2.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">腾讯云_宝塔面板部署hexo</source>
      <description>前提 已经搭建好 hexo 博客，并将 hexo 部署到 GitHub 已经购买好云服务器 已经购买好域名（没有的也可以用 IP 地址访问） 安装宝塔面板 可以在服务器预装系统选择 宝塔面板 或者对服务器进行重装系统 重装完成建议 重置一下服务器登录密码</description>
      <category>Hexo</category>
      <pubDate>Sun, 20 Nov 2022 11:02:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前提</h2>
<ul>
<li>已经搭建好 hexo 博客，并将 hexo 部署到 GitHub</li>
<li>已经购买好云服务器</li>
<li>已经购买好域名（没有的也可以用 IP 地址访问）</li>
</ul>
<h2> 安装宝塔面板</h2>
<ul>
<li>可以在服务器预装系统选择 宝塔面板</li>
<li>或者对服务器进行重装系统<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120095748.png" alt="" loading="lazy"><br>
重装完成建议 重置一下服务器登录密码<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120100041.png" alt="" loading="lazy"></li>
</ul>
<h2> 进入腾讯云的控制台</h2>
<p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120100225.png" alt="" loading="lazy"><br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120100345.png" alt="" loading="lazy"><br>
输入 <code>sudo /etc/init.d/bt default</code> 可以查看宝塔控制面板地址，<br>
下方有账号密码，最好记录下来</p>
<p>进入宝塔 登录输入刚刚的账号密码<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120100753.png" alt="" loading="lazy"><br>
进入之后 直接点击一键安装默认推荐的软件<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/9b27621822492f5e864a38f1a14a4cfa.png" alt="" loading="lazy"></p>
<h2> 安装并配置 git 仓库</h2>
<p>在远程服务器上配置好 Git 仓库后，才能将本地的 hexo push 到远端。</p>
<ol>
<li>打开服务器控制台<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120101422.png" alt="" loading="lazy"><br>
若当前账号不是 root 则通过<code>sudo su root</code>命令切换到 root</li>
<li>安装 git<br>
<code>yum install git</code></li>
<li>创建 Git 账户</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>编辑/etc/sudoers 文件</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="5">
<li>按<code>i</code>键进入编辑模式, 找到 root ALL=(ALL) ALL 在其下方加入</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120101955.png" alt="" loading="lazy"><br>
输入完成后按<code>esc</code>，再输入<code>:wq</code>，保存退出</p>
<ol start="6">
<li>更变/etc/sudoers 权限</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="7">
<li>设置 git 账户密码</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意:<code>输入密码，输入的时候是看不到任何显示的，输完回车即可</code>。</p>
<ol start="8">
<li>切换至 <code>git 用户</code>，创建<code>~/.ssh</code>文件夹和<code>~/.ssh/authorized_keys</code>文件</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样 i 进入编辑模式，把之前本地准备的 id_rsa.pub 文件中的公钥复制进去，按 esc 后，输入:wq 保存。 9. 更改权限</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成之后 接下来创建 Git 仓库</p>
<h2> 创建 Git 仓库</h2>
<p>在服务端控制台进行操作</p>
<ol>
<li>切换<code>root</code>用户</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>创建 repo 作为仓库目录，并加权限</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>创建 hexo 目录作为网站根目录</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>创建一个空白的 git 仓库</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>编辑一个 Git 钩子</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按<code>i</code>进入编辑模式，添加下面的代码，按<code>esc</code>输入<code>:wq</code> 保存</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6">
<li>更改权限</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 宝塔网站配置</h2>
<p>点击添加站点<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120103418.png" alt="" loading="lazy"><br>
配置<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120103313.png" alt="" loading="lazy"><br>
根目录 选择刚刚创建的 hexo 文件夹<br>
点击提交</p>
<h2> 本地推送</h2>
<p>在博客目录中配置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成后，可直接 hexo 三连到自己的服务器。简单快捷。</p>
<p>之后就能通过服务器 IP 地址，访问博客了 默认是 80 端口<br>
所以直接输入服务器 IP 就能访问了</p>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20221120095748.png" type="image/png"/>
    </item>
    <item>
      <title>html的小技巧</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">html的小技巧</source>
      <description>使用 capture 属性打开设备摄像头 正如 input 标签具有 email、text 和 password 属性一样，我们也可以通过一些属性打开移动设备的摄像头以捕获图像。 那就是 capture 属性，属性值有两个： user 用于前置摄像头 environment 用于后置摄像头 &amp;lt;input type=&amp;quot;file&amp;quot; capture=&amp;quot;user&amp;quot; accept=&amp;quot;image/*&amp;quot; /&amp;gt;</description>
      <category>记录</category>
      <pubDate>Sun, 23 Oct 2022 11:02:21 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 使用 capture 属性打开设备摄像头</h3>
<p>正如 input 标签具有 email、text 和 password 属性一样，我们也可以通过一些属性打开移动设备的摄像头以捕获图像。<br>
那就是 capture 属性，属性值有两个：</p>
<ul>
<li>user 用于前置摄像头</li>
<li>environment 用于后置摄像头</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 网站自动刷新</h3>
<p>你可以在 head 标签中将网站设置为定时刷新！</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 激活拼写检查</h3>
<p>你可以使用 HTML 的 spellcheck 属性并将其设置为 true 以激活拼写检查。使用 lang 属性指定待检查的语言。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 指定要上传的文件类型</h3>
<p>你可以使用 accept 属性在 input 标签中指定允许用户上传的文件类型。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 阻止浏览器翻译</h3>
<p>将 translate 属性设置为 no 会阻止浏览器翻译该内容。如果你不想翻译某个短语或单词，例如 logo、公司或品牌名称，那就可以应用这个属性。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 在 input 标签中输入多个项目</h3>
<p>这可以通过 multiple 属性来完成。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 为视频创建海报（缩略图）</h3>
<p>使用 poster 属性，我们可以在视频加载时，或者在用户点击播放按钮之前，显示指定的缩略图。</p>
<p>如果不指定图片，则默认使用视频的第一帧作为缩略图。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 点击链接自动下载）</h3>
<p>如果你希望在单击目标资源的链接时下载特定资源，那就添加 download 属性。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JS基础</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS基础</source>
      <description>script 元素 async:可选，表示应该立即开始下载脚本，但是不能阻止其他页面动作，比如下载资源挥着等待其他脚本加载，只对外部脚本有效， charset：可选，使用 src 指定的代码字符集，这个属性很少使用，大多数浏览器不在乎它的值。 corssorigin:可选，配置相关请求的 cors（跨源资源共享）设置，默认不使用 CORS, crossorigin=&amp;quot;use-credentials&amp;quot;设置凭据标志，意味着出站请求会包含凭据， defer:可选。表示在问达能解析和显示完成后，再执行脚本是没有有问题的。只对外部脚本有效， integrity:可选允许比对接收到的资源和指定的加密协议以验证子资源的完整性，如果接受到的资源的签名，与这个属性指定的签名不匹配则页面报错,脚本不会执行，这个属性可以用与确保内容分发网络不会提供恶意内容 src:可选。表示要执行的代码的外部文件 type:可选，用于指定代码块中的语言类型，按照管理，这个始终都是“text/JavaScript”。如果这个值时“module”则代码会被当成 ES6 模块， 包含在 script 标签里的内容，会从上至下解释，在&amp;lt;\script&amp;gt;元素中的代码被执行完毕之前，页面的其余内容不会被加载，也不会被显示，就形成了阻塞 在使用行内&amp;lt;\script&amp;gt;代码时，注意代码中崩出现字符串&amp;lt;\script&amp;gt;。比如以下代码， 会导致浏览器报错，浏览器解析行内脚本会将其当乘结束的&amp;lt;\script&amp;gt;的&amp;lt;\script&amp;gt;标签，想避免这个问题，只需要转义字符\即可</description>
      <category>记录</category>
      <pubDate>Mon, 21 Mar 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> script 元素</h1>
<ol>
<li>async:可选，表示应该立即开始下载脚本，但是不能阻止其他页面动作，比如下载资源挥着等待其他脚本加载，只对外部脚本有效，</li>
<li>charset：可选，使用 src 指定的代码字符集，这个属性很少使用，大多数浏览器不在乎它的值。</li>
<li>corssorigin:可选，配置相关请求的 cors（跨源资源共享）设置，默认不使用 CORS, crossorigin="use-credentials"设置凭据标志，意味着出站请求会包含凭据，</li>
<li>defer:可选。表示在问达能解析和显示完成后，再执行脚本是没有有问题的。只对外部脚本有效，</li>
<li>integrity:可选允许比对接收到的资源和指定的加密协议以验证子资源的完整性，如果接受到的资源的签名，与这个属性指定的签名不匹配则页面报错,脚本不会执行，这个属性可以用与确保内容分发网络不会提供恶意内容</li>
<li>src:可选。表示要执行的代码的外部文件</li>
<li>type:可选，用于指定代码块中的语言类型，按照管理，这个始终都是“text/JavaScript”。如果这个值时“module”则代码会被当成 ES6 模块，<br>
包含在 script 标签里的内容，会从上至下解释，在&lt;\script&gt;元素中的代码被执行完毕之前，页面的其余内容不会被加载，也不会被显示，就形成了阻塞<br>
在使用行内&lt;\script&gt;代码时，注意代码中崩出现字符串&lt;\script&gt;。比如以下代码，<br>
会导致浏览器报错，浏览器解析行内脚本会将其当乘结束的&lt;\script&gt;的&lt;\script&gt;标签，想避免这个问题，只需要转义字符\即可</li>
</ol>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样修改之后就可以被浏览器完全解释，不会导致任何错误， 8. 在解释外还不 JavaScript 文件时页面也会阻塞，（阻塞时间包括文件的下载时间，）在 XHTML 可以忽略结束标签， 9. 另外使用了 src 属性的&lt;\script&gt;的元素不应该在其内部写入代码，如果两种方式都使用的话，则浏览器只会下载执行脚本，而忽略内部代码， 10. &lt;\script&gt;最为强大，同时也备受争议的特性时，它可以包含来自外部域的 JavaScript 代码，与 img 的 src 很像<br>
"&lt;\script src='<a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a>'&gt;&lt;\script&gt;"</p>
<p>浏览器在计息这个资源时，会向 SRC 指定的地址发送一个 get 请求，以取得相应资源，这个初始的请求不受浏览器同源策略限制，但返回被执行的 JS 代码则受限制，当然请求仍然收父页面 HTTP/HTTPS 协议的限制</p>
<p>这就可能收到恶意的攻击，如果引用了别人服务器上的 JS 文件，就要格外小心，因为恶意的程序员，随时可能替换这个文件，在百翰外部与的 JS 文件时，要确保该域是自己所有的，或者该域是一个可靠的来源，&lt;\script&gt;时防范这种问题的一个武器，但是不是所有的浏览器都支持，这个属性，</p>
<p>不管包含的是什么代码，浏览器都会按照&lt;\script&gt;在页面中出现的顺序依次去解析他们，前提是他们没有使用 defer 和 async 属性，第二个&lt;\script&gt;代码会在第一个&lt;\script&gt;执行完毕之后进行，第三个会在第二个执行完毕之后进行，依次类推。</p>
<h1> 标签位置</h1>
<ol>
<li>过去所有的&lt;\script&gt;元素都放在 head 标签内部，如下面的例子，</li>
</ol>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种做法的主要目的，就是把外部的 CSS 和 JavaScript 文件都集中到一起，不过把所有 JavaScript 文件都放在头部，也就意味着必须把所有的 JavaScript 文件都加载完毕才会开始渲染页面，对于需要很多 JavaScript 文件的页面这回导致，渲染时间明显变长，在此期间页面窗口完全空白，为解决这个问题，现代 web 应用程序将所有的 Javascript 引用放到了&lt;\body&gt;元素中的页面内容之后，如下</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.推迟执行脚本<br>
defer 属性，这个属性表示这个脚本在执行的时候不会改变页面结构，完全可以等到整个页面解析完成以后，再运行，这个属性会告诉浏览器，应该立即下载，但执行会延迟，会等待 html 标签执行完毕之后，再执行 3.异步执行脚本<br>
async async 与 defer 相似，都只是用与外部脚本，都会告诉浏览器立即开始下载，不过与 defer 不同的是，async 并不能保证能按照出现的顺序执行，<br>
给脚本添加 async 的目的是告诉浏览器 ，不必等待脚本下载和执行完毕再加载页面，同样也不必等待脚本下载执行完毕。再去执行其他脚本，正因为如此异步脚本不应该在加载期间修改 DOM</p>
<p>4.动态加载脚本</p>
<p>这个方式不推荐，很影响性能，而且会造成混乱。</p>
<p>5.行内代码，与外部文件</p>
<p>这两种方式，比较推荐外部文件，有以下优点</p>
<p>一.可维护性</p>
<p>二.缓存，如果两个 html 文件用到相同的 JS 文件，浏览器会根据缓存机制，只加载一次。意味着网页的加载速度更快</p>
<p>三.适应未来，</p>
]]></content:encoded>
    </item>
    <item>
      <title>JS对象创建模式</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS对象创建模式</source>
      <description>对象创建模式有以下几种： 1.工厂模式 2.构造函数模式 3.原型模式 4.组合使用构造函数模式和原型模式 5.动态原型模式 6.寄生构造函数模式 7.稳妥构造函数模式 1.工厂模式 一种函数用函数来封装以特定接口创建对象的细节</description>
      <category>记录</category>
      <pubDate>Sun, 27 Mar 2022 08:31:40 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>对象创建模式有以下几种：</p>
<p><strong>1.工厂模式</strong></p>
<p><strong>2.构造函数模式</strong></p>
<p><strong>3.原型模式</strong></p>
<p><strong>4.组合使用构造函数模式和原型模式</strong></p>
<p><strong>5.动态原型模式</strong></p>
<p><strong>6.寄生构造函数模式</strong></p>
<p><strong>7.稳妥构造函数模式</strong></p>
<p>1.<strong>工厂模式</strong> 一种函数用函数来封装以特定接口创建对象的细节</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p>
<p>2.<strong>构造函数模式</strong></p>
<p>构造函数可以用来创建特定类型的对象，像 object 和 Array 这样的原生构造函数，可以自定义构造函数，从而定义对象的类型的属性和方法；还是上面的例子用构造函数重写如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样对象的类型就能够知道对象的类型</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方</p>
<p>3.<strong>原型模式</strong></p>
<p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原型的内容在上一篇博客种已经说过；</p>
<p>4.<strong>组合使用构造函数模式和原型模式</strong></p>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组</p>
<p>5.<strong>动态原型模式</strong></p>
<p>可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用动态原型模式时，不能使用对象字面量重写原型，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</strong></p>
<p>6.<strong>寄生构造函数模式</strong></p>
<p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊 数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。</p>
<p>6.<strong>稳妥构造函数模式</strong></p>
<p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p>
<blockquote>
<p>《Javascript 高级程序设计》</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>JS对象复制</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS对象复制</source>
      <description>我们知道，赋值运算符不会创建对象的副本，只会分配对它的引用，请看以下代码： let obj = { a: 1, b: 2, }; let copy = obj; obj.a = 5; console.log(copy.a); // Result // a = 5;</description>
      <category>记录</category>
      <pubDate>Sun, 27 Nov 2022 08:31:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们知道，赋值运算符不会创建对象的副本，只会分配对它的引用，请看以下代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>obj 变量是初始化的新对象的容器。copy 变量指向同一个对象，并且是该对象的引用。所以基本上这个{ a: 1, b: 2, }对象是在说现在有两种方法可以访问我：通过 obj 变量或 copy 变量以任何一种方式传递给我，并且你通过这些方式对我所做的任何操作都会影响我。</p>
<p>此方法消除了任何形式的不变性，如果原始对象被代码的另一部分使用，可能会导致 bug。</p>
<h2> 复制对象的简单方法</h2>
<p>复制对象的简单方法是遍历原始对象并一个接一个地复制每个属性。让我们看一下这段代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这里有几个问题：</p>
<ol>
<li>objCopy 对象有一个新的 Object.prototype 方法，不同于 mainObj 对象的原型方法，这不是我们想要的。我们想要的是原始对象的精确副本。</li>
<li>不复制属性描述符。值设置为 false 的“可写”描述符在 objCopy 对象中将为 true。<br>
上面的代码只复制了 mainObj 的可枚举属性。</li>
<li>如果原始对象中的属性之一是对象本身，那么它将在副本和原始对象之间共享，使它们各自的属性指向同一个对象。</li>
</ol>
<h2> 浅拷贝对象</h2>
<p>当源顶层属性在没有任何引用的情况下被复制并且存在一个值为对象并被复制为引用的源属性时，就称该对象为浅拷贝。如果源值是对对象的引用，那么它只会将该引用值复制到目标对象。</p>
<p>浅拷贝将复制顶层属性，但嵌套对象在原始（源）和副本（目标）之间共享.</p>
<h2> 使用 Object.assign()方法</h2>
<p>Object.assign()方法用于将所有可枚举自身属性的值从一个或多个源对象复制到目标对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到目前为止，我们制作了 obj 的副本。现在让我们看看是否存在不可变性：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码将 objCopy 对象中的属性 b 的值更改为 89，当我们在控制台中记录修改后的 objCopy 对象时，更改仅应用于 objCopy。最后一行代码检查 obj 对象是否仍然完整且未曾更改。如果是的话，意味着我们已经成功地创建了源对象的副本，而没有对其进行任何引用。</p>
<h3> Object.assign()的陷阱</h3>
<p>虽然我们成功创建了副本，并且一切似乎都运行良好，但还记得我们讨论过浅拷贝吗？看一个例子：<br>
let obj = {<br>
a: 1,<br>
b: {<br>
c: 2,<br>
},<br>
}</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么 obj.b.c = 30？<br>
嗯，这是 Object.assign()的一个陷阱。Object.assign 只制作浅拷贝。newObj.b 和 obj.b 两者共享对同一个对象的相同引用，因为没有制作单独的副本，而是复制了对同一个对象的引用。对那个对象的任何属性所做的任何更改都适用于使用该对象的所有引用。<br>
<code>注意：不能复制原型链上的属性和不可枚举的属性。</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>someObj 在 obj 的原型链上，所以它不会被复制。</li>
<li>属性 b 是不可枚举的属性。</li>
<li>属性 c 有一个可枚举的属性描述符，允许其成为可枚举。这就是属性 c 被复制的原因</li>
</ol>
<h3> 深度拷贝对象</h3>
<p>深拷贝将复制它遇到的每个对象。副本和原始对象不会共享任何内容。下面是使用 Object.assign()遇到的问题的解决方法。</p>
<h3> 使用 JSON.parse(JSON.stringify(object));</h3>
<p>这解决了我们之前遇到的问题。现在 newObj.b 有一个副本而不是引用！这是一种深度复制对象的方法。请看例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>陷阱<br>
不幸的是，此方法不能用于复制用户定义的对象方法。</p>
<h3> 复制对象方法</h3>
<p>到目前为止的示例中，我们还不能复制对象的方法。现在让我们尝试一下，如何来复制对象的方法。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果表明 Object.assign()可以用来复制对象方法，而 JSON.parse(JSON.stringify(obj))却不能。</p>
<h3> 复制 circular 对象</h3>
<p>circular 对象是具有引用自身属性的对象。让我们使用复制对象的方法来复制 circular 对象，看看它是否有效。</p>
<h3> 使用 JSON.parse(JSON.stringify(object))</h3>
<p>先试试 JSON.parse(JSON.stringify(object))：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：<br>
<code>JSON.parse(JSON.stringify(obj))</code>显然不适用于<code>circular</code>对象。</p>
<h3> 使用 Object.assign()</h3>
<p>再试试 Object.assign()：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p>
<p><code>Object.assign()</code>适用于浅拷贝<code>circular</code>对象，但不适用于深拷贝。</p>
<h3> 使用展开运算符(…)</h3>
<p>ES6 已经实现了用于数组解构赋值的 rest 元素和用于数组字面量的展开运算符。数组的展开运算符实现如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象初始值设定项中的扩展属性将自己的可枚举属性从源对象复制到目标对象。如果 ECMAScript 的 Stage 3 提案接受的话，那么复制对象变得非常容易：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JS引擎的执行机制</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS引擎的执行机制</source>
      <description>1.首先 JS 是单线程的 2.JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop Event loop 事件循环 先看一个例子如下: console.log(1); setTimeout(function () { console.log(2); }, 0); console.log(3);</description>
      <category>记录</category>
      <pubDate>Sat, 02 Apr 2022 20:06:12 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p><em><strong>1.首先 JS 是单线程的</strong></em></p>
<p><strong><em>2.JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop</em></strong></p>
<p>Event loop 事件循环</p>
<p>先看一个例子如下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的执行输出顺序是 1 3 2；</p>
<p>也就是说,setTimeout 里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p>
<p>JS 中有两类任务，一类是同步任务，一类是异步任务</p>
<p>按照这种分类方式:JS 的执行机制是</p>
<blockquote>
<p><strong>Event Table</strong>&nbsp; 就是个注册站：调用栈让 Event Table 注册一个函数，该函数会在达到条件后被调用。当指定的事情发生时，Event Table 会将这个函数移到 Event Queue。<strong>Event Queue</strong>其实就是个缓冲区域，这里的函数等着被调用并移到调用栈。</p>
</blockquote>
<ul>
<li>首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table</li>
<li>异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue</li>
<li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中</li>
</ul>
<p>以上三步循环执行,这就是 event loop；</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一种情况，假如在一个程序中，有许多个异步任务，那么先执行哪一个呢？；在异步任务中并不是按照进入事件队列的先后顺序去执行的；而是另有规定；</p>
<p>再举一个例子：如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这段代码中；第一个定时器是异步任务会被放到 event&nbsp; table 中；</p>
<p>new Promise 是同步任务，会被放到主线程中直 l 接执行打印</p>
<p>.then 里的函数是异步任务，被放到 event table</p>
<p>console.log('代码执行结束')；是同步代码被放到主线程中；直接执行；</p>
</blockquote>
<p>结果是：&nbsp; &nbsp; &nbsp; 马上执行 for 循环啦 --- 代码执行结束 --- 执行 then 函数啦 --- 定时器开始啦</p>
<p><strong>如果仅仅按照异步同步去判断执行流程是不足够的，不够准确,</strong></p>
<p>像上面的这个代码.then&nbsp; &nbsp; 和 &nbsp; &nbsp;setTimeout 都是异步的，但是执行结果并没有按照进入事件队列的顺序执行的，</p>
<p>而准确的划分方式是按照<strong>宏任务</strong>和<strong>微任务</strong>划分的</p>
<p>macro-task(宏任务)：包括整体代码 script，setTimeout,setInterval</p>
<p>micro-task(微任务)：promise，process,nextTick;</p>
<figure><img src="https://img-blog.csdnimg.cn/b93c9dddfb2246af9f5960c0edf540bd.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>首先执行 script 下的宏任务,遇到 setTimeout,将其放到宏任务的【队列】里（这个在下一个事件循环的宏任务里添加，不是在当前宏任务中添加的）</p>
<p>遇到 new Promise 直接执行,打印"马上执行 for 循环啦"</p>
<p>遇到 then 方法,是微任务,将其放到微任务的【队列里】</p>
<p>打印 "代码执行结束"</p>
<p>本轮宏任务执行完毕,查看本轮的微任务,发现有一个 then 方法里的函数, 打印"执行 then 函数啦"</p>
<p>到此,本轮的 event loop 全部完成。</p>
</blockquote>
<p>下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout 里的函数,执行打印"定时器开始啦了；</p>
<p><a href="https://segmentfault.com/a/1190000012806637" title="原内容地址，感谢博主的精心讲解！" target="_blank" rel="noopener noreferrer">原内容地址，感谢博主的精心讲解！</a></p>
<p>周总结：</p>
<p>这周在学习 js 高级的内容；内容可以说很多，可以学习的知识很深，我现在只是浅浅的明白一些内容；红宝书的内容很多；这周学习总体上理论上的东西比较多；接下来我会进行实践，实际操作一下更深层次的理解；闭包，对象创建模式；继承都没有进行实践操作过；也不太清楚什么时候会用</p>
<p>希望能够尽快进行前后端交互;让我多一些实战经验；实际操作可比看书能学到的多的多；这周感觉挺累的，需要稍稍调整一下，马上就要有新成员进来了；我们的压力大了一些，可不能让他们超越了已经学了几个月的我们，要不然就感觉我们学习效率很低；</p>
<p>加油继续努力（卷）；</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/b93c9dddfb2246af9f5960c0edf540bd.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16" type="image/"/>
    </item>
    <item>
      <title>JS语言基础（一）</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS语言基础（一）</source>
      <description>1.严格模式 严格模式是一种不同的 javascript 解析和执行的模型，如果要对整个脚本开启严格模式在脚本开头加上use strict虽然看起来没有复制给任何变量的字符串吗，但它其实是一个预处理指令，任何支持 JavaScript 的引擎看到就会切换到严格模式， 2.变量 var 关键字 let 关键字 const 关键字 3.暂时性死区 //name会被提升 console.log(name);//undefined var name=&amp;quot;小明&amp;quot;; //name不会提升 console.log(name)//报错 let name=&amp;quot;小明&amp;quot;;</description>
      <category>记录</category>
      <pubDate>Fri, 12 Nov 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1.严格模式</h2>
<p>严格模式是一种不同的 javascript 解析和执行的模型，如果要对整个脚本开启严格模式在脚本开头加上<code>use strict</code>虽然看起来没有复制给任何变量的字符串吗，但它其实是一个预处理指令，任何支持 JavaScript 的引擎看到就会切换到严格模式，</p>
<h2> 2.变量</h2>
<ul>
<li>var 关键字</li>
<li>let 关键字</li>
<li>const 关键字</li>
</ul>
<h2> 3.暂时性死区</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 let 声明之前的执行瞬间被称为。暂时性死区，在此阶段引用任何后面声明的变量都会抛出<code>ReferenceError</code></p>
<h2> 4.全局声明</h2>
<p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）;</p>
<h2> 声明风格及最佳实践</h2>
<ul>
<li>不使用 var</li>
<li>const 优先 ，let 次之</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>JS通过文件URL路径下载文件</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS通过文件URL路径下载文件</source>
      <description>const exportFile = (data, fileName, _this)=&amp;gt;{ 　// 地址不存在时，禁止操作 if(!data)return; // 下载文件并保存到本地 const callback = (data)=&amp;gt;{ 　　 // 创建a标签，使用 html5 download 属性下载， const link = document.createElement(&amp;apos;a&amp;apos;); 　　 // 创建url对象 const objectUrl = window.URL.createObjectURL(new Blob([data])); link.style.display=&amp;apos;none&amp;apos;; link.href=objectUrl; 　　 // 自定义文件名称， fileName 　　 link.download = fileName; 　　 document.body.appendChild(link); 　　 link.click(); 　　 // 适当释放url window.URL.revokeObjectURL(objectUrl); }; // 把接口返回的url地址转换为 blob const xhr = new XMLHttpRequest(); xhr.open(&amp;apos;get&amp;apos;, data, true); xhr.responseType = &amp;apos;blob&amp;apos;; xhr.onload = ()=&amp;gt; { 　　 // 返回文件流，进行下载处理 callback(xhr.response); }; xhr.send(); // 不要忘记发送 }; // ie和浏览器兼容模式会有问题，可以用下面代码调试。 　try{ exportFile(); // 调用方式 }catch(err){ // 兼容模式下，IE const exportBlob = new Blob([data]); if (navigator.userAgent.indexOf(&amp;apos;Trident&amp;apos;) &amp;gt; -1) { window.navigator.msSaveBlob(data, fileName); } else { exportFile(); // 调用方式 } };</description>
      <category>记录</category>
      <pubDate>Sun, 24 Jul 2022 16:39:55 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用方式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>linux常用命令</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">linux常用命令</source>
      <description>一、基本命令 1.1 关机和重启 关机 &amp;nbsp; &amp;nbsp; shutdown -h now &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 立刻关机 &amp;nbsp; &amp;nbsp; shutdown -h 5 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;5 分钟后关机 &amp;nbsp; &amp;nbsp; poweroff &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 立刻关机 重启 &amp;nbsp; &amp;nbsp; shutdown -r now &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 立刻重启 &amp;nbsp; &amp;nbsp; shutdown -r 5 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;5 分钟后重启 &amp;nbsp; &amp;nbsp; reboot &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 立刻重启</description>
      <category>记录</category>
      <pubDate>Sun, 17 Jul 2022 15:33:15 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p><strong>一、基本命令</strong><br>
1.1 关机和重启<br>
关机<br>
&nbsp; &nbsp; shutdown -h now &nbsp; &nbsp; &nbsp; &nbsp; 立刻关机<br>
&nbsp; &nbsp; shutdown -h 5 &nbsp; &nbsp; &nbsp; &nbsp;5 分钟后关机<br>
&nbsp; &nbsp; poweroff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立刻关机<br>
重启<br>
&nbsp; &nbsp; shutdown -r now &nbsp; &nbsp; &nbsp; &nbsp; 立刻重启<br>
&nbsp; &nbsp; shutdown -r 5 &nbsp; &nbsp; &nbsp; &nbsp;5 分钟后重启<br>
&nbsp; &nbsp; reboot &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立刻重启</p>
<h2> 1.2 帮助命令</h2>
<p>--help 命令<br>
&nbsp; shutdown --help：<br>
&nbsp; ifconfig --help：查看网卡信息</p>
<p>man 命令（命令说明书）&nbsp;<br>
&nbsp; man shutdown<br>
&nbsp; 注意：man shutdown 打开命令说明书之后，使用按键 q 退出</p>
<p><strong>二、目录操作命令</strong><br>
2.1 目录切换 cd<br>
命令：cd 目录</p>
<p>cd / &nbsp; &nbsp; &nbsp; &nbsp; 切换到根目录<br>
cd /usr &nbsp; &nbsp; &nbsp; &nbsp; 切换到根目录下的 usr 目录<br>
cd ../ &nbsp; &nbsp; &nbsp; &nbsp; 切换到上一级目录 或者 &nbsp;cd ..<br>
cd ~ &nbsp; &nbsp; &nbsp; &nbsp; 切换到 home 目录<br>
cd - &nbsp; &nbsp; &nbsp; &nbsp; 切换到上次访问的目录</p>
<p><strong>2.2 目录查看 ls [-al]</strong><br>
命令：ls [-al]</p>
<p>ls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 查看当前目录下的所有目录和文件<br>
ls -a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 查看当前目录下的所有目录和文件（包括隐藏的文件）<br>
ls -l 或 ll &nbsp; &nbsp; &nbsp; 列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>
ls /dir &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 查看指定目录下的所有目录和文件 &nbsp; 如：ls /usr</p>
<p><strong>2.3 目录操作【增，删，改，查】</strong><br>
2.3.1 创建目录【增】 mkdir<br>
命令：mkdir 目录</p>
<p>mkdir &nbsp; &nbsp;aaa &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在当前目录下创建一个名为 aaa 的目录<br>
mkdir &nbsp; &nbsp;/usr/aaa &nbsp; &nbsp; 在指定目录下创建一个名为 aaa 的目录</p>
<p><strong>2.3.2 删除目录或文件【删】rm</strong><br>
命令：rm [-rf] 目录</p>
<p>删除文件：<br>
rm 文件 &nbsp; &nbsp; &nbsp; &nbsp; 删除当前目录下的文件<br>
rm -f 文件 &nbsp; &nbsp; 删除当前目录的的文件（不询问）</p>
<p>删除目录：<br>
rm -r aaa &nbsp; &nbsp; 递归删除当前目录下的 aaa 目录<br>
rm -rf aaa &nbsp; &nbsp; 递归删除当前目录下的 aaa 目录（不询问）</p>
<p>全部删除：<br>
rm -rf * &nbsp; &nbsp; 将当前目录下的所有目录和文件全部删除<br>
rm -rf /* &nbsp; &nbsp;【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p>
<p>注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p>
<p>正在学习，，，</p>
<p>本周呢，还是以项目为主又完成了一些功能，马上就能做完了，加油</p>
]]></content:encoded>
    </item>
    <item>
      <title>随时切换node版本不是梦</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/nvm%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/nvm%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">随时切换node版本不是梦</source>
      <description>nvm 介绍 在工作中，我们可能同时在进行 2 个或者多个不同的项目开发，每个项目的需求不同，进而不同项目必须依赖不同版本的 NodeJS 运行环境，这种情况下，对于维护多个版本的 node 将会是一件非常麻烦的事情，nvm 就是为解决这个问题而产生的，他可以方便的在同一台设备上进行多个 node 版本之间切换。 nvm 的下载和使用 安装包地址：https://github.com/coreybutler/nvm-windows/releases</description>
      <category>记录</category>
      <pubDate>Thu, 13 Apr 2023 15:33:15 GMT</pubDate>
      <content:encoded><![CDATA[<h3> nvm 介绍</h3>
<p>在工作中，我们可能同时在进行 2 个或者多个不同的项目开发，每个项目的需求不同，进而不同项目必须依赖不同版本的 NodeJS 运行环境，这种情况下，对于维护多个版本的 node 将会是一件非常麻烦的事情，nvm 就是为解决这个问题而产生的，他可以方便的在同一台设备上进行多个 node 版本之间切换。</p>
<h3> nvm 的下载和使用</h3>
<p>安装包地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">https://github.com/coreybutler/nvm-windows/releases</a><br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230413154837.png" alt="" loading="lazy"></p>
<p>下载 windows 版本</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230413155112.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>点击下载好的压缩包 运行里面的 exe 文件进行安装</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230413155223.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>第一个路径选择的是安装目录<br>
第二个路径选择的是 node 的安装目录；<br>
<code>如果本身装有node，则选择node所在位置</code></p>
<h3> 选择淘宝镜像加速下载</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230413155504.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>编辑 settings.txt;不改变原来的内容在下方加上以下两行内容<br>
<code>node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/</code></p>
<h3> nvm 的操作</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是全部内容,不得不说感觉真的好用</p>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230413154837.png" type="image/png"/>
    </item>
    <item>
      <title>Promise.all() 的小技巧</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Promise.all() 的小技巧</source>
      <description>Promise 在处理异步操作时很有用。 JavaScript 提供了一个辅助函数 Promise.all(promisesArrayOrIterable)来同时并行处理多个 promise，并在单个聚合数组中获取结果。让我们看看它是如何工作的。 Promise.all() Promise.all() 接受一组 promises（或通常是一个可迭代的）。该函数返回一个 promise： const allPromise = Promise.all([promise1, promise2, ...]);</description>
      <category>记录</category>
      <pubDate>Sun, 06 Nov 2022 15:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Promise 在处理异步操作时很有用。<br>
JavaScript 提供了一个辅助函数 Promise.all(promisesArrayOrIterable)来同时并行处理多个 promise，并在单个聚合数组中获取结果。让我们看看它是如何工作的。</p>
<h2> Promise.all()</h2>
<p>Promise.all() 接受一组 promises（或通常是一个可迭代的）。该函数返回一个 promise：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后您可以使用 then-able 语法提取 Promise 解析的值：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或 async/await 语法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 所有的 Promise fulfilled</h2>
<p>为了研究如何 Promise.all() 工作，我将使用 2 个助手 -resolveTimeout(value, delay)和 rejectTimeout(reason, delay).</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>promises 数组的顺序直接影响结果的顺序。</p>
<h3> 一个 Promise rejects</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种行为 Promise.all([...])被命名为 fail-fast。如果 promises 数组中至少有一个 promise 拒绝，则 allPromise = Promise.all([...])rejects 返回的 promise 也会被拒绝。</p>
<h3> 结论</h3>
<p>Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个 Promise 实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>promise解决回调函数嵌套</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">promise解决回调函数嵌套</source>
      <description>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的 ajax 的异步造成的问题，还要在回调函数中去绑定事件，有了 promise 这些都不是事，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 promise 对象代表一个异步操作，有三种状态 pending(进行中)，fulfilled(已成功)，rejected(&amp;quot;已失败&amp;quot;)，异步操作的结果决定这个对象的状态， 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</description>
      <category>记录</category>
      <pubDate>Sun, 13 Mar 2022 11:16:14 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的 ajax 的异步造成的问题，还要在回调函数中去绑定事件，有了 promise 这些都不是事，有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p>promise 对象代表一个异步操作，有三种状态 pending(进行中)，fulfilled(已成功)，rejected("已失败")，异步操作的结果决定这个对象的状态，</p>
<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>基本用法</p>
<p>创建一个 promise 对象，</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img-blog.csdnimg.cn/f003286678cc48fd81dfb73761b53b1a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这我只是创建了一个对 promise 对象但是却执行了，Promise 新建后就会立即执行。</p>
<p>所以应该把 promise 对象放在函数了，比如单击事件函数，单机之后才会新建 promise 对象然后执行，</p>
<p>其中两个参数，resolve&nbsp; &nbsp;reject 是两个函数，是由 js 引擎提供的，不需要自己写</p>
<p>resolve 函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定 resolved 状态和<code>Promise</code>状态的回调函数。</p>
<p>promise 对象的 then 方法，可以将两个回调函数作为参数，第一个会回调函数就是当 promise 的状态为 resolve 的时候调用的并且可以接受传来的数据。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img-blog.csdnimg.cn/e76bc85121e2457a96cb4dc58ba1de38.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>状态变为 resolve 之后就会执行 then 方法的第一个回调函数，并且把数据也传了过来，在进行操作就行了，类似于这样在 Ajax 中请求成功就把返回数据用 resolve 函数传递，就会执行 then 方法的第一个回调函数，在回调函数中也可以再 return&nbsp; promise 对象，进行回调函数的执行，形成链式，如果不用 promise，在 Ajax 的回调函数中写就会形成多层嵌套，代码一直往右延申，不利于观察，用 promise 链式，可以代码让代码看起来更有条理，</p>
<p>这就我现在的理解，可能有错误，后续会改</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/f003286678cc48fd81dfb73761b53b1a.png" type="image/png"/>
    </item>
    <item>
      <title>PS学习总结</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">PS学习总结</source>
      <description>这周对 PS 进行了基础的学习，简单的操作，抠图，蒙版的使用，调色，各种工具的使用都应经学会了，其实 PS 大有可学，因为我不是专业的，仅仅学习了 PS 的一点皮毛，这些皮毛就已经够我用的了，这是用来找新做东西用的，希望我能够为招新做点什么，让宣传海报更加具有吸引力， 这周呢，在家学习感到是时间很是充足，想学什么都有时间，下一阶段要学习 node.js 这是一个用 js 做后端的一个基于 V8 的一个运行环境，感觉学完这个就能够自己做一整个项目了，既有前端，又有后端，我会更加努力的，这个的学习是对 JS 的基础的考验，平时会多看看红宝书，加强自己的基础知识，巩固一下，学好 node.js,就想做什么就做什么了，自己一个人就能完成前后端的工作,加油，不过最近要把考试课复习一下，还有一场考试加油！</description>
      <category>记录</category>
      <pubDate>Sat, 11 Jun 2022 16:10:55 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这周对 PS 进行了基础的学习，简单的操作，抠图，蒙版的使用，调色，各种工具的使用都应经学会了，其实 PS 大有可学，因为我不是专业的，仅仅学习了 PS 的一点皮毛，这些皮毛就已经够我用的了，这是用来找新做东西用的，希望我能够为招新做点什么，让宣传海报更加具有吸引力，</p>
<p>这周呢，在家学习感到是时间很是充足，想学什么都有时间，下一阶段要学习 node.js 这是一个用 js 做后端的一个基于 V8 的一个运行环境，感觉学完这个就能够自己做一整个项目了，既有前端，又有后端，我会更加努力的，这个的学习是对 JS 的基础的考验，平时会多看看红宝书，加强自己的基础知识，巩固一下，学好 node.js,就想做什么就做什么了，自己一个人就能完成前后端的工作,加油，不过最近要把考试课复习一下，还有一场考试加油！</p>
]]></content:encoded>
    </item>
    <item>
      <title>React Hooks</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20Hooks.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20Hooks.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">React Hooks</source>
      <description>useState() const [state, setState] = useState(initialState);</description>
      <category>React</category>
      <pubDate>Wed, 19 Jul 2023 12:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3> useState()</h3>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>useState 返回两个值，一个是带有初始值的变量，一个是更新这个变量的函数<br>
在第一次渲染的时候，返回的状态 state 与传入的第一个参数值相同。<br>
setState 函数用于更新 state, 当它接收一个新的 state 值的时候，会将组件的一次重新渲染加入队列，<br>
<strong>setState 执行渲染，如果是对象，里面的值必须是一个新对象</strong></p>
<h3> useEffect();</h3>
<p>两个参数，第一个参数是一个回调函数。在组件 DOM 加载完毕之后执行的函数，<br>
<code>可以rerurn 一个函数，这个函数是组件被重新渲染或者卸载时候执行</code></p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个函数式组件中可以存在多个 useEffect，按照顺序依次执行</p>
<h4> 用法</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>useEffect 还有第二个参数，作用是 useEffect 回调函数的执行受到那个状态 state 的影响，如果为空数组【】，<br>
则只在组件载入时执行一次。 组件卸载时执行内部的回调函数<br>
数组中是回调函数依赖的数据，若数据发生变化则在 DOM 渲染完后执行回调函数。</p>
<h3> 特殊场景 Hooks</h3>
<h4> useContext()</h4>
<p>首先创建 Context</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在根组件外面包裹 userContext</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在子组件中使用，直接读取外层传入的信息</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>当组件上层最近的&lt;MyContext.Provider&gt; 更新时 该Hooks 会触发重新渲染，并使用最新传递给&lt;MyContext.Provider&gt;的context 的value值</code><br>
举一个例子：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在父组件 App.tsx 中向内通过 Context 传递了一个 Student 信息，并且 age 属性是受 App.tsx 中 addage() 操控的，<br>
当在 App.tsx 中改变 age 的值，子组件也重新渲染，更新 age</p>
<h4> useReduce() （了解就行，不咋用）</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>useState 的替代品，<strong>useState</strong>保存的数据处理逻辑比较复杂时可以使用 useReducer 来将其进行拆分<br>
或者这次修改的 state 需要依赖之前的 state 时，也可以使用</p>
<h4> useCallback()</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个组件每次被加载 addsum 都会被定义一次，每次更新 addsum 也会重新定义一次，就造成了内存空间中有许多个 addsum，虽然函数会因为未被使用而被销毁，但是仍会有一下性能问题.</p>
<ul>
<li>useCallback 会返回一个函数的 memoized 的值</li>
<li>在依赖不变的情况下，多次定义的时候，返回的值时相同的，</li>
</ul>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 useCallback 将函数包裹住，第二个参数是依赖项，<br>
当点击按钮 触发 addsum 时，组件重新渲染，sum 变为 1，但是由于依赖项为【】空，useCallback 是由记忆的，addsum 不会发生变化，useCallback 返回的函数还是之前的那个函数，因为闭包的原因，返回的函数内部 sum 还是等于 0，所以在此点击按钮 触发 addsum（） sum 的还是 1， 这就是 被称为 <strong>闭包陷阱</strong><br>
这就造成 sum 只能加一次；<br>
接下来就是正确 ✔ 写法</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到目前为止，使用 useCallback 似乎并没有什么太大的价值，接下来看下面这段代码</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个没有被 useCallback,处理的函数，则更新 message 时，会重新定义 addsum（） 函数，<br>
因为子组件 Student 传入了 addsum 函数，子组件会重新渲染，控制台打印"子组件被渲染" ；</p>
<p>若使用经过 useCallback 包裹的 addsum 函数，依赖项是 sum ， 则更新 message 时，由于 useCallback 的记忆功能。不会再重新定义 addsum 函数，子组件不会被重新渲染。<br>
所以就防止了子组件的无效渲染，提高了性能</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 useCallback 和不使用 useCallback 定义一个函数是不会带来性能优化的；<br>
使用 useCallback 定义的函数，传递给子组件，防止造成没必要的渲染<br>
<code>通常使用useCallback 的目的是不希望组组件进行多次渲染，并不是为了函数及进行缓存</code><br>
闭包陷阱解决方案：</p>
<ol>
<li>正确填写依赖</li>
<li>使用 useRef，在组建多次渲染时返回的是同一个值</li>
</ol>
<h4> useMemo();</h4>
<p>先看一个案例</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当点击按钮时，counter 增加，会造成页面重新渲染，addsum（） 会再次执行，这样就造成了一定的性能开销<br>
useMemo 登场：useMemo 有两个参数，第一个参数是一个函数，第二个参数是一个数组，内部填入依赖项，<br>
useMemo 和 useCallback 很相似，useMemo 是对函数返回值做记忆，</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写，当 counter 变化时，addsum 不会再次执行，因为，没有发生变化，不再重复执行</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用法：</p>
<ol>
<li>对于大量进行计算的操作，是否有必要每次渲染都重新计算；</li>
<li>对于组件传递相同内容的对象时，使用 useMemo 进行性能优化</li>
</ol>
<h4> useRef()</h4>
<p>useRef() 返回一个 ref 对象，返回的 ref 对象在组件的整个生命周期保持不变；<br>
最常用的 ref 时两种用法：<br>
用法一：引入 DOM 元素；</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用法二：保存一个数据，这个对象在整个生命周期中可以保持不变，可以用来解决 useCallback 中无依赖状态下，造成的闭包陷阱问题</p>
<h4> useImperativeHandle</h4>
<p>不是很好理解 ,用于子组件向外暴露 ref，使用 useImperativeHandle 可以指定向外暴露的属性和方法</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此 Hooks 不常用，感觉主要用封装组件库，不让用户随意动里面的东西</p>
<h4> useLayoutEffect()</h4>
<ul>
<li>useLayoutEffect（） 会在渲染的内同更新到 DOM 之前执行，<strong>会阻塞 DOM 的更新</strong>；</li>
<li>useEffect（） 会在渲染的内容更新到 DOM 上之前执行，<strong>不会阻塞 DOM 的更新</strong></li>
</ul>
<p>接下来一个例子：判断值是否符合预设值，不合符则更新值；</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>useLayoutEffect（） 官方不建议使用，<br>
<img src="https://cdn.nlark.com/yuque/0/2023/png/26302696/1689758427564-67dc6d57-a56b-41ef-8e6b-f00dae97a651.png#averageHue=%23fdf7ee&amp;clientId=u5e12156c-1aef-4&amp;from=paste&amp;height=253&amp;id=u12f7b957&amp;originHeight=253&amp;originWidth=937&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18643&amp;status=done&amp;style=none&amp;taskId=ubd2be9c0-1922-4a36-9146-d45b3166660&amp;title=&amp;width=937" alt="image.png" loading="lazy"><br>
会阻塞 DOM 的更新</p>
]]></content:encoded>
      <enclosure url="https://cdn.nlark.com/yuque/0/2023/png/26302696/1689758427564-67dc6d57-a56b-41ef-8e6b-f00dae97a651.png#averageHue=%23fdf7ee&amp;clientId=u5e12156c-1aef-4&amp;from=paste&amp;height=253&amp;id=u12f7b957&amp;originHeight=253&amp;originWidth=937&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18643&amp;status=done&amp;style=none&amp;taskId=ubd2be9c0-1922-4a36-9146-d45b3166660&amp;title=&amp;width=937" type="image/"/>
    </item>
    <item>
      <title>React脚手架配置代理</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">React脚手架配置代理</source>
      <description>react 脚手架配置代理总结 方法一 在 package.json 中追加如下配置 &amp;quot;proxy&amp;quot;:&amp;quot;http://localhost:5000&amp;quot;</description>
      <category>React</category>
      <pubDate>Sun, 23 Apr 2023 15:33:15 GMT</pubDate>
      <content:encoded><![CDATA[<h1> react 脚手架配置代理总结</h1>
<h2> 方法一</h2>
<blockquote>
<p>在 package.json 中追加如下配置</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>优点：配置简单，前端请求资源时可以不加任何前缀。</li>
<li>缺点：不能配置多个代理。</li>
<li>工作方式：上述方式配置代理，当请求了 3000 不存在的资源时，那么该请求会转发给 5000 （优先匹配前端资源）</li>
</ol>
<h2> 方法二</h2>
<ol>
<li>
<p>第一步：创建代理配置文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>编写 setupProxy.js 配置具体代理规则：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li>
<li>缺点：配置繁琐，前端请求资源时必须加前缀。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>vue3源码本码-render</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/render.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/render.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">vue3源码本码-render</source>
      <description>import { ShapeFlags } from &amp;quot;@mini-vue/shared&amp;quot;; import { createComponentInstance } from &amp;quot;./component&amp;quot;; import { queueJob } from &amp;quot;./scheduler&amp;quot;; import { effect } from &amp;quot;@mini-vue/reactivity&amp;quot;; import { setupComponent } from &amp;quot;./component&amp;quot;; import { Fragment, normalizeVNode, Text } from &amp;quot;./vnode&amp;quot;; import { shouldUpdateComponent } from &amp;quot;./componentRenderUtils&amp;quot;; import { createAppAPI } from &amp;quot;./createApp&amp;quot;; export function createRenderer(options) { const { createElement: hostCreateElement, setElementText: hostSetElementText, patchProp: hostPatchProp, insert: hostInsert, remove: hostRemove, setText: hostSetText, createText: hostCreateText, } = options; const render = (vnode, container) =&amp;gt; { console.log(&amp;quot;调用 patch&amp;quot;) patch(null, vnode, container); }; function patch( n1, n2, container = null, anchor = null, parentComponent = null ) { // 基于 n2 的类型来判断 // 因为 n2 是新的 vnode const { type, shapeFlag } = n2; switch (type) { case Text: processText(n1, n2, container); break; // 其中还有几个类型比如： static fragment comment case Fragment: processFragment(n1, n2, container); break; default: // 这里就基于 shapeFlag 来处理 if (shapeFlag &amp;amp; ShapeFlags.ELEMENT) { console.log(&amp;quot;处理 element&amp;quot;); processElement(n1, n2, container, anchor, parentComponent); } else if (shapeFlag &amp;amp; ShapeFlags.STATEFUL_COMPONENT) { console.log(&amp;quot;处理 component&amp;quot;); processComponent(n1, n2, container, parentComponent); } } } function processFragment(n1: any, n2: any, container: any) { // 只需要渲染 children ，然后给添加到 container 内 if (!n1) { // 初始化 Fragment 逻辑点 console.log(&amp;quot;初始化 Fragment 类型的节点&amp;quot;); mountChildren(n2.children, container); } } function processText(n1, n2, container) { console.log(&amp;quot;处理 Text 节点&amp;quot;); if (n1 === null) { // n1 是 null 说明是 init 的阶段 // 基于 createText 创建出 text 节点，然后使用 insert 添加到 el 内 console.log(&amp;quot;初始化 Text 类型的节点&amp;quot;); hostInsert((n2.el = hostCreateText(n2.children as string)), container); } else { // update // 先对比一下 updated 之后的内容是否和之前的不一样 // 在不一样的时候才需要 update text // 这里抽离出来的接口是 setText // 注意，这里一定要记得把 n1.el 赋值给 n2.el, 不然后续是找不到值的 const el = (n2.el = n1.el!); if (n2.children !== n1.children) { console.log(&amp;quot;更新 Text 类型的节点&amp;quot;); hostSetText(el, n2.children as string); } } } function processElement(n1, n2, container, anchor, parentComponent) { if (!n1) { mountElement(n2, container, anchor); } else { // todo updateElement(n1, n2, container, anchor, parentComponent); } } function updateElement(n1, n2, container, anchor, parentComponent) { const oldProps = (n1 &amp;amp;&amp;amp; n1.props) || {}; const newProps = n2.props || {}; // 应该更新 element console.log(&amp;quot;应该更新 element&amp;quot;); console.log(&amp;quot;旧的 vnode&amp;quot;, n1); console.log(&amp;quot;新的 vnode&amp;quot;, n2); // 需要把 el 挂载到新的 vnode const el = (n2.el = n1.el); // 对比 props patchProps(el, oldProps, newProps); // 对比 children patchChildren(n1, n2, el, anchor, parentComponent); } function patchProps(el, oldProps, newProps) { // 对比 props 有以下几种情况 // 1. oldProps 有，newProps 也有，但是 val 值变更了 // 举个栗子 // 之前: oldProps.id = 1 ，更新后：newProps.id = 2 // key 存在 oldProps 里 也存在 newProps 内 // 以 newProps 作为基准 for (const key in newProps) { const prevProp = oldProps[key]; const nextProp = newProps[key]; if (prevProp !== nextProp) { // 对比属性 // 需要交给 host 来更新 key hostPatchProp(el, key, prevProp, nextProp); } } // 2. oldProps 有，而 newProps 没有了 // 之前： {id:1,tId:2} 更新后： {id:1} // 这种情况下我们就应该以 oldProps 作为基准，因为在 newProps 里面是没有的 tId 的 // 还需要注意一点，如果这个 key 在 newProps 里面已经存在了，说明已经处理过了，就不要在处理了 for (const key in oldProps) { const prevProp = oldProps[key]; const nextProp = null; if (!(key in newProps)) { // 这里是以 oldProps 为基准来遍历， // 而且得到的值是 newProps 内没有的 // 所以交给 host 更新的时候，把新的值设置为 null hostPatchProp(el, key, prevProp, nextProp); } } } function patchChildren(n1, n2, container, anchor, parentComponent) { const { shapeFlag: prevShapeFlag, children: c1 } = n1; const { shapeFlag, children: c2 } = n2; // 如果 n2 的 children 是 text 类型的话 // 就看看和之前的 n1 的 children 是不是一样的 // 如果不一样的话直接重新设置一下 text 即可 if (shapeFlag &amp;amp; ShapeFlags.TEXT_CHILDREN) { if (c2 !== c1) { console.log(&amp;quot;类型为 text_children, 当前需要更新&amp;quot;); hostSetElementText(container, c2 as string); } } else { // 看看之前的是不是 text if (prevShapeFlag &amp;amp; ShapeFlags.TEXT_CHILDREN) { // 先清空 // 然后在把新的 children 给 mount 生成 element hostSetElementText(container, &amp;quot;&amp;quot;); mountChildren(c2, container); } else { // array diff array // 如果之前是 array_children // 现在还是 array_children 的话 // 那么我们就需要对比两个 children 啦 patchKeyedChildren(c1, c2, container, parentComponent, anchor); } } } function patchKeyedChildren( c1: any[], c2: any[], container, parentAnchor, parentComponent ) { let i = 0; const l2 = c2.length; let e1 = c1.length - 1; let e2 = l2 - 1; const isSameVNodeType = (n1, n2) =&amp;gt; { return n1.type === n2.type &amp;amp;&amp;amp; n1.key === n2.key; }; while (i &amp;lt;= e1 &amp;amp;&amp;amp; i &amp;lt;= e2) { const prevChild = c1[i]; const nextChild = c2[i]; if (!isSameVNodeType(prevChild, nextChild)) { console.log(&amp;quot;两个 child 不相等(从左往右比对)&amp;quot;); console.log(`prevChild:${prevChild}`); console.log(`nextChild:${nextChild}`); break; } console.log(&amp;quot;两个 child 相等，接下来对比这两个 child 节点(从左往右比对)&amp;quot;); patch(prevChild, nextChild, container, parentAnchor, parentComponent); i++; } while (i &amp;lt;= e1 &amp;amp;&amp;amp; i &amp;lt;= e2) { // 从右向左取值 const prevChild = c1[e1]; const nextChild = c2[e2]; if (!isSameVNodeType(prevChild, nextChild)) { console.log(&amp;quot;两个 child 不相等(从右往左比对)&amp;quot;); console.log(`prevChild:${prevChild}`); console.log(`nextChild:${nextChild}`); break; } console.log(&amp;quot;两个 child 相等，接下来对比这两个 child 节点(从右往左比对)&amp;quot;); patch(prevChild, nextChild, container, parentAnchor, parentComponent); e1--; e2--; } if (i &amp;gt; e1 &amp;amp;&amp;amp; i &amp;lt;= e2) { // 如果是这种情况的话就说明 e2 也就是新节点的数量大于旧节点的数量 // 也就是说新增了 vnode // 应该循环 c2 // 锚点的计算：新的节点有可能需要添加到尾部，也可能添加到头部，所以需要指定添加的问题 // 要添加的位置是当前的位置(e2 开始)+1 // 因为对于往左侧添加的话，应该获取到 c2 的第一个元素 // 所以我们需要从 e2 + 1 取到锚点的位置 const nextPos = e2 + 1; const anchor = nextPos &amp;lt; l2 ? c2[nextPos].el : parentAnchor; while (i &amp;lt;= e2) { console.log(`需要新创建一个 vnode: ${c2[i].key}`); patch(null, c2[i], container, anchor, parentComponent); i++; } } else if (i &amp;gt; e2 &amp;amp;&amp;amp; i &amp;lt;= e1) { // 这种情况的话说明新节点的数量是小于旧节点的数量的 // 那么我们就需要把多余的 while (i &amp;lt;= e1) { console.log(`需要删除当前的 vnode: ${c1[i].key}`); hostRemove(c1[i].el); i++; } } else { // 左右两边都比对完了，然后剩下的就是中间部位顺序变动的 // 例如下面的情况 // a,b,[c,d,e],f,g // a,b,[e,c,d],f,g let s1 = i; let s2 = i; const keyToNewIndexMap = new Map(); let moved = false; let maxNewIndexSoFar = 0; // 先把 key 和 newIndex 绑定好，方便后续基于 key 找到 newIndex // 时间复杂度是 O(1) for (let i = s2; i &amp;lt;= e2; i++) { const nextChild = c2[i]; keyToNewIndexMap.set(nextChild.key, i); } // 需要处理新节点的数量 const toBePatched = e2 - s2 + 1; let patched = 0; // 初始化 从新的index映射为老的index // 创建数组的时候给定数组的长度，这个是性能最快的写法 const newIndexToOldIndexMap = new Array(toBePatched); // 初始化为 0 , 后面处理的时候 如果发现是 0 的话，那么就说明新值在老的里面不存在 for (let i = 0; i &amp;lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0; // 遍历老节点 // 1. 需要找出老节点有，而新节点没有的 -&amp;gt; 需要把这个节点删除掉 // 2. 新老节点都有的，—&amp;gt; 需要 patch for (i = s1; i &amp;lt;= e1; i++) { const prevChild = c1[i]; // 优化点 // 如果老的节点大于新节点的数量的话，那么这里在处理老节点的时候就直接删除即可 if (patched &amp;gt;= toBePatched) { hostRemove(prevChild.el); continue; } let newIndex; if (prevChild.key != null) { // 这里就可以通过key快速的查找了， 看看在新的里面这个节点存在不存在 // 时间复杂度O(1) newIndex = keyToNewIndexMap.get(prevChild.key); } else { // 如果没key 的话，那么只能是遍历所有的新节点来确定当前节点存在不存在了 // 时间复杂度O(n) for (let j = s2; j &amp;lt;= e2; j++) { if (isSameVNodeType(prevChild, c2[j])) { newIndex = j; break; } } } // 因为有可能 nextIndex 的值为0（0也是正常值） // 所以需要通过值是不是 undefined 或者 null 来判断 if (newIndex === undefined) { // 当前节点的key 不存在于 newChildren 中，需要把当前节点给删除掉 hostRemove(prevChild.el); } else { // 新老节点都存在 console.log(&amp;quot;新老节点都存在&amp;quot;); // 把新节点的索引和老的节点的索引建立映射关系 // i + 1 是因为 i 有可能是0 (0 的话会被认为新节点在老的节点中不存在) newIndexToOldIndexMap[newIndex - s2] = i + 1; // 来确定中间的节点是不是需要移动 // 新的 newIndex 如果一直是升序的话，那么就说明没有移动 // 所以我们可以记录最后一个节点在新的里面的索引，然后看看是不是升序 // 不是升序的话，我们就可以确定节点移动过了 if (newIndex &amp;gt;= maxNewIndexSoFar) { maxNewIndexSoFar = newIndex; } else { moved = true; } patch(prevChild, c2[newIndex], container, null, parentComponent); patched++; } } // 利用最长递增子序列来优化移动逻辑 // 因为元素是升序的话，那么这些元素就是不需要移动的 // 而我们就可以通过最长递增子序列来获取到升序的列表 // 在移动的时候我们去对比这个列表，如果对比上的话，就说明当前元素不需要移动 // 通过 moved 来进行优化，如果没有移动过的话 那么就不需要执行算法 // getSequence 返回的是 newIndexToOldIndexMap 的索引值 // 所以后面我们可以直接遍历索引值来处理，也就是直接使用 toBePatched 即可 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : []; let j = increasingNewIndexSequence.length - 1; // 遍历新节点 // 1. 需要找出老节点没有，而新节点有的 -&amp;gt; 需要把这个节点创建 // 2. 最后需要移动一下位置，比如 [c,d,e] -&amp;gt; [e,c,d] // 这里倒循环是因为在 insert 的时候，需要保证锚点是处理完的节点（也就是已经确定位置了） // 因为 insert 逻辑是使用的 insertBefore() for (let i = toBePatched - 1; i &amp;gt;= 0; i--) { // 确定当前要处理的节点索引 const nextIndex = s2 + i; const nextChild = c2[nextIndex]; // 锚点等于当前节点索引+1 // 也就是当前节点的后面一个节点(又因为是倒遍历，所以锚点是位置确定的节点) const anchor = nextIndex + 1 &amp;lt; l2 ? c2[nextIndex + 1].el : parentAnchor; if (newIndexToOldIndexMap[i] === 0) { // 说明新节点在老的里面不存在 // 需要创建 patch(null, nextChild, container, anchor, parentComponent); } else if (moved) { // 需要移动 // 1. j 已经没有了 说明剩下的都需要移动了 // 2. 最长子序列里面的值和当前的值匹配不上， 说明当前元素需要移动 if (j &amp;lt; 0 || increasingNewIndexSequence[j] !== i) { // 移动的话使用 insert 即可 hostInsert(nextChild.el, container, anchor); } else { // 这里就是命中了 index 和 最长递增子序列的值 // 所以可以移动指针了 j--; } } } } } function mountElement(vnode, container, anchor) { const { shapeFlag, props } = vnode; // 1. 先创建 element // 基于可扩展的渲染 api const el = (vnode.el = hostCreateElement(vnode.type)); // 支持单子组件和多子组件的创建 if (shapeFlag &amp;amp; ShapeFlags.TEXT_CHILDREN) { // 举个栗子 // render(){ // return h(&amp;quot;div&amp;quot;,{},&amp;quot;test&amp;quot;) // } // 这里 children 就是 test ，只需要渲染一下就完事了 console.log(`处理文本:${vnode.children}`); hostSetElementText(el, vnode.children); } else if (shapeFlag &amp;amp; ShapeFlags.ARRAY_CHILDREN) { // 举个栗子 // render(){ // Hello 是个 component // return h(&amp;quot;div&amp;quot;,{},[h(&amp;quot;p&amp;quot;),h(Hello)]) // } // 这里 children 就是个数组了，就需要依次调用 patch 递归来处理 mountChildren(vnode.children, el); } // 处理 props if (props) { for (const key in props) { // todo // 需要过滤掉vue自身用的key // 比如生命周期相关的 key: beforeMount、mounted const nextVal = props[key]; hostPatchProp(el, key, null, nextVal); } } // todo // 触发 beforeMount() 钩子 console.log(&amp;quot;vnodeHook -&amp;gt; onVnodeBeforeMount&amp;quot;); console.log(&amp;quot;DirectiveHook -&amp;gt; beforeMount&amp;quot;); console.log(&amp;quot;transition -&amp;gt; beforeEnter&amp;quot;); // 插入 hostInsert(el, container, anchor); // todo // 触发 mounted() 钩子 console.log(&amp;quot;vnodeHook -&amp;gt; onVnodeMounted&amp;quot;); console.log(&amp;quot;DirectiveHook -&amp;gt; mounted&amp;quot;); console.log(&amp;quot;transition -&amp;gt; enter&amp;quot;); } function mountChildren(children, container) { children.forEach((VNodeChild) =&amp;gt; { // todo // 这里应该需要处理一下 vnodeChild // 因为有可能不是 vnode 类型 console.log(&amp;quot;mountChildren:&amp;quot;, VNodeChild); patch(null, VNodeChild, container); }); } function processComponent(n1, n2, container, parentComponent) { // 如果 n1 没有值的话，那么就是 mount if (!n1) { // 初始化 component mountComponent(n2, container, parentComponent); } else { updateComponent(n1, n2, container); } } // 组件的更新 function updateComponent(n1, n2, container) { console.log(&amp;quot;更新组件&amp;quot;, n1, n2); // 更新组件实例引用 const instance = (n2.component = n1.component); // 先看看这个组件是否应该更新 if (shouldUpdateComponent(n1, n2)) { console.log(`组件需要更新: ${instance}`); // 那么 next 就是新的 vnode 了（也就是 n2） instance.next = n2; // 这里的 update 是在 setupRenderEffect 里面初始化的，update 函数除了当内部的响应式对象发生改变的时候会调用 // 还可以直接主动的调用(这是属于 effect 的特性) // 调用 update 再次更新调用 patch 逻辑 // 在update 中调用的 next 就变成了 n2了 // ps：可以详细的看看 update 中 next 的应用 // TODO 需要在 update 中处理支持 next 的逻辑 instance.update(); } else { console.log(`组件不需要更新: ${instance}`); // 不需要更新的话，那么只需要覆盖下面的属性即可 n2.component = n1.component; n2.el = n1.el; instance.vnode = n2; } } function mountComponent(initialVNode, container, parentComponent) { // 1. 先创建一个 component instance const instance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent )); console.log(`创建组件实例:${instance.type.name}`); // 2. 给 instance 加工加工 setupComponent(instance); setupRenderEffect(instance, initialVNode, container); } function setupRenderEffect(instance, initialVNode, container) { // 调用 render // 应该传入 ctx 也就是 proxy // ctx 可以选择暴露给用户的 api // 源代码里面是调用的 renderComponentRoot 函数 // 这里为了简化直接调用 render // obj.name = &amp;quot;111&amp;quot; // obj.name = &amp;quot;2222&amp;quot; // 从哪里做一些事 // 收集数据改变之后要做的事 (函数) // 依赖收集 effect 函数 // 触发依赖 function componentUpdateFn() { if (!instance.isMounted) { // 组件初始化的时候会执行这里 // 为什么要在这里调用 render 函数呢 // 是因为在 effect 内调用 render 才能触发依赖收集 // 等到后面响应式的值变更后会再次触发这个函数 console.log(`${instance.type.name}:调用 render,获取 subTree`); const proxyToUse = instance.proxy; // 可在 render 函数中通过 this 来使用 proxy const subTree = (instance.subTree = normalizeVNode( instance.render.call(proxyToUse, proxyToUse) )); console.log(&amp;quot;subTree&amp;quot;, subTree); // todo console.log(`${instance.type.name}:触发 beforeMount hook`); console.log(`${instance.type.name}:触发 onVnodeBeforeMount hook`); // 这里基于 subTree 再次调用 patch // 基于 render 返回的 vnode ，再次进行渲染 // 这里我把这个行为隐喻成开箱 // 一个组件就是一个箱子 // 里面有可能是 element （也就是可以直接渲染的） // 也有可能还是 component // 这里就是递归的开箱 // 而 subTree 就是当前的这个箱子（组件）装的东西 // 箱子（组件）只是个概念，它实际是不需要渲染的 // 要渲染的是箱子里面的 subTree patch(null, subTree, container, null, instance); // 把 root element 赋值给 组件的vnode.el ，为后续调用 $el 的时候获取值 initialVNode.el = subTree.el; console.log(`${instance.type.name}:触发 mounted hook`); instance.isMounted = true; } else { // 响应式的值变更后会从这里执行逻辑 // 主要就是拿到新的 vnode ，然后和之前的 vnode 进行对比 console.log(`${instance.type.name}:调用更新逻辑`); // 拿到最新的 subTree const { next, vnode } = instance; // 如果有 next 的话， 说明需要更新组件的数据（props，slots 等） // 先更新组件的数据，然后更新完成后，在继续对比当前组件的子元素 if (next) { // 问题是 next 和 vnode 的区别是什么 next.el = vnode.el; updateComponentPreRender(instance, next); } const proxyToUse = instance.proxy; const nextTree = normalizeVNode( instance.render.call(proxyToUse, proxyToUse) ); // 替换之前的 subTree const prevTree = instance.subTree; instance.subTree = nextTree; // 触发 beforeUpdated hook console.log(`${instance.type.name}:触发 beforeUpdated hook`); console.log(`${instance.type.name}:触发 onVnodeBeforeUpdate hook`); // 用旧的 vnode 和新的 vnode 交给 patch 来处理 patch(prevTree, nextTree, prevTree.el, null, instance); // 触发 updated hook console.log(`${instance.type.name}:触发 updated hook`); console.log(`${instance.type.name}:触发 onVnodeUpdated hook`); } } // 在 vue3.2 版本里面是使用的 new ReactiveEffect // 至于为什么不直接用 effect ，是因为需要一个 scope 参数来收集所有的 effect // 而 effect 这个函数是对外的 api ，是不可以轻易改变参数的，所以会使用 new ReactiveEffect // 因为 ReactiveEffect 是内部对象，加一个参数是无所谓的 // 后面如果要实现 scope 的逻辑的时候 需要改过来 // 现在就先算了 instance.update = effect(componentUpdateFn, { scheduler: () =&amp;gt; { // 把 effect 推到微任务的时候在执行 // queueJob(effect); queueJob(instance.update); }, }); } function updateComponentPreRender(instance, nextVNode) { // 更新 nextVNode 的组件实例 // 现在 instance.vnode 是组件实例更新前的 // 所以之前的 props 就是基于 instance.vnode.props 来获取 // 接着需要更新 vnode ，方便下一次更新的时候获取到正确的值 nextVNode.component = instance; // TODO 后面更新 props 的时候需要对比 // const prevProps = instance.vnode.props; instance.vnode = nextVNode; instance.next = null; const { props } = nextVNode; console.log(&amp;quot;更新组件的 props&amp;quot;, props); instance.props = props; console.log(&amp;quot;更新组件的 slots&amp;quot;); // TODO 更新组件的 slots // 需要重置 vnode } return { render, createApp: createAppAPI(render), }; } function getSequence(arr: number[]): number[] { const p = arr.slice(); const result = [0]; let i, j, u, v, c; const len = arr.length; for (i = 0; i &amp;lt; len; i++) { const arrI = arr[i]; if (arrI !== 0) { j = result[result.length - 1]; if (arr[j] &amp;lt; arrI) { p[i] = j; result.push(i); continue; } u = 0; v = result.length - 1; while (u &amp;lt; v) { c = (u + v) &amp;gt;&amp;gt; 1; if (arr[result[c]] &amp;lt; arrI) { u = c + 1; } else { v = c; } } if (arrI &amp;lt; arr[result[u]]) { if (u &amp;gt; 0) { p[i] = result[u - 1]; } result[u] = i; } } } u = result.length; v = result[u - 1]; while (u-- &amp;gt; 0) { result[u] = v; v = p[v]; } return result; }</description>
      <category>源码</category>
      <pubDate>Sat, 04 Mar 2023 20:30:14 GMT</pubDate>
      <content:encoded><![CDATA[<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Thymeleaf</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Thymeleaf.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Thymeleaf.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Thymeleaf</source>
      <description>Thymeleaf 概述 Thymeleaf 是一个 Java 模板引擎，支持 html、xml、text、javascript、css、raw 这几种模型。 使用 Thymeleaf 首先需要引入命名空间 &amp;lt;html&amp;nbsp;&amp;nbsp;xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;</description>
      <category>记录</category>
      <pubDate>Sun, 10 Apr 2022 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<ol>
<li>Thymeleaf 概述</li>
</ol>
<p>Thymeleaf 是一个 Java 模板引擎，支持 html、xml、text、javascript、css、raw 这几种模型。</p>
<p>使用 Thymeleaf 首先需要引入命名空间</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2.&nbsp; 基本使用方法</p>
<p>1⃣️ 引用 web 静态资源</p>
<p>Thymeleaf 通过”@{}”来引用 web 静态资源，例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2⃣️ 访问 model 模型中的数据，例如访问一个 user 对象的 name 属性</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3⃣️ 在 Javascript 中访问 model 模型数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段时间，感觉自己学习的还是太少，不会的很多，学无止境，各种模版都需要学习，现在开始了前后端交互，怎么合作，怎么合作好是现在我面临的问题，第一次交互，我觉得能后收获很多东西，希望能够顺利完成这次的任务。</p>
<p>之后会继续写静态页面，等后端接口能用了，在进行下一步</p>
]]></content:encoded>
    </item>
    <item>
      <title>Ts配置文件and泛型</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TS%E5%85%A5%E9%97%A8.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TS%E5%85%A5%E9%97%A8.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Ts配置文件and泛型</source>
      <description>tsconfig.json 配置 { /* 编译路径 **表示文件夹下的所有文件夹， *表示文件夹下的所有文件 */ &amp;quot;include&amp;quot;: [&amp;quot;./src/**/*&amp;quot;], /* 排除路径 不参加编译的文件路径 	默认值[”node_modules“,&amp;quot;bower_components&amp;quot;,&amp;quot;jspm_packages&amp;quot;] */ &amp;quot;exclude&amp;quot;: [&amp;quot;./hellow/**/*&amp;quot;] }</description>
      <category>记录</category>
      <pubDate>Sat, 06 May 2023 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<h3> tsconfig.json 配置</h3>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> compilerOptions 配置选项</h4>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 泛型（Generic）</h2>
<p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p>
<p>此时泛型便能够发挥作用；</p>
<p>举个例子：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中，test 函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</p>
<p>由于类型不确定所以参数和返回值均使用了 any，但是很明显这样做是不合适的：</p>
<p>首先使用 any 会关闭 TS 的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</p>
<h3> 泛型函数</h3>
<h4> 创建泛型函数</h4>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>&lt;T&gt;</code>就是泛型；</p>
<p>T 是我们给这个类型起的名字（不一定非叫 T），设置泛型后即可在函数中使用 T 来表示该类型；</p>
<p>所以泛型其实很好理解，就表示某个类型；</p>
<p>那么如何使用上边的函数呢？</p>
<h4> 使用泛型函数</h4>
<h5> 方式一（直接使用）：</h5>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用时可以直接传递参数使用，类型会由 TS 自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p>
<h5> 方式二（指定类型）：</h5>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以在函数后手动指定泛型；</p>
<h4> 函数中声明多个泛型</h4>
<p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用；</p>
<h3> 泛型类</h3>
<p>类中同样可以使用泛型：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 泛型继承</h3>
<p>除此之外，也可以对泛型的范围进行约束</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 T extends MyInter 表示泛型 T 必须是 MyInter 的子类，不一定非要使用接口类和抽象类同样适用；</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue3-reactive 浅谈</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Vue3-reactive 浅谈</source>
      <description>Vue2 和 Vue3 响应式的区别 Vue2 的响应式，利用了 ES5 的一个 API，object.defineProperty,它的基本用法是这样的 const obj = { name: &amp;quot;kw&amp;quot; }; Object.defineProperty(obj, key, { get() { return obj[key]; }, set(val) { obj[key] = val; }, });</description>
      <category>Vue</category>
      <pubDate>Sat, 25 Feb 2023 17:40:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3> Vue2 和 Vue3 响应式的区别</h3>
<p>Vue2 的响应式，利用了 ES5 的一个 API，object.defineProperty,它的基本用法是这样的</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就能拦截到对象属性的基本操作，比如访问属性和给属性设置新值。当拦截到访问属性时，可以做依赖收集；当监听到属性更改时，可以做派发更新，从而实现响应式。</p>
<p>它存在几个缺点：</p>
<ol>
<li>
<p>重写了对象的属性，性能较差；</p>
</li>
<li>
<p>只能拦截到对象属性的操作，不能处理数组。所以 Vue2 需要单独对数组数据进行处理。</p>
</li>
<li>
<p>对于属性的新增和删除，无法拦截到。所以额外提供了 $set 和 $delete 方法，整体不和谐。</p>
</li>
</ol>
<p><code>Vue3</code> 采用了 ES6 的 API <code>Proxy</code> 来实现响应式。由于该 API 不兼容 IE 浏览器，所以在使用 Vue3 开发时要考虑项目是否需要兼容 IE 系列。</p>
<h3> Proxy 和 Reflect</h3>
<p>先来看看 Proxy 的基本用法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>target</code>：用 <code>Proxy</code> 包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p>
<p><code>handler</code>：是一个对象，其声明了代理 target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。</p>
<p>简单示例</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>Proxy</code> 的使用其实和 <code>Object.defineProperty</code>是差不多的，也是能拦截到对象属性的一些操作。但它的特点是：</p>
<ol>
<li>
<p>不仅可以代理普通的对象，还可以代理数组，函数</p>
</li>
<li>
<p>不仅能拦截到 <code>get</code> 和 <code>set</code> 操作，还支持 <code>apply、delete</code> 等一共 13 种操作</p>
</li>
<li>
<p>不需要重写 <code>target</code>，性能更高</p>
</li>
</ol>
<p>再来看一下 <code>Reflect</code> 对象<br>
<code>Proxy</code> 和 <code>Reflect</code> 是一对好兄弟，形影不离。</p>
<p>按照 MDN 文档的说明：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，我们在使用 <code>Proxy</code> 时传入的 <code>handler</code> 参数，它所有的属性，在 Reflect 中都有一一对应的。比如上面我们说了 <code>Proxy</code> 对象的 handler 可以支持 <code>get</code> ，<code>get</code> ，<code>apply</code>，<code>delete</code> 操作，那么 <code>Reflect</code> 对象就提供了对应的静态方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初看起来，Reflect 的使用很繁琐，远不如传统的点语法来的方便简洁。确实如此，但是在这些 API 的设计上，它和 Proxy 拥有一致的属性和方法，所以搭配起来更加合适。再者，有些场景下，比如需要用到 receiver 参数时，此时就只有 Reflect 能堪大任了。</p>
<h3> reactive 的基本使用</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>reactive</code> 时需要注意的地方：</p>
<ol>
<li>只能实现对象数据的响应式</li>
<li>同一个对象，只会被代理一次</li>
<li>被代理过的对象，不会被再次代理</li>
<li>支持嵌套属性的响应式</li>
</ol>
<h3> 实现 reactive</h3>
<p>这是 Vue3 中一个最基础的响应式 API，它内部采用了 Proxy 来实现对象属性的拦截操作。</p>
<p>如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 无需多次代理</h3>
<p>前面我们提到，如果一个对象被代理过了，就无需再被代理。实现的思路就是利用缓存，将代理过的对象进行缓存，每当调用 reactive 方法时，先判断缓存中是否存在 target ；每次 target 被代理后，都将 target 和 proxy 放到缓存中： 利用 weakmap</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 嵌套代理</h3>
<p>Vue3 实现响应式采用的原则是懒代理，并不像 Vue2 那样在初始化时，就递归所有的属性进行属性重写。<br>
只有在访问到某个属性，且该属性是对象类型时，才会再进行一层响应式包装：<br>
到此，我们实现的 reactive 方法，就能监听到对象属性的访问和设置操作，从而在此时机做一些处理，从而实现响应式系统。同时也做了一些优化处理。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue2 笔记</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Vue2 笔记</source>
      <description>笔记 脚手架文件结构 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件</description>
      <category>Vue</category>
      <pubDate>Tue, 08 Nov 2022 15:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 笔记</h1>
<h2> 脚手架文件结构</h2>

<h2> 关于不同版本的 Vue</h2>
<ol>
<li>vue.js 与 vue.runtime.xxx.js 的区别：
<ol>
<li>vue.js 是完整版的 Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 这个配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</li>
</ol>
<h2> vue.config.js 配置文件</h2>
<ol>
<li>使用 vue inspect &gt; output.js 可以查看到 Vue 脚手架的默认配置。</li>
<li>使用 vue.config.js 可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh" target="_blank" rel="noopener noreferrer">https://cli.vuejs.org/zh</a></li>
</ol>
<h2> ref 属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id 的替代者）</li>
<li>应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ol>
<li>打标识：<code>&lt;h1 ref="xxx"&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref="xxx"&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2> props 配置项</h2>
<ol>
<li>
<p>功能：让组件接收外部传过来的数据</p>
</li>
<li>
<p>传递数据：<code>&lt;Demo name="xxx"/&gt;</code></p>
</li>
<li>
<p>接收数据：</p>
<ol>
<li>
<p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li>
<p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li>
<p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<blockquote>
<p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p>
</blockquote>
</li>
</ol>
<h2> mixin(混入)</h2>
<ol>
<li>
<p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li>
<p>使用方式：</p>
<p>第一步定义混合：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步使用混入：</p>
<p>​ 全局混入：<code>Vue.mixin(xxx)</code><br>
​ 局部混入：<code>mixins:['xxx']	</code></p>
</li>
</ol>
<h2> 插件</h2>
<ol>
<li>
<p>功能：用于增强 Vue</p>
</li>
<li>
<p>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li>
<p>定义插件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2> scoped 样式</h2>
<ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2> 总结 TodoList 案例</h2>
<ol>
<li>
<p>组件化编码流程：</p>
<p>​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。</p>
<p>​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​ 1).一个组件在用：放在组件自身即可。</p>
<p>​ 2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>​ (3).实现交互：从绑定事件开始。</p>
</li>
<li>
<p>props 适用于：</p>
<p>​ (1).父组件 ==&gt; 子组件 通信</p>
<p>​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li>
<p>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</p>
</li>
<li>
<p>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2> webStorage</h2>
<ol>
<li>
<p>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</p>
</li>
<li>
<p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li>
<p>相关 API：</p>
<ol>
<li>
<p><code>xxxxxStorage.setItem('key', 'value');</code><br>
该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li>
<p><code>xxxxxStorage.getItem('person');</code></p>
<p>​ 该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li>
<p><code>xxxxxStorage.removeItem('key');</code></p>
<p>​ 该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li>
<p><code> xxxxxStorage.clear()</code></p>
<p>​ 该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li>
<p>备注：</p>
<ol>
<li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage 存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li>
<li><code>JSON.parse(null)</code>的结果依然是 null。</li>
</ol>
</li>
</ol>
<h2> 组件的自定义事件</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li>
<p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</p>
</li>
<li>
<p>绑定自定义事件：</p>
<ol>
<li>
<p>第一种方式，在父组件中：<code>&lt;Demo @atguigu="test"/&gt;</code> 或 <code>&lt;Demo v-on:atguigu="test"/&gt;</code></p>
</li>
<li>
<p>第二种方式，在父组件中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p>
</li>
</ol>
<h2> 全局事件总线（GlobalEventBus）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2> 消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装 pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2> nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li>
</ol>
<h2> Vue 封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2> vue 脚手架配置代理</h2>
<h3> 方法一</h3>
<p>​ 在 vue.config.js 中添加如下配置：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3> 方法二</h3>
<p>​ 编写 vue.config.js 配置具体代理规则：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2> 插槽</h2>
<ol>
<li>
<p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li>
<p>使用方式：</p>
<ol>
<li>
<p>默认插槽：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>具名插槽：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>作用域插槽：</p>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p>
</li>
<li>
<p>具体编码：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<h2> Vuex</h2>
<h3> 1.概念</h3>
<p>​ 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3> 2.何时使用？</h3>
<p>​ 多个组件需要共享数据时</p>
<h3> 3.搭建 vuex 环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 4.基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改 vuex 中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3> 5.getters 的使用</h3>
<ol>
<li>
<p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3> 6.四个 map 方法的使用</h3>
<ol>
<li>
<p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<blockquote>
<p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3> 7.模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开启命名空间后，组件中读取 state 数据：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开启命名空间后，组件中读取 getters 数据：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开启命名空间后，组件中调用 dispatch</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开启命名空间后，组件中调用 commit</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 路由</h2>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key 是路径，value 是组件。</li>
</ol>
<h3> 1.基本使用</h3>
<ol>
<li>
<p>安装 vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写 router 配置项:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>实现切换（active-class 可配置高亮样式）</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>指定展示位置</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<h3> 2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3> 3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用 children 配置项：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>跳转（要写完整路径）：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<h3> 4.路由的 query 参数</h3>
<ol>
<li>
<p>传递参数</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>接收参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>简化跳转：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
</li>
</ol>
<h3> 6.路由的 params 参数</h3>
<ol>
<li>
<p>配置路由，声明接收 params 参数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>传递参数</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 7.路由的 props 配置</h3>
<p>​ 作用：让路由组件更方便的收到参数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.<code>&lt;router-link&gt;</code>的 replace 属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3> 9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：
<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3> 12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>独享守卫:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>组件内守卫：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 13.路由器的两种工作模式</h3>
<ol>
<li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li>
<li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li>
<li>hash 模式：
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history 模式：
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和 hash 模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li>
</ol>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>vue面试题-第一弹</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E9%9D%A2%E8%AF%95%E9%A2%98.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E9%9D%A2%E8%AF%95%E9%A2%98.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">vue面试题-第一弹</source>
      <description>组件间通信的方式 根据组件之间的关系讨论组件通信最为有效 父子组件 props/emit/emit/emit/parent/ref/$attrs</description>
      <category>Vue</category>
      <pubDate>Sun, 19 Mar 2023 10:06:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 组件间通信的方式</h3>
<p>根据组件之间的关系讨论组件通信最为有效</p>
<ol>
<li>父子组件</li>
</ol>
<ul>
<li>props/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">emit/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">t</span><span class="mord">/</span></span></span></span>parent/ref/$attrs</li>
</ul>
<ol start="2">
<li>兄弟组件</li>
</ol>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">root/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mord">/</span></span></span></span>parent/vuex/eventbus</li>
</ul>
<ol start="3">
<li>跨层级关系</li>
</ol>
<ul>
<li>eventbus / vuex / prpvate + inject</li>
</ul>
<h3> v-for 和 v-if 那个优先级更高</h3>
<ol>
<li>实践中 不应该把 v-for 和 v-if 放在一起</li>
<li>在 vue2 中，v-for 的优先级高于 v-if 把他们放在一起。输出的渲染函数中已可看出会限制性循环再判断条件，哪怕我们只渲染列表中的一小部分，也得在每次重新渲染的时候遍历整个列表，这会比较浪费，另外需要注意的是在 vue3 中则完全相反，v-if 的优先级大于 v-for，所以在执行 v-if 的时候，它调用的变量还不存在，就会导致异常</li>
<li>通常有两种情况会导致我们这样做</li>
</ol>
<ul>
<li>为了过滤列表中的项目，此时定义一个计算属性，让其返回过滤后的列表即可</li>
<li>为了避免渲染本应该隐藏的列表，</li>
</ul>
<ol start="4">
<li>文档中明确指出，永远不要把 v-if 和 v-for 同时用在同一个元素上面，显示这是不可行的</li>
<li>源码里面关于代码生成的部分，能够清晰得分看到是先出来 v-if 还是 v-for 顺序上 vue2 和 vue3 是相反的，但是不管怎么样，不能讲两个放在一起使用</li>
</ol>
<h3> 简述 vue 生命周期</h3>
<ol>
<li>每个 vue 组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到 dom 上，以及数据变化时的更新 dom，这个过程中会运行叫做生命周期的钩子函数，以便用户在特定时期添加自己的代码，</li>
<li>vue 生命周期总共可以分为 8 个阶段，创建前后，挂在前后，更新前后，卸载（销毁）前后，以及特殊场景的生命周期，vue3 中新增了三个用于调试和服务端渲染场景<br>
生命周期 activated activated keep-alive 缓存的组件激活时，<br>
deactivated deactivated keep-alive 缓存的组件停用时调用的<br>
errorCaptured errorCaptured 捕获一个来自子孙组件的错误时被调用<br>
----------- renderTracked 调试钩子，响应式依赖被收集时调用的<br>
----------- renderTriggered 调试钩子，响应式依赖被触发时调用的<br>
----------- serverPrefetch ssr only 组件实例在服务器上被渲染前调用<br>
beforeCreate :通常用于插件开发中执行一些初始化任务，<br>
created：组件初始化完毕，可以访问各种数据，获取接口数据等，<br>
mounted：dom 已创建，可以进行获取访问数据和 dom 元素，访问子组件，<br>
beforeUpdate：此时 view 层还未更新，更新后，所有状态已是最新，<br>
beforeunmounted:实例被销毁前调用，可用于一些定时器或者订阅的取消，<br>
unmounted:销毁一个实例，可清理它与其他实例的连接，解绑它的全部指令及事件，<br>
追问：setup 和 creatd 谁先执行;</li>
</ol>
<ul>
<li>setup 先执行，setup 中已经创建了组件实例,creatd 是创建之后，</li>
<li>setup 中为什么没有 beforeCreate 和 created，因为<br>
setup 中已经完成了组件实例的创建，所以没有这两个钩子，这两个钩子是专门为 options API 服务的</li>
</ul>
<h3> 双向绑定使用和原理</h3>
<ol>
<li>vue 中双向绑定是一个指令 v-model，可以绑定一个响应式数据到视图，同时视图中的变化能改变该值，</li>
<li>v-model 是语法糖，默认情况下相当于：value 和 @input 。使用 v-model 可以减少大量的繁琐的代码，提高开发效率</li>
</ol>
<h3> 了解 DIFF 算法</h3>
<ol>
<li>在新老虚拟 DOM 对比时： ● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 ● 如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除) ● 比较如果都有子节点，则进行 updateChildren，判断如何对这些新老节点的子节点进行操作（diff 核心）。 ● 匹配时，找到相同的子节点，递归比较子节点 在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从 O(n3)降低值 O(n)，也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</li>
</ol>
<h3> Vue 中 key 的作用</h3>
<p>vue 中 key 值的作用可以分为两种情况来考虑：</p>
<ul>
<li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li>
<li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li>
<li>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速
<ul>
<li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</li>
<li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>webpack5配置</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webpack.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webpack.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">webpack5配置</source>
      <description>Vue 脚手架 开发模式配置 // webpack.dev.js const path = require(&amp;quot;path&amp;quot;); const ESLintWebpackPlugin = require(&amp;quot;eslint-webpack-plugin&amp;quot;); const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;); const { VueLoaderPlugin } = require(&amp;quot;vue-loader&amp;quot;); const { DefinePlugin } = require(&amp;quot;webpack&amp;quot;); const CopyPlugin = require(&amp;quot;copy-webpack-plugin&amp;quot;); const getStyleLoaders = (preProcessor) =&amp;gt; { return [ &amp;quot;vue-style-loader&amp;quot;, &amp;quot;css-loader&amp;quot;, { loader: &amp;quot;postcss-loader&amp;quot;, options: { postcssOptions: { plugins: [ &amp;quot;postcss-preset-env&amp;quot;, // 能解决大多数样式兼容性问题 ], }, }, }, preProcessor, ].filter(Boolean); }; module.exports = { entry: &amp;quot;./src/main.js&amp;quot;, output: { path: undefined, filename: &amp;quot;static/js/[name].js&amp;quot;, chunkFilename: &amp;quot;static/js/[name].chunk.js&amp;quot;, assetModuleFilename: &amp;quot;static/js/[hash:10][ext][query]&amp;quot;, }, module: { rules: [ { // 用来匹配 .css 结尾的文件 test: /\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), }, { test: /\.less$/, use: getStyleLoaders(&amp;quot;less-loader&amp;quot;), }, { test: /\.s[ac]ss$/, use: getStyleLoaders(&amp;quot;sass-loader&amp;quot;), }, { test: /\.styl$/, use: getStyleLoaders(&amp;quot;stylus-loader&amp;quot;), }, { test: /\.(png|jpe?g|gif|svg)$/, type: &amp;quot;asset&amp;quot;, parser: { dataUrlCondition: { maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 }, }, }, { test: /\.(ttf|woff2?)$/, type: &amp;quot;asset/resource&amp;quot;, }, { test: /\.(jsx|js)$/, include: path.resolve(__dirname, &amp;quot;../src&amp;quot;), loader: &amp;quot;babel-loader&amp;quot;, options: { cacheDirectory: true, cacheCompression: false, plugins: [ // &amp;quot;@babel/plugin-transform-runtime&amp;quot; // presets中包含了 ], }, }, // vue-loader不支持oneOf { test: /\.vue$/, loader: &amp;quot;vue-loader&amp;quot;, // 内部会给vue文件注入HMR功能代码 options: { // 开启缓存 cacheDirectory: path.resolve( __dirname, &amp;quot;node_modules/.cache/vue-loader&amp;quot; ), }, }, ], }, plugins: [ new ESLintWebpackPlugin({ context: path.resolve(__dirname, &amp;quot;../src&amp;quot;), exclude: &amp;quot;node_modules&amp;quot;, cache: true, cacheLocation: path.resolve( __dirname, &amp;quot;../node_modules/.cache/.eslintcache&amp;quot; ), }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, &amp;quot;../public/index.html&amp;quot;), }), new CopyPlugin({ patterns: [ { from: path.resolve(__dirname, &amp;quot;../public&amp;quot;), to: path.resolve(__dirname, &amp;quot;../dist&amp;quot;), toType: &amp;quot;dir&amp;quot;, noErrorOnMissing: true, globOptions: { ignore: [&amp;quot;**/index.html&amp;quot;], }, info: { minimized: true, }, }, ], }), new VueLoaderPlugin(), // 解决页面警告 new DefinePlugin({ __VUE_OPTIONS_API__: &amp;quot;true&amp;quot;, __VUE_PROD_DEVTOOLS__: &amp;quot;false&amp;quot;, }), ], optimization: { splitChunks: { chunks: &amp;quot;all&amp;quot;, }, runtimeChunk: { name: (entrypoint) =&amp;gt; `runtime~${entrypoint.name}`, }, }, resolve: { extensions: [&amp;quot;.vue&amp;quot;, &amp;quot;.js&amp;quot;, &amp;quot;.json&amp;quot;], // 自动补全文件扩展名，让vue可以使用 }, devServer: { open: true, host: &amp;quot;localhost&amp;quot;, port: 3000, hot: true, compress: true, historyApiFallback: true, // 解决vue-router刷新404问题 }, mode: &amp;quot;development&amp;quot;, devtool: &amp;quot;cheap-module-source-map&amp;quot;, };</description>
      <category>Webpack</category>
      <pubDate>Fri, 05 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Vue 脚手架</h1>
<h2> 开发模式配置</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 生产模式配置</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 其他配置</h2>
<ul>
<li>package.json</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>.eslintrc.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>babel.config.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 合并开发和生产配置</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 优化配置</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>websocket基础</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/websocket%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/websocket%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">websocket基础</source>
      <description>1.传统的是 HTTP 模式， 因为 HTTP 协议有一个缺陷：通信只能由客户端发起 一个 request 对应一个 respond 通信是单向的，请求==响应 没有请求就没有响应，举个例子：就比如我需要查询天气，只能是从客户端发送请求，接受查询结果。HTTP 做不到主动向客户端推送信息，这种单向的请求的特点，注定如果服务器有连续的状态变化，客户端想要及时了解就很不方便，只能通过轮询的方式实现，这样是非常浪费资源的因为需要不停的连接,所以发明了 websocket 2.websocket websocket 是一种网络传输协议，可在单个 TCP 连接进行全双工通信，位于 OSI 模型的应用层 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话 特点：</description>
      <category>Webscoket</category>
      <pubDate>Sat, 23 Jul 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1.传统的是 HTTP 模式，</h1>
<p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起 一个 request 对应一个 respond<br>
通信是单向的，请求==响应<br>
没有请求就没有响应，举个例子：就比如我需要查询天气，只能是从客户端发送请求，接受查询结果。HTTP 做不到主动向客户端推送信息，这种单向的请求的特点，注定如果服务器有连续的状态变化，客户端想要及时了解就很不方便，只能通过轮询的方式实现，这样是非常浪费资源的因为需要不停的连接,所以发明了 websocket</p>
<h1> 2.websocket</h1>
<p>websocket 是一种网络传输协议，可在单个 TCP 连接进行全双工通信，位于 OSI 模型的应用层<br>
最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>
特点：</p>
<ol>
<li>TCP 连接，与 HTTP 协议兼容</li>
<li>双向通信，主动推送（服务端向客户端）</li>
<li>无同源限制，协议标识符是 WS（加密 wss）</li>
</ol>
<p>应用场景：</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 聊天，消息，点赞，</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 直播弹幕</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 游戏，协同编辑，基于位置的应用</label></li>
</ul>
<h1> 原生 websocket 的简单使用案例</h1>
<p>我使用的 node.js 平台做的一个服务端，开启 websocket 服务<br>
在 sever.js 文件中 ,建立服务先安装 ws 模块<br>
<code>npm i ws</code><br>
在 sever.js 中</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端建立好之后接下载，看客户端<br>
新建一个 HTML 文件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来在控制台输入<code>node sever.js</code>来启动服务<br>
在浏览器控制台可以看到<br>
<img src="https://img-blog.csdnimg.cn/bf21920e35cb4b79ab4f4d5275dd9698.png#pic_center" alt="客户端结果" loading="lazy"><br>
连接成功，并接收到服务端发来的消息<br>
websocket 有很多 API</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/bf21920e35cb4b79ab4f4d5275dd9698.png#pic_center" type="image/"/>
    </item>
    <item>
      <title>一周学习总结</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">一周学习总结</source>
      <description>这一周，按照学习计划学习了 node.js 及相关的内容，学习了一个简单的数据库，我感觉真的要是精通 node.js 那真的是非常厉害，几乎是想做什么就做什么，接下来我将会进行实践练习，加深理解，更加熟练的运用，该与对于项目结构的规范都要进行实践练习， 这段时间的学习，感觉到挺充实的，相比整天在家玩耍好得多，每天按时规律起床,晚上出去跑个步，其余时间用来敲代码我感觉还是很好的，我的许多同学都外出打工了，确实能挣到很多钱，但是他们的能力在原地踏步，不羡慕他们，加油提升自己更重要</description>
      <category>记录</category>
      <pubDate>Sun, 19 Jun 2022 08:33:21 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这一周，按照学习计划学习了 node.js 及相关的内容，学习了一个简单的数据库，我感觉真的要是精通 node.js 那真的是非常厉害，几乎是想做什么就做什么，接下来我将会进行实践练习，加深理解，更加熟练的运用，该与对于项目结构的规范都要进行实践练习，</p>
<p>这段时间的学习，感觉到挺充实的，相比整天在家玩耍好得多，每天按时规律起床,晚上出去跑个步，其余时间用来敲代码我感觉还是很好的，我的许多同学都外出打工了，确实能挣到很多钱，但是他们的能力在原地踏步，不羡慕他们，加油提升自己更重要</p>
]]></content:encoded>
    </item>
    <item>
      <title>七个JavaScript的简写方法</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">七个JavaScript的简写方法</source>
      <description>多字符串检查 通常，如果我们需要检查字符串是否等于多个值中的一个，往往很快就会觉得疲惫不堪，性欲的是，JavaScript 有一个内置方法帮助你解决这个问题 // 普通写法 const isVowel = (letter) =&amp;gt; { if ( letter === &amp;quot;a&amp;quot; || letter === &amp;quot;e&amp;quot; || letter === &amp;quot;i&amp;quot; || letter === &amp;quot;o&amp;quot; || letter === &amp;quot;u&amp;quot; ) { return true; } return false; }; // 简写方法 const isVowel = (letter) =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;u&amp;quot;].includes(letter);</description>
      <category>记录</category>
      <pubDate>Sat, 03 Dec 2022 08:31:40 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 多字符串检查</h3>
<p>通常，如果我们需要检查字符串是否等于多个值中的一个，往往很快就会觉得疲惫不堪，性欲的是，JavaScript 有一个内置方法帮助你解决这个问题</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> For-of 和 For-in 循环</h3>
<p>For-of 和 For-in 循环是迭代 array 或 object 的好方法，因为无需手动跟踪 object 键的索引。</p>
<ol>
<li>For-of</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>For-in</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>Falsey（假值）检查<br>
如果要检查变量是 null、undefined、0、false、NaN 还是空 string，可以使用逻辑非 (!)运算符一次检查所有变量，而无需编写多个条件。这使得检查变量是否包含有效数据变得相对容易多了。</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 三元运算符</h3>
<p>作为 JavaScript 开发人员，你一定遇到过三元运算符。这是编写简洁 if-else 语句的好方法。但是，也可用来编写简洁的代码，甚至将它们链接起来来检查多个条件。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 函数调用</h3>
<p>在三元运算符的帮助下，你还可以根据条件确定要调用哪个函数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Switch 简写</h3>
<p>通常我们可以使用以键作为 switch 条件并将值作为返回值的对象来优化长 switch 语句。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 回退值</h3>
<p>||运算符可以为变量设置回退值。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JS事件循环</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvenLoop.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvenLoop.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JS事件循环</source>
      <description>用简单的流程解释事件循环 在了解什么是事件循环之前我们应该需要先行了解javascript是一个单线程语言和JavaScript的事件分类; JavaScript 是一个单线程语言 什么是单线程。举个例子：这就好像食堂打饭，需要排队，如果只有一个窗口可以进行打饭，那么就可以看作是单线程，如果有好多个窗口可以进行打饭，这就是多线程 同理，javascript中的所有任务都只有一条线程在处理。 显然这种机制会造成很多问题，如果一个任务卡死，那么整个都不能运行了， 或者其中有一个任务执行的很慢，那么后面所有的任务都会延迟执行，所以 JS 有了两个任务分类[同步任务]和[异步任务]</description>
      <category>记录</category>
      <pubDate>Sat, 25 Mar 2023 10:06:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 用简单的流程解释事件循环</h3>
<p>在了解什么是事件循环之前我们应该需要先行了解<code>javascript是一个单线程语言</code>和<code>JavaScript的事件分类</code>;</p>
<h3> JavaScript 是一个单线程语言</h3>
<p>什么是单线程。举个例子：这就好像食堂打饭，需要排队，如果只有一个窗口可以进行打饭，那么就可以看作是单线程，如果有好多个窗口可以进行打饭，这就是多线程<br>
<code>同理，javascript中的所有任务都只有一条线程在处理。</code></p>
<p>显然这种机制会造成很多问题，如果一个任务卡死，那么整个都不能运行了，<br>
或者其中有一个任务执行的很慢，那么后面所有的任务都会延迟执行，所以 JS 有了两个任务分类[同步任务]和[异步任务]</p>
<h3> JavaScript 的任务分类</h3>
<p>接上文，javascript 中饿所有任务被分为同步任务和异步任务两大类<br>
同步任务介绍：就是只要扫描到，就会马上执行的任务（优先于所有异步任务）<br>
异步任务介绍：即使被扫描到，也不会立即执行，而是会被压入异步任务队列，等待主线程中的任务被执行完毕，再被召唤执行</p>
<p>常见的异步任务有如下几种</p>
<ol>
<li>Promise.then() --微任务</li>
<li>async/await ---Promise 的语法糖 ---微任务</li>
<li>setTimeOut() ---宏任务</li>
<li>setInterval() ---宏任务</li>
<li>.....</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是 2 1 虽然定时器是 0 秒，但是 setTimeout 是一个异步任务，会等到所有同步任务执行完毕再去执行</p>
<h3> 宏任务和微任务</h3>
<p>JavaScript 的异步任务分为宏任务和微任务，</p>
<p>在异步任务中，有些异步任务的执行周期较长，被列入宏任务队列，有些执行周期较短被列入为任务队列</p>
<p>两种任务在执行顺序上是不一样的，当有异步任务被压入任务队列时，JavaScript 会将这两种任务放入两个新的任务队列，会优先执行已经存在的微任务，在所有微任务执行完毕之后会执行一个宏任务，注意是一个宏任务，之后再去微任务队列检查是否有未执行的微任务，如果有则全部执行，再回到宏任务队列再执行一个宏任务，依次循环，这套流程被称作事件循环（event loop）</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230325160939.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 来一个例题</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果为 2 6 3 1</p>
<p>解析参考：</p>
<p>首先，同步任务必定优先于所有所有异步任务并按顺序执行。所以输出 2 6。</p>
<p>同步任务执行完毕后，还剩下一个宏任务和一个微任务。</p>
<p>微任务优先于宏任务执行，所以先输出 3 再输出 1</p>
<p>得答案：2 6 3 1</p>
<h3> 第二题</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/1090548F591933667F0D8C8224F6DBF2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>来一道难一点的</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果为 2 6 3 1 7 8 4 5</p>
<p>解析参考：<br>
首先，同步任务必定优先于所有所有异步任务并按顺序执行。所以输出 2 6。<br>
然后同一批次中剩下一个微任务和一个三个宏任务。<br>
因为宏任务必定会在同一批次环境中的微任务全部执行完毕后再执行，所以场上当前批次中唯一一个微任务先执行。输出 3<br>
还剩下三个宏任务。执行第一个宏任务，宏任务中有一个同步任务和一个异步任务。这里要注意两点。</p>
<p>统一批次宏任务中按顺序执行<br>
一次只执行一个宏任务，然后同步任务当场执行。微任务压入队列。然后就要去检查有没有微任务，有则执行</p>
<p>所以，第一个宏任务执行的时候，产生了一个同步任务和一个微任务。需要注意,宏任务一次只执行一个。执行完之后发现同步任务当场执行（输出 1），然后查看微任务队列中有没有微任务可以执行。发现有，则执行微任务（输出 7）<br>
然后,才开始执行第二个宏任务。执行第二个宏任务产生了一个同步任务，同步任务当场执行（输出 8），产生一个宏任务（宏任务压入红任务执行队列，也就是所有宏任务之后），按事件循环，再次检查是否存在未执行的微任务，发现没有，不执行。<br>
然后执行第三个宏任务，第三个宏任务中产生一个微任务，按事件循环，再去寻找是否存在未执行的微任务，发现有，则执行（输出 4）<br>
最后执行第四个宏任务（第二个宏任务产生的）。走一遍事件循环的流程，输出 5</p>
<p><code>事件循环每一次只执行一个宏任务</code> 这个是非常重要的一点</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/2871389CC6253FDBDB3DD1B711CA6575.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230325160939.png" type="image/png"/>
    </item>
    <item>
      <title>本周学习笔记</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">本周学习笔记</source>
      <description>假期总结 复习了 Vue2 的内容，然后做了一个半的项目，总得来说 Vue2 确实不错，相比 Vue3 还是差点意思，Vue3 性能几乎翻倍，各种优化的非常好，但是 Vue3 毕竟出的时间不久，还是先从 Vue2 开始学习，弄懂 vue2 之后再进行 vue3 的学习，vue3 在用法上与 2 做了少许改变， 学习周期短， 完成了小组招新，我是第九组，怎么说呢，真希望他们坚持久一点，小组真的是一个学习的好地方，机会只有一次，大一的学习热情非常浓厚，我应该向他们学习，我现在大二了，激情有点褪去了，加油，自己感兴趣的东西，努力不留遗憾</description>
      <category>记录</category>
      <pubDate>Mon, 13 Feb 2023 08:05:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 假期总结</h2>
<ol>
<li>复习了 Vue2 的内容，然后做了一个半的项目，总得来说 Vue2 确实不错，相比 Vue3 还是差点意思，Vue3 性能几乎翻倍，各种优化的非常好，但是 Vue3 毕竟出的时间不久，还是先从 Vue2 开始学习，弄懂 vue2 之后再进行 vue3 的学习，vue3 在用法上与 2 做了少许改变， 学习周期短，</li>
<li>完成了小组招新，我是第九组，怎么说呢，真希望他们坚持久一点，小组真的是一个学习的好地方，机会只有一次，大一的学习热情非常浓厚，我应该向他们学习，我现在大二了，激情有点褪去了，加油，自己感兴趣的东西，努力不留遗憾</li>
</ol>
<h2> 下阶段学习计划</h2>
<ol>
<li>还是以项目为主，多实践，然后使用 vue3 做点项目，提高自己的学习热情，加油</li>
</ol>
<h2> 反思与总结，</h2>
<p>多抓紧时间，</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于git</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8Egit.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8Egit.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">关于git</source>
      <description>git 是一种版本控制器，git 的安装非常简单，下一步就行了。 git 的基本操作； 在需要记录版本的文件夹中用，git init 创建本地库 首次使用需要配置一下个人的用户名和电子邮件地址，输入一下两行代码 $ git config --global user.name &amp;quot;用户名&amp;quot; $git config --global user.email 邮箱</description>
      <category>记录</category>
      <pubDate>Sun, 27 Feb 2022 08:35:13 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>git 是一种版本控制器，git 的安装非常简单，下一步就行了。</p>
<p>git 的基本操作；</p>
<p>在需要记录版本的文件夹中用，git init 创建本地库</p>
<p>首次使用需要配置一下个人的用户名和电子邮件地址，输入一下两行代码</p>
<p>$ git config --global <a href="http://user.name" target="_blank" rel="noopener noreferrer">user.name</a> "用户名"</p>
<p>$git config --global user.email 邮箱</p>
<p>可以输入一下代码查看是否配置成功</p>
<p>$git config --list</p>
<p>git 有三个部分，工作区，暂存区，本地库，也可以上传至远程库</p>
<p>git 的基本操作；</p>
<p>git init 初始化操作</p>
<p>git add 添加文件到暂存区</p>
<p>git commit 将暂存区的内容添加到本地仓库中；</p>
<p>git status 查看仓库当前状态</p>
<p>git diff 比较暂存区和工作区的差异</p>
<p>git reset 版本号 回退版本；</p>
<p>git rm 删除工作区文件</p>
<p>git mv 移动或重命名工作区文件。</p>
<p>git log 查看历史提交记录</p>
<p>git blame&lt;file&gt;以列表形式查看指定文件的历史修改记录</p>
<p>git remote 远程仓库操作</p>
<p>git fetch 从远程库获取代码库</p>
<p>git pull 下载远程代码并合并</p>
<p>git push 上传远程代码并合并</p>
<p>其中 git pull git fetch git cloned 的区别</p>
<p>git pull 相当于是从远程获取最新版本并 merge（合并）到本地 git pull = git fetch + git merge</p>
<p><strong>git fetch</strong>&nbsp; 命令用于从远程获取代码库，该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p>
<p>git clone 拷贝一个 git 仓库到本地，本地无需初始化仓库也能拷贝，这是完全拷贝，连历代记录都进行了拷贝，历代版本信息也有，</p>
<p>2.分支管理</p>
<p>git branch -v 可以查看分支</p>
<p>git branch 分支名 &nbsp; &nbsp; &nbsp; 可以创建分支，</p>
<p>git checkout 分支名 &nbsp; &nbsp; &nbsp; &nbsp; 可以切换分支</p>
<p>git merge 分支名 &nbsp; &nbsp; &nbsp; 可以合并分支到当前分支；</p>
<p>git 其实还可以用来保存游戏存档的历代版本，当打游戏材料消耗完了，这个时候只需要回退版本，就能恢复存档。</p>
]]></content:encoded>
    </item>
    <item>
      <title>前端考核感想</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">前端考核感想</source>
      <description>这次前端考核时间很充裕但是我并没有好好利用做的时候有点莽，刚开始先写的整体框架内容填完之后，而且动画还有特效都做好了，才发现一缩小布局是乱的，虽然下边没有出现滚动条，但是我的内容全部都被压缩了，我的内容区的盒子宽度是按照百分比写的，而且使用的是绝对定位，没有响应式布局，直到了最后一天，我才进行改动把所有内容区的宽度改成了固定像素值，并且设置了媒体查询，缩小的页面进行布局。把本来变形的布局改了回来，当然这也不能改变大框架的弄错带来的问题，以后再写就明白怎么去写了，先想明白再去动手不然之后再去修改会很麻烦，总体来说前端做出来的效果事可以看到的，成就感比较强，自己脑海中所想的能够做出来，</description>
      <category>记录</category>
      <pubDate>Mon, 13 Dec 2021 10:58:57 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这次前端考核时间很充裕但是我并没有好好利用做的时候有点莽，刚开始先写的整体框架内容填完之后，而且动画还有特效都做好了，才发现一缩小布局是乱的，虽然下边没有出现滚动条，但是我的内容全部都被压缩了，我的内容区的盒子宽度是按照百分比写的，而且使用的是绝对定位，没有响应式布局，直到了最后一天，我才进行改动把所有内容区的宽度改成了固定像素值，并且设置了媒体查询，缩小的页面进行布局。把本来变形的布局改了回来，当然这也不能改变大框架的弄错带来的问题，以后再写就明白怎么去写了，先想明白再去动手不然之后再去修改会很麻烦，总体来说前端做出来的效果事可以看到的，成就感比较强，自己脑海中所想的能够做出来，</p>
<p>这一阶段结束之后就要分前后端学习了，两个方向都不容易，都挺好，所以现在我以我的兴趣为导向进行选择，我打算选择前端，我觉得前端我有学下去的动力，我想象力很好，我觉得对前端的学习有所帮助。这马上就要期末考试了，要注意课程的学习，不能挂科，尽量安排好自己的时间，小组学习和正常课程，都要弄好，</p>
]]></content:encoded>
    </item>
    <item>
      <title>顺时针打印矩阵JS版</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88).html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88).html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">顺时针打印矩阵JS版</source>
      <description>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 /** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function (matrix) { if (matrix.length == 0) { return []; } if (matrix[0].length == 0) { return []; } //向右 获取长和宽 let height = matrix.length; let width = matrix[0].length; let result = []; //向右打印 for (let i = 0; i &amp;lt; width; i++) { result.push(matrix[0][i]); } //如果有向下的，则向下 不能则返回结果 if (height &amp;gt; 1) { for (let k = 1; k &amp;lt; height; k++) { result.push(matrix[k][width - 1]); } } else { return result; } //如果能向左就向左 不能则返回结果 if (width &amp;gt; 1) { for (let i = width - 2; i &amp;gt;= 0; i--) { result.push(matrix[height - 1][i]); } } else { return result; } //如果能向上 则向上，不能则返回结果 if (height &amp;gt; 2) { for (let i = height - 2; i &amp;gt;= 1; i--) { result.push(matrix[i][0]); } } else { return result; } //剥除里面的矩阵 (循环一次减掉两层高度) let inner = new Array(height - 2); for (let i = 0; i &amp;lt; height - 2; i++) { inner[i] = matrix[i + 1].slice(1, width - 1); } //递归 result = result.concat(spiralOrder(inner)); return result; };</description>
      <category>记录</category>
      <pubDate>Sun, 01 May 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>原型链prototype和__proto__</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">原型链prototype和__proto__</source>
      <description>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。 显示原型和隐式原型；构造函数的显示原型用来存放函数对象，而实例对象的隐式原型等同于构函数的显示原型。所有对象的原型最终都指向 object 对象，object 是原型链的顶端；</description>
      <category>记录</category>
      <pubDate>Sat, 19 Mar 2022 15:10:32 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p>
<p>显示原型和隐式原型；构造函数的显示原型用来存放函数对象，而实例对象的隐式原型等同于构函数的显示原型。所有对象的原型最终都指向 object 对象，object 是原型链的顶端；</p>
<figure><img src="https://img-blog.csdnimg.cn/e4eb068bd2ff4832b6263231b504ec99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>function 的构造函数也是 function，隐式原型指向 function 的原型对象；</p>
<p>而 function 的隐式原型指向 object 对象的显示原型，object 没有隐式原型。object 就是最顶层的对象；</p>
<p>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _'属性(也就是它的构造函数的’prototype’属性)中去寻找，如果他的构造函数的 prototype 中没有这个属性就会去 object 中去寻找。再找不到就没有了；</p>
<p>首先，fn 的构造函数是 Foo()。所以：<br>
fn._ _ proto _ _=== Foo.prototype<br>
又因为 Foo.prototype 是一个普通的对象，它的构造函数是 Object，所以：<br>
Foo.prototype._ _ proto _ _=== Object.prototype<br>
通过上面的代码，我们知道这个 toString()方法是在 Object.prototype 里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到 null 为止。</p>
<figure><img src="https://img-blog.csdnimg.cn/cd57f2c5e51949c49e12a3fc957a9ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>暂时的理解，后续会改</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/e4eb068bd2ff4832b6263231b504ec99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16" type="image/"/>
    </item>
    <item>
      <title>周总结关于项目</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">周总结关于项目</source>
      <description>这周静态页面基本已经完工，没剩几个页面了， 在交互方面实现了，用户的登录注册，账户信息的修改，菜谱步骤的上传（实现了一半），这周的交互我发现前后端传收数据，需要确定好发送的格式，需要与后端讨论好如何去存储一些信息，此次的图片上传中，学会了使用 JS 原生的 FormData 来传输文件，传输文件时要使用$.ajax 而不能直接使用$.post 因为需要调整一些参数的类型， 如下是一个例子 我使用$.ajax 传输一个图片文件 其中把 contentType 设置成了 false processData 设置成了 false</description>
      <category>记录</category>
      <pubDate>Sat, 16 Apr 2022 21:56:36 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这周静态页面基本已经完工，没剩几个页面了，</p>
<p>在交互方面实现了，用户的登录注册，账户信息的修改，菜谱步骤的上传（实现了一半），这周的交互我发现前后端传收数据，需要确定好发送的格式，需要与后端讨论好如何去存储一些信息，此次的图片上传中，学会了使用 JS 原生的 FormData 来传输文件，传输文件时要使用$.ajax 而不能直接使用$.post 因为需要调整一些参数的类型，</p>
<p>如下是一个例子</p>
<p>我使用$.ajax 传输一个图片文件</p>
<p>其中把</p>
<p>contentType 设置成了 false</p>
<p>processData 设置成了 false</p>
<p>就时不对我所发送的数据做处理；直接发送</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有就是，插入图片的直接显示</p>
<p>如下传入一个类型为 file 的 input</p>
<p>通过 readAsDataUrl 把文件转为 base64 格式直接赋给 img 的 src 属性就能显示了</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>回溯算法题</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">回溯算法题</source>
      <description>输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 输入：s = &amp;quot;abc&amp;quot; 输出：[&amp;quot;abc&amp;quot;,&amp;quot;acb&amp;quot;,&amp;quot;bac&amp;quot;,&amp;quot;bca&amp;quot;,&amp;quot;cab&amp;quot;,&amp;quot;cba&amp;quot;] /** * @param {string} s * @return {string[]} * 全排列算法: * 固定位置依次递归交换位置穷举出所有的可能性。 */ var permutation = function (s) { const char = s.split(&amp;quot;&amp;quot;); const res = []; const dsf = function (n) { // 递归的出口,如果是遍历到最后一个位置此方法就解了 if (n === char.length) { res.push(char.join(&amp;quot;&amp;quot;)); return; } const catSet = new Set(); for (let i = n; i &amp;lt; char.length; i++) { //如果有相同的交换，则不需要处理枝减。 if (catSet.has(char[i])) continue; catSet.add(char[i]); // 被固定的位置和其他位置依次交换位置 { const t = char[n]; char[n] = char[i]; char[i] = t; } // 递归下一个位置 dsf(n + 1); // 被交换的位置需要回溯归位。 { const t = char[n]; char[n] = char[i]; char[i] = t; } } }; dsf(0); return res.sort(); };</description>
      <category>记录</category>
      <pubDate>Sat, 29 Oct 2022 20:34:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。<br>
<code>输入：s = "abc" 输出：["abc","acb","bac","bca","cab","cba"]</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>回顾CSS内容</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">回顾CSS内容</source>
      <description>目录 1.弹性盒子 2.文本标签 3.定位 1.弹性盒子 flex flex-direction 指定容器中弹性元素的排列方式； 主轴由 flex 的设置的方向决定；</description>
      <category>记录</category>
      <pubDate>Sun, 16 Jan 2022 19:38:46 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p><strong>目录</strong></p>
<p><a href="#1.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90">1.弹性盒子</a></p>
<p><a href="#2.%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE">2.文本标签</a></p>
<p><a href="#3.%E5%AE%9A%E4%BD%8D">3.定位</a></p>
<hr>
<h2> 1.弹性盒子</h2>
<p>flex</p>
<p>flex-direction 指定容器中弹性元素的排列方式；</p>
<p>主轴由 flex 的设置的方向决定；</p>
<p>flex-grow 指定弹性元素伸展的系数默认值是零；</p>
<p>当父元素有多余的空间时子元素如何伸展，0 就是不伸展，</p>
<p>要是把 flex-grow 写入子元素，则子元素按照 flex-grow 的比值被分配剩余空白部分</p>
<p>flex-shrink 表示收缩系数。当父元素不足以容纳子元素时对子元素进行收缩</p>
<p>当值为零的时候就是不收缩，当外面的框小的时候内容会溢出</p>
<p>这时使用 flex-wrap：wrap；多出的部分会沿着辅轴方向排列</p>
<p>flex-flow 是简写属性</p>
<p>justify-content</p>
<p>如何分配空白区域</p>
<p>flex-start 元素沿着主轴起边排列</p>
<p>flex-end 元素沿着主轴终边排列</p>
<p>center 元素居中排列</p>
<p>sparce-between 空白均匀分布到元素间</p>
<p>spare-around 空白分布到元素两侧。</p>
<p>在纵向上 align-item</p>
<p>中 stretch 属性把元素的长度设置为相同的值；</p>
<p>指的是行与行之间的高度</p>
<p>flex-start：元素不会拉伸，沿着辅轴起边方向对齐</p>
<p>flex-end：沿着辅轴终边对齐</p>
<p>flex-baseline：沿着基线对齐就是文字底边的基线。</p>
<p>在纵轴上分配空白空间</p>
<p>用 align-conent：</p>
<p>和横着的一样。</p>
<p>设置弹性元素的属性</p>
<p>flex-basic:可以设置弹性元素的基础长度；</p>
<p>如果主轴是纵向的则设置的是高度；</p>
<h2> 2.文本标签</h2>
<p>html 格式化标签粗体表示重要性（内容的重要性）或者斜体表示着重点（语气上的强调）表示你要呈现的文章时重要的所以要突出显示 一个粗体，一个斜体</p>
<p>与是定义粗体或斜体文本与上面的那两个是不一样的</p>
<p>cite 标签：网站中所有加书名号的内容都可以使用 cite 标签</p>
<p>《XXX》</p>
<p>短引用标签的内容浏览器会默认给他加上一个“”</p>
<p>blockquote 长引用（块级引用不能放在中）</p>
<p>独占一行</p>
<p>sup 标签用来表示一个上标；</p>
<p>sub 标签用来表示一个下标；</p>
<p>del 标签用来表示一个删除的内容画一个横线</p>
<p>ins 表示插入一个内容插入的内容有下划线</p>
<p>pre 标签时预格式标签保留了格式；</p>
<p>code 专门用来表示代码的标签</p>
<h2> 3.定位</h2>
<p>通过 position 属性</p>
<p>relative 是相对定位</p>
<p>当开启元素相对定位时，而不设置偏移量。和没有设置一样</p>
<p>2：开启后可以通过，left right top bottom 四个属性设置元素的偏移量。</p>
<p>是相对与原来位置移动的。</p>
<p>3：相对定位的元素不会脱离文档流。原来的位置虽然是空的但还占位置。</p>
<p>4：相对定位会使元素提升一个层级。会覆盖其他元素。</p>
<p>通常偏移量使用两个就可以对一个元素进行定位。</p>
<p>相对定位，不会该改变元素的性质，块还是块，内联还是内联</p>
<p>绝对定位 absolute</p>
<p>开启绝对定位后脱离文档流</p>
<p>开启绝对定位后</p>
<p>而且是相对于浏览器窗口定位的</p>
<p>3：绝对定位是相对于离他最近的的开启了定位的祖先元素定位的</p>
<p>（一般情况开启子元素的绝对定位，也会开启祖先元素的绝对定位。）</p>
<p>4：如果所有的祖先元素都未开启定位，则会相对于浏览器窗口定位。</p>
<p>5：绝对定位会使元素提升一个层级</p>
<p>6：定位会改变元素的性质</p>
<p>内联元素变成块元素，块元素的宽度和高度默认被内容撑开</p>
<p>固定定位 fixed</p>
<p>position 也是一种绝对定位</p>
<p>它的大部分特点都和绝对定位一样</p>
<p>不同的是：</p>
<p>固定定位永远会相对于浏览器窗口进行定位</p>
<p>固定定位会固定在浏览器窗口的某个位置，不会随滚顶条滚动</p>
]]></content:encoded>
    </item>
    <item>
      <title>回顾express</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E9%A1%BEexpress.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9E%E9%A1%BEexpress.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">回顾express</source>
      <description>1.express 是什么 Express 是一个基于 &amp;nbsp;Node平台的 Web 应用开发框架，它提供了一系列的强大特性，帮助你创建各种 Web 应用。 2 .Express 框架特性 提供了简洁的路由定义方式 对获取 http&amp;nbsp;请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态 HTML 页面 拥有中间件机制有效控制 HTTP 请求 拥有大量第三方中间件对功能进行扩展</description>
      <category>记录</category>
      <pubDate>Sun, 14 Aug 2022 08:34:12 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<h2> 1.express 是什么</h2>
<p>Express 是一个基于 &nbsp;<a href="https://so.csdn.net/so/search?q=Node&amp;spm=1001.2101.3001.7020" title="Node" target="_blank" rel="noopener noreferrer">Node</a>平台的 Web 应用开发框架，它提供了一系列的强大特性，帮助你创建各种 Web 应用。</p>
<h2> 2 .Express 框架特性</h2>
<ul>
<li>提供了<strong>简洁的路由定义</strong>方式</li>
<li>对获取 http&nbsp;<strong>请求参数</strong>进行了<strong>简化处理</strong></li>
<li>对<strong>模板引擎支持程度高</strong>，方便渲染动态 HTML 页面</li>
<li>拥有<strong>中间件</strong>机制有效<strong>控制 HTTP 请求</strong></li>
<li>拥有大量第三方中间件对功能进行扩展</li>
</ul>
<h2> 3 .原生 node.js 与 Express 框架对比</h2>
<figure><img src="https://img-blog.csdnimg.cn/422f6da8b6d34336ae69e70859163419.png" alt="422f6da8b6d34336ae69e70859163419.png" tabindex="0" loading="lazy"><figcaption>422f6da8b6d34336ae69e70859163419.png</figcaption></figure>
<figure><img src="https://img-blog.csdnimg.cn/e9c435389c0542b5b5da8e592be66431.png" alt="e9c435389c0542b5b5da8e592be66431.png" tabindex="0" loading="lazy"><figcaption>e9c435389c0542b5b5da8e592be66431.png</figcaption></figure>
<h2> 4.中间件</h2>
<figure><img src="https://img-blog.csdnimg.cn/55bd7475882742339b921dc03a8d95e8.png" alt="55bd7475882742339b921dc03a8d95e8.png" tabindex="0" loading="lazy"><figcaption>55bd7475882742339b921dc03a8d95e8.png</figcaption></figure>
<figure><img src="https://img-blog.csdnimg.cn/647096f6d82246239deb7a99732285b2.png" alt="647096f6d82246239deb7a99732285b2.png" tabindex="0" loading="lazy"><figcaption>647096f6d82246239deb7a99732285b2.png</figcaption></figure>
<figure><img src="https://img-blog.csdnimg.cn/27cf49b6412f40669e23658c0d81748b.png" alt="27cf49b6412f40669e23658c0d81748b.png" tabindex="0" loading="lazy"><figcaption>27cf49b6412f40669e23658c0d81748b.png</figcaption></figure>
<h2> 5 &nbsp; 中间件应用</h2>
<h3> 路由保护：</h3>
<p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p>
<p>错误处理中间件</p>
<p>本周还是对项目的完善，使之更加严谨可用，</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/422f6da8b6d34336ae69e70859163419.png" type="image/png"/>
    </item>
    <item>
      <title>图的深度与广度优先遍历</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">图的深度与广度优先遍历</source>
      <description>深度优先遍历算法口诀 访问根节点 对根节点的没访问过相邻节点挨个进行深度优先遍历 code const graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3], }; const dfs = (n) =&amp;gt; { console.log(n); //访问根节点 visted.add(n); //访问过的做一个记录 graph[n].forEach((item) =&amp;gt; { if (!visted.has(item)) { dfs(item); //递归调用 } }); }; dfs(2); //结果为 2 0 1 3</description>
      <category>记录</category>
      <pubDate>Sat, 24 Sep 2022 10:39:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 深度优先遍历算法口诀</h2>
<ul>
<li>访问根节点</li>
<li>对根节点的没访问过相邻节点挨个进行深度优先遍历<br>
code</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 广度优先遍历算法口诀</h2>
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的没访问过的相邻节点入队</li>
<li>重复第二三步，直到队列为空<br>
code</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果<br>
<img src="https://s2.loli.net/2022/09/18/bnU753C1qlmox6L.png" alt="QQ截图20220918154348.png" loading="lazy"></p>
<h3> 总结</h3>
<ul>
<li>图是网络结构的抽象模型，是一组由边连接的节点</li>
<li>图可以表示任何二次元关系，比如道路，航班</li>
<li>JS 中没有图，但是可以用，Object 和 Array 构件图</li>
<li>图的表示法：邻接矩阵,邻接表</li>
<li>图的常用操作: 深度/广度优先遍历</li>
</ul>
]]></content:encoded>
      <enclosure url="https://s2.loli.net/2022/09/18/bnU753C1qlmox6L.png" type="image/png"/>
    </item>
    <item>
      <title>学习记录2</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">学习记录2</source>
      <description>做考核页面也有三四天了，进展很慢，前一部分的内容很细，有好多小地方需要处理；今天我做到了那个轮播图左边的功能栏的地方了，自我感觉这个地方是最不好做的，希望明天之前能够完成，后面的就好做了。这个地方中，当鼠标放上时，一整排图标上移并且弹出内容栏，肯定要用到动画，也能用 JS 来写，我尽量能用 CSS 就不用 JS，虽然 JS 很好用，可以操作基本所有东西，但是还是尽量用基本的写，我的思路就是，先给图标开启定位，当鼠标放上时，让其上移，还有一个同步触发的事件，让该弹出的内容由高度为零变成预定高度，这个过程加一个过渡动画，内容区再用 JS 去写页面左右切换；现在只是这样想，希望能够实现。希望不要花费太多时间，</description>
      <category>记录</category>
      <pubDate>Sun, 23 Jan 2022 20:57:39 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>做考核页面也有三四天了，进展很慢，前一部分的内容很细，有好多小地方需要处理；今天我做到了那个轮播图左边的功能栏的地方了，自我感觉这个地方是最不好做的，希望明天之前能够完成，后面的就好做了。这个地方中，当鼠标放上时，一整排图标上移并且弹出内容栏，肯定要用到动画，也能用 JS 来写，我尽量能用 CSS 就不用 JS，虽然 JS 很好用，可以操作基本所有东西，但是还是尽量用基本的写，我的思路就是，先给图标开启定位，当鼠标放上时，让其上移，还有一个同步触发的事件，让该弹出的内容由高度为零变成预定高度，这个过程加一个过渡动画，内容区再用 JS 去写页面左右切换；现在只是这样想，希望能够实现。希望不要花费太多时间，</p>
<p>还有 7 天就要过年了，希望能够在过年之前写好页面，好好过年，最近学习写页面总感觉时间过的很快，还没有写多少就一天过去了，希望能够提升效率，注意力集中，上午去写一些逻辑性的东西，晚上把文字内容填一填。规划好时间，加油，上班不摸鱼。希望和同学们一起进步，争取突破一下。成为肝帝！！</p>
]]></content:encoded>
    </item>
    <item>
      <title>手写Promise🧐简单版🚩</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%99Promise.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%99Promise.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">手写Promise🧐简单版🚩</source>
      <description>class MyPromise { constructor(executor) { // 初始化state为等待态 this.state = &amp;quot;pending&amp;quot;; // 成功的值 this.value = undefined; // 失败的原因 this.reason = undefined; let resolve = (value) =&amp;gt; { // state改变,resolve调用就会失败 if (this.state === &amp;quot;pending&amp;quot;) { // resolve调用后，state转化为成功态 this.state = &amp;quot;fulfilled&amp;quot;; // 储存成功的值 this.value = value; } }; let reject = (reason) =&amp;gt; { // state改变,reject调用就会失败 if (this.state === &amp;quot;pending&amp;quot;) { // reject调用后，state转化为失败态 this.state = &amp;quot;rejected&amp;quot;; // 储存失败的原因 this.reason = reason; } }; // 如果executor执行报错，直接执行reject try { executor(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { // 状态为fulfilled，执行onFulfilled，传入成功的值 if (this.state === &amp;quot;fulfilled&amp;quot;) { onFulfilled(this.value); } // 状态为rejected，执行onRejected，传入失败的原因 if (this.state === &amp;quot;rejected&amp;quot;) { onRejected(this.reason); } } }</description>
      <category>记录</category>
      <pubDate>Sun, 09 Apr 2023 10:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>手写一些函数</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">手写一些函数</source>
      <description>二维数组斜向打印 (function () { function printMaxit(arr: number[][]) { let row = arr.length; //行 x let conlum = arr[0].length; //列 y let res: any = []; //左上角 从0开始打印到conlum-1； for (let k = 0; k &amp;lt; conlum; k++) { for (let i = 0, j = k; i &amp;lt; row &amp;amp;&amp;amp; j &amp;gt;= 0; i++, j--) { res.push(arr[i][j]); } } //右下角 for (let k = 1; k &amp;lt; row; k++) { for (let i = k, j = row; i &amp;lt; row &amp;amp;&amp;amp; j &amp;gt;= 0; i++, j--) { res.push(arr[i][j]); } } return res; } const matrix2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], ]; console.log(printMaxit(matrix2)); // 输出: [1, 5, 2, 9, 6, 3, 10, 7, 4, 11, 8, 12] })();</description>
      <category>记录</category>
      <pubDate>Tue, 06 Jun 2023 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li><code>二维数组斜向打印</code></li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给定的代码定义了一个名为<code>printMatrix</code>的函数，它接受一个二维数组(<code>arr</code>)作为输入，并返回一个数组(<code>res</code>)，其中包含按特定模式打印矩阵的元素。</p>
<h3> 代码的工作原理如下：</h3>
<ol>
<li>
<p>函数首先初始化变量<code>m</code>和<code>n</code>，用于存储矩阵的行数和列数。</p>
</li>
<li>
<p>然后，创建一个空数组<code>res</code>，用于存储打印出的矩阵元素。</p>
</li>
<li>
<p>接下来，通过两个嵌套的循环来按特定模式打印矩阵的元素。</p>
<ul>
<li>
<p>第一个循环从左上角开始，从 0 到 n-1 列进行迭代。其中，变量<code>k</code>表示当前列数。</p>
<ul>
<li>
<p>内部循环使用变量<code>i</code>和<code>j</code>分别表示当前元素的行和列。</p>
</li>
<li>
<p>循环条件是<code>i</code>小于行数<code>m</code>且<code>j</code>大于等于 0。</p>
</li>
<li>
<p>在每次迭代中，将<code>arr[i][j]</code>添加到结果数组<code>res</code>中，并将<code>i</code>递增，<code>j</code>递减。</p>
</li>
</ul>
</li>
<li>
<p>第二个循环从右下角开始，从 1 到 m-1 行进行迭代。其中，变量<code>k</code>表示当前行数。</p>
<ul>
<li>
<p>内部循环使用变量<code>i</code>和<code>j</code>分别表示当前元素的行和列。</p>
</li>
<li>
<p>循环条件是<code>i</code>小于行数<code>m</code>且<code>j</code>大于等于 0。</p>
</li>
<li>
<p>在每次迭代中，将<code>arr[i][j]</code>添加到结果数组<code>res</code>中，并将<code>i</code>递增，<code>j</code>递减。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环结束后，将结果数组<code>res</code>返回作为函数的输出。</p>
</li>
</ol>
<p>总体而言，该函数按照一种特定的模式遍历二维数组，并将遍历到的元素按顺序存储在一个新的数组中。</p>
<p>2.解析 URL 的 params 参数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是一个 JavaScript IIFE(Immediately Invoked Function Expression)，它包含一个函数 <code>ParseParams</code> 和一个立即执行该函数的语句。</p>
<p><code>ParseParams</code> 函数用于解析给定 URL 的查询参数，并将其转换为一个对象 <code>paramsobj</code>，其中查询参数的名称作为对象的键名，查询参数的值作为对象的键值。函数的实现过程如下：</p>
<ol>
<li>从 URL 中获取查询参数字符串 <code>paramsstr</code>，通过 <code>split</code> 方法将 URL 字符串以 <code>?</code> 分割，取得索引为 1 的字符串作为查询参数字符串。</li>
<li>将查询参数字符串 <code>paramsstr</code> 以 <code>&amp;</code> 符号分割成数组 <code>paramsArr</code>，使用 <code>forEach</code> 方法遍历数组中的每个查询参数。</li>
<li>对于每个查询参数，首先判断其是否包含 <code>=</code> 符号，如果包含则表示该查询参数有值，将其分割成 <code>key</code> 和 <code>value</code> 两部分，并对 <code>value</code> 进行解码和类型转换，然后将其存储到 <code>paramsobj</code> 对象中。</li>
<li>如果某个查询参数的 <code>key</code> 已经在 <code>paramsobj</code> 对象中存在，那么将其值转换为数组，并将新的值添加到数组中，否则直接将新的值赋值给 <code>paramsobj</code> 对象的 <code>key</code> 属性。</li>
<li>如果某个查询参数不包含 <code>=</code> 符号，那么表示该查询参数没有值，直接将其存储到 <code>paramsobj</code> 对象中，并将其值设置为 <code>true</code>。</li>
<li>最后，将解析后的 <code>paramsobj</code> 对象作为函数返回值。</li>
</ol>
<p>在这个例子中，通过传递一个 URL 字符串 <code>url</code> 给 <code>ParseParams</code> 函数，可以获取该 URL 的查询参数，并将其转换为一个对象。函数的执行结果会被输出到控制台中，因为在这个例子中，函数是立即执行的，并且输出结果是通过 <code>console.log</code> 方法输出到控制台的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>拓展运算符是深拷贝还是浅拷贝</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">拓展运算符是深拷贝还是浅拷贝</source>
      <description>对于拓展运算符是深拷贝还是浅拷贝网上怎么说的都有，我就说一下我的理解。 什么是深拷贝？什么是浅拷贝？ 假如 B 复制了 A，修改 A 的时候，看 B 是否发生变化： 如果 B 也跟着变了，说明是浅拷贝，拿别人手段！ 如果 B没有改变，说明是深拷贝，自食其力！ 怎么判断拓展运算符是什么拷贝呢？ 看一下下面的例子： let a = [1, 2, 3]; let b = [...a]; console.log(b); //[1,2,3] a[1] = 4; console.log(a); //[1,4,3] console.log(b); //[1,2,3]</description>
      <category>记录</category>
      <pubDate>Sun, 07 Aug 2022 10:39:55 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>对于拓展运算符是深拷贝还是浅拷贝网上怎么说的都有，我就说一下我的理解。</p>
<p><strong>什么是深拷贝？什么是浅拷贝？</strong></p>
<p>假如 B 复制了 A，修改 A 的时候，看 B 是否发生变化：</p>
<p>如果 B 也跟着<strong>变</strong>了，说明是浅拷贝，拿别人手段！</p>
<p>如果 B<strong>没有改变</strong>，说明是深拷贝，自食其力！</p>
<p><strong>怎么判断拓展运算符是什么拷贝呢？</strong></p>
<p>看一下下面的例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是深拷贝？别急看下面的例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是浅拷贝？</p>
<p>所以结合上面两个例子得出一个结论，拓展运算符是深拷贝还是浅拷贝是看具体拷贝内容的，当拷贝的内容只有一层时是深拷贝，层数很多时时浅拷贝，如果还是不太理解可以先看深拷贝和浅拷贝的定义然后自己手敲一下代码，</p>
<p>加油</p>
]]></content:encoded>
    </item>
    <item>
      <title>数字电子技术——数据选择器</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">数字电子技术——数据选择器</source>
      <description>数据选择器的地址输入和数据输入怎么理解 以一个 4-1 数据选择器为例，它有 4 个数据输入线（D0, D1, D2, D3）、2 个选择输入线（S0, S1）和 1 个输出线（Y）。S0 和 S1 是地址输入，它们可以选择其中一个数据输入线作为输出线的数据。例如，当 S0=0, S1=0 时，选择器会选择 D0 作为输出数据，因为 S0 和 S1 的二进制值为 00，对应的是选择器的第 1 个数据输入线 D0，而 D0 的数据输入则是指在 D0 输入线上输入的具体数字。因此，地址输入和数据输入是数据选择器的两个重要的输入，用于选择和输出特定的数据。</description>
      <category>专业课</category>
      <pubDate>Sun, 11 Jun 2023 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 数据选择器的地址输入和数据输入怎么理解</h3>
<p>以一个 4-1 数据选择器为例，它有 4 个数据输入线（D0, D1, D2, D3）、2 个选择输入线（S0, S1）和 1 个输出线（Y）。S0 和 S1 是地址输入，它们可以选择其中一个数据输入线作为输出线的数据。<br>例如，当 S0=0, S1=0 时，选择器会选择 D0 作为输出数据，因为 S0 和 S1 的二进制值为 00，对应的是选择器的第 1 个数据输入线 D0，而 D0 的数据输入则是指在 D0 输入线上输入的具体数字。<br>因此，地址输入和数据输入是数据选择器的两个重要的输入，用于选择和输出特定的数据。</p>
<h3> 二选一数据选择器</h3>
<p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090259.png" alt="" loading="lazy"><br>案例一，电视频道选择解答<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090331.png" alt="" loading="lazy"></p>
<h3> 四选一数据选择器</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090442.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 解答：</h4>
<table>
<thead>
<tr>
<th>A0 （遥控器输入信号第一位）</th>
<th>A1（遥控器输入信号第二位）</th>
<th>Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>A0 ， A1，</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>A0 ， A1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>A0 A1，</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>A0 A1</td>
</tr>
</tbody>
</table>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090502.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 双四选一数据选择器 74HC153</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090531.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 数据选择器的逻辑函数</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090549.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 例题</h4>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090604.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 数据选择器设计组合逻辑电路</h3>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/yuque_mind.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 例题 2</h4>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090700.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 解答：</h4>
<p>看题目时三个变量，<br>数据选择器地址输入端个数是： n-1 = 3-1 = 2;<br>题目给的 74H153 是两个地址输入端，够用<br>然后对逻辑函数式进行化简。<br>与 74H153 的逻辑函数式进行比较，得到器件端口对应的输入<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090713.png" alt="" loading="lazy"></p>
<h4> 例题 3</h4>
<p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090729.png" alt="" loading="lazy"><br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090752.png" alt="" loading="lazy"></p>
<h4> 解题</h4>
<p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090805.png" alt="" loading="lazy"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090830.png" alt="" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090259.png" type="image/png"/>
    </item>
    <item>
      <title>JavaScript 数组方法</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JavaScript 数组方法</source>
      <description>JavaScript 中的 Array 对象与其他编程语言中的数组一样，可以将多个项目的集合存储在单个变量名下，并具有用于执行常见数组操作的成员。 声明数组 有两种不同的方式可以声明数组。 使用 new Array 通过 new Array，我们可以指定希望存在于数组中的元素，如下所示： const fruits = new Array(&amp;quot;Apple&amp;quot;, &amp;quot;Banana&amp;quot;); console.log(fruits.length);</description>
      <category>记录</category>
      <pubDate>Sat, 15 Oct 2022 15:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JavaScript 中的 Array 对象与其他编程语言中的数组一样，可以将多个项目的集合存储在单个变量名下，并具有用于执行常见数组操作的成员。<br>
声明数组<br>
有两种不同的方式可以声明数组。</p>
<h3> 使用 new Array</h3>
<p>通过 new Array，我们可以指定希望存在于数组中的元素，如下所示：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组字面量表示法</h4>
<p>使用数组字面量声明，我们可以指定数组将具有的值。如果我们不声明任何值，则数组将为空。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1. forEach</h4>
<p>forEach()方法将为每个数组元素执行一次指定的函数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>forEach()为数组中的每个元素按索引升序调用提供的 callbackFn 函数一次。它不会为已删除或未初始化的索引属性调用。</p>
<h4> 2. map</h4>
<p>Array.map()方法允许你遍历数组并使用回调函数修改其元素。然后将在数组的每个元素上执行回调函数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Array.map()方法通常用于对元素应用一些更改，无论是像在上面代码中那样乘以特定数字，还是执行应用程序可能需要的任何其他操作。</p>
<h4> 3. concat</h4>
<p>JavaScript 中的 concat()方法是一个字符串方法，用于将字符串连接在一起。concat()方法将一个或多个字符串值附加到调用字符串，然后将连接的结果作为新字符串返回。因为 concat()方法是 String 对象的方法，所以必须通过 String 类的特定实例来调用它。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4. push</h4>
<p>Javascript 数组中的 push()方法将给定元素附加到数组最后并返回新数组的长度。</p>
<p>如果你想在数组末尾添加一个元素，请使用 push()。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5. pop</h4>
<p>pop()方法将删除数组的最后一个元素并将该值返回给调用者。如果你在空数组上调用 pop()，则返回 undefined。</p>
<p>Array.prototype.shift()与 pop()具有相似的行为，但应用于数组中的第一个元素。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6. splice</h4>
<p>splice()方法是一种通用方法，用于在数组的指定位置通过删除、替换或添加元素来更改数组的内容。本节将介绍如何使用此方法将元素添加到特定位置。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7. slice</h4>
<p>slice()方法将一部分数组的浅表副本返回到从开始到结束（不包括结束）选择的新数组对象中，其中开始和结束表示该数组中项目的索引。该方法不会修改原始数组。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8. shift</h4>
<p>shift()是内置的 JavaScript 函数，用于从数组中删除第一个元素。shift()函数直接修改正在使用的数组。同时 shift()返回数组中删除的项目。</p>
<p>shift()函数删除索引位置 0 的项目，并将索引号的值依次向下移动 1。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 9. unshift</h4>
<p>unshift()方法将插入给定值到类数组对象的开头。</p>
<p>Array.prototype.push()与 unshift()具有相似的行为，但应用于数组的末尾。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10. join</h4>
<p>JavaScript 数组中的 join()方法是一个内置方法，通过连接数组的所有元素来创建并返回新字符串。join()方法将连接数组的项到字符串并返回该字符串。指定的分隔符用于分隔元素数组。默认分隔符是逗号(,)。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 11. every</h4>
<p>every()方法测试数组中的所有元素是否都满足指定的条件。返回的是布尔值。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 12. filter</h4>
<p>filter()方法创建部分给定数组的浅表副本，向下过滤到给定数组中的元素，且元素通过所提供函数实现的条件测试。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 13. indexOf</h4>
<p>indexOf()方法返回可以在数组中找到给定元素的第一个索引，如果不存在则返回-1。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 14. reduce</h4>
<p>reduce()方法按顺序对数组的每个元素执行用户提供的 reducer 回调函数，传入前一个元素的计算返回值。在数组的所有元素上运行 reducer 的最终结果是单个值。。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 15. reverse</h4>
<p>reverse()方法将反转数组并返回对相同数组的引用，第一个数组元素成为最后一个，最后一个数组元素成为第一个。换句话说，数组中的元素顺序将转向与之前相反的方向。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 16. sort</h4>
<p>sort()方法对数组的元素进行就地排序，并返回对同一个数组的引用，而此时数组已排序。默认排序顺序是升序，将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 17. toString</h4>
<p>toString()方法返回表示对象的字符串。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 18. at</h4>
<p>at()方法接受整数值并返回 at 索引的项目，正整数和负整数皆可。负整数从数组中的最后一项开始倒数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 19. find</h4>
<p>find()方法返回数组中满足条件测试函数的第一个元素。如果没有值满足提供的测试函数，则返回 undefined。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 20. some</h4>
<p>some()方法测试数组中是不是至少有一个元素通过了函数实现的条件测试。如果在数组中找到这样的元素就返回 true；否则返回 false。该方法不修改原数组。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>React生命周期</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">React生命周期</source>
      <description>生命周期（新）♥ 新版本可以使用旧的生命周期钩子 react生命周期(新)</description>
      <category>React</category>
      <pubDate>Sun, 14 May 2023 08:25:54 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 生命周期（新）♥</h3>
<p>新版本可以使用旧的生命周期钩子</p>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/react生命周期(新).png" alt="react生命周期(新)" tabindex="0" loading="lazy"><figcaption>react生命周期(新)</figcaption></figure>
<figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/react生命周期(旧).png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>新的生命周期钩子中，有三个钩子出现了警告，</p>
<ul>
<li>
<p>componentWillMount</p>
</li>
<li>
<p>componentWillUpdate</p>
</li>
<li>
<p>componentWillReceiveProps</p>
<p>需要在前方加上 UNSAFE_ React 官方说将在未来会上线异步渲染，这些钩子可能会出现问题</p>
</li>
</ul>
<p>新的钩子：</p>
<ul>
<li>
<p>getDerivedStateFromPorps</p>
</li>
<li>
<p>getSnapshotBeforeUpdate</p>
<h3> getDerivedStateFromPorps()</h3>
<blockquote>
<p>派生状态</p>
</blockquote>
<p>需要加上 static，变为静态方法，这个钩子用途很罕见，这个钩子的原则就是，state 的值在任何时候都取决于 props。</p>
<h3> getSnapshotBeforeUpdate（）</h3>
<p>这个钩子 是 更新 DOM 之前，渲染之后，</p>
<ul>
<li>此钩子的返回值将作为参数，传递给 componentDidUpdate（）；</li>
<li>此方法不常用，滚动条固定可以使用这个，</li>
</ul>
</li>
</ul>
<h3> 新生命周期</h3>
<ul>
<li>挂载过程</li>
</ul>
<ol>
<li>constructor</li>
<li>getSnapshotBeforeUpdate()</li>
<li><strong>render</strong></li>
<li><strong>componentDidmount() //发请求，订阅消息，定时器开启</strong></li>
</ol>
<ul>
<li>
<p>更新过程 由 setState 触发，或者父组件传入 Props 触发</p>
<ol>
<li>getSnapshotBeforeUpdate()</li>
<li>shouldComponentUpdate()</li>
<li><strong>render</strong></li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ol>
</li>
<li>
<p>卸载过程</p>
<ol>
<li><strong>componentWillUnmount()</strong></li>
</ol>
</li>
</ul>
<p>即将废弃的钩子</p>
<ul>
<li>
<p>componentWillUpdate();</p>
</li>
<li>
<p>componentWillMount();</p>
</li>
<li>
<p>componentReviceProps();</p>
<p>必须加上 UNSAFE 才能使用，未来可能废弃了，这三个钩子也不常用</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>本周学习笔记</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">本周学习笔记</source>
      <description>一、node.js 简介 1.Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。 2.Node 采用 Google 开发的 V8 引擎运行 js 代码，使用事件驱动、非阻塞和异步 I/O 模型等技术来提高性能，可优化应用程序的传输量和规模。 3.Node 大部分基本模块都用 JavaScript 编写。在 Node 出现之前，JS 通常作为客户端程序设计语言使用，以 JS 写出的程序常在用户的浏览器上运行。 3.目前，Node 已被 IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、&amp;nbsp;LinkedIn、Rakuten、PayPal、Voxer 和 GoDaddy 等企业采用</description>
      <category>记录</category>
      <pubDate>Sun, 26 Jun 2022 12:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>一、node.js 简介</p>
<p>1.Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。</p>
<p>2.Node 采用 Google 开发的 V8 引擎运行 js 代码，使用事件驱动、非阻塞和异步 I/O 模型等技术来提高性能，可优化应用程序的传输量和规模。</p>
<p>3.Node 大部分基本模块都用 JavaScript 编写。在 Node 出现之前，JS 通常作为客户端程序设计语言使用，以 JS 写出的程序常在用户的浏览器上运行。</p>
<p>3.目前，Node 已被 IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、&nbsp;LinkedIn、Rakuten、PayPal、Voxer 和 GoDaddy 等企业采用</p>
<p>4.Node 主要用于编写像 Web 服务器一样的网络应用，这和 PHP 和 Python 是类似的。</p>
<p>但是 Node 与其他语言最大的不同之处在于，PHP 等语言是阻塞的而 Node 是非阻塞的。</p>
<p>Node 是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意。</p>
<p>Node 正是在这个前提下被创造出来。</p>
<p>Node 把 JS 的易学易用和 Unix 网络编程的强大结合到了一起。</p>
<p>5.Node.js 允许通过 JS 和一系列模块来编写服务器端应用和网络相关的应用。</p>
<p>6.核心模块包括文件系统 I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL 等）、二进制数据流、加密算法、数据流等等。Node 模块的 API 形式简单，降低了编程的复杂度。</p>
<p>7.使用框架可以加速开发。常用的框架有 Express.js、<a href="http://Socket.IO" target="_blank" rel="noopener noreferrer">Socket.IO</a> 和 Connect 等。Node.js 的程序可以在 Microsoft Windows、Linux、Unix、Mac OS X 等服务器上运行。</p>
<p>8.Node.js 也可以使用 CoffeeScript、TypeScript、Dart 语言，以及其他能够编译成 JavaScript 的语言编程。</p>
<p>二.Node.Js 用途</p>
<p><a href="http://1.Web" target="_blank" rel="noopener noreferrer">1.Web</a> 服务 API，比如 REST</p>
<p>实时多人游戏</p>
<p>2.后端的 Web 服务，例如跨域、服务器端的请求</p>
<p>3.基于 Web 的应用</p>
<p>多客户端的通信，如即时通信</p>
]]></content:encoded>
    </item>
    <item>
      <title>本周项目总结</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">本周项目总结</source>
      <description>这周我们组后端接口提供的差不多了，压力来到了我们前端，这周完成了主页面的热门菜谱显示，菜单的上传，用户界面的中，菜谱菜单的显示，及菜谱的删除功能，菜谱详情页的展示，关注和收藏，对登录注册页面的重写，美化了用户界面，判断更加严谨， 在交互中遇到了很多问题，不过都是些小问题，只要交流好都不是问题，这周的交互中，主要是对以前不合理的地方进行修改，代码更加具有普适性，可以搬运，减少重复性劳动，JS 中还是要注意规范，不然一个小错误，可能会浪费大量的时间,很难发现 下周，我计划把网站主体所有功能全部实现，当然评论功能不在其中，因为想要实现一个好的评论功能，可能需要大量的时间，等把主要功能做的差不多了，再去做评论，还有就是上传数据的前端判断，下周把上传相关的判断给完善一下，防止错误数据和空数据的上传，还有界面的美化，感觉还是主要在我们前端，各种交互，需要总结一下经验，如果还有时间，会继续增加功能，</description>
      <category>记录</category>
      <pubDate>Sat, 23 Apr 2022 21:50:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>这周我们组后端接口提供的差不多了，压力来到了我们前端，这周完成了主页面的热门菜谱显示，菜单的上传，用户界面的中，菜谱菜单的显示，及菜谱的删除功能，菜谱详情页的展示，关注和收藏，对登录注册页面的重写，美化了用户界面，判断更加严谨，</p>
<p>在交互中遇到了很多问题，不过都是些小问题，只要交流好都不是问题，这周的交互中，主要是对以前不合理的地方进行修改，代码更加具有普适性，可以搬运，减少重复性劳动，JS 中还是要注意规范，不然一个小错误，可能会浪费大量的时间,很难发现</p>
<p>下周，我计划把网站主体所有功能全部实现，当然评论功能不在其中，因为想要实现一个好的评论功能，可能需要大量的时间，等把主要功能做的差不多了，再去做评论，还有就是上传数据的前端判断，下周把上传相关的判断给完善一下，防止错误数据和空数据的上传，还有界面的美化，感觉还是主要在我们前端，各种交互，需要总结一下经验，如果还有时间，会继续增加功能，</p>
<p>最后分享一个正则表达式</p>
<p>是用来检测邮箱的</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>栈结构+一道算法</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%BB%93%E6%9E%84_%E7%AE%97%E6%B3%95.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%BB%93%E6%9E%84_%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">栈结构+一道算法</source>
      <description>1.栈（stack） QQ截图20220916150957.png 它是一种受限制的线性表，后见先出 其限制是仅允许在表的一端进行插入和删除操作，这一段被称为栈顶相对地把另一端称为栈底 LIFO 表示就是后进入的元素，带一个弹出栈空间，类似于自动餐托盘最后放上托盘，往往先拿出去使用 向一个栈插入新元素又称作进栈，入栈，或者压栈，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素 从一个栈删除元素又称作出栈，或者退栈，他是把栈顶元素删掉，使其相邻的元素成为新的栈顶元素。</description>
      <category>记录</category>
      <pubDate>Thu, 03 Mar 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1.栈（stack）</h2>
<figure><img src="https://s2.loli.net/2022/09/16/PSWIgxmMZ4RKpF9.png" alt="QQ截图20220916150957.png" tabindex="0" loading="lazy"><figcaption>QQ截图20220916150957.png</figcaption></figure>
<ol>
<li>它是一种受限制的线性表，后见先出</li>
</ol>
<ul>
<li>其限制是仅允许在表的一端进行插入和删除操作，这一段被称为<code>栈顶</code>相对地把另一端称为<code>栈底</code></li>
<li>LIFO 表示就是后进入的元素，带一个弹出栈空间，类似于自动餐托盘最后放上托盘，往往先拿出去使用</li>
<li>向一个栈插入新元素又称作<code>进栈</code>，<code>入栈</code>，或者<code>压栈</code>，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li>
<li>从一个栈删除元素又称作<code>出栈</code>，或者<code>退栈</code>，他是把栈顶元素删掉，使其相邻的元素成为新的栈顶元素。</li>
</ul>
<h2> 2.栈结构的实现 例一</h2>
<figure><img src="https://s2.loli.net/2022/09/16/TYaosZUxe2y8bIv.png" alt="QQ截图20220916173538.png" tabindex="0" loading="lazy"><figcaption>QQ截图20220916173538.png</figcaption></figure>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>利用栈结构解题</p>
<h3> 例二</h3>
<figure><img src="https://s2.loli.net/2022/09/19/rV46HcgxIdEjk5M.png" alt="QQ截图20220919102019.png" tabindex="0" loading="lazy"><figcaption>QQ截图20220919102019.png</figcaption></figure>
<p>code</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> JS 中的函数调用堆栈</h3>
<p><strong>演示视频</strong></p>
<iframe height="419" width="745" src="https://player.youku.com/embed/XNTkwNDc3NTQ2MA==" frameborder="0" allowfullscreen="true"></iframe>
]]></content:encoded>
      <enclosure url="https://s2.loli.net/2022/09/16/PSWIgxmMZ4RKpF9.png" type="image/png"/>
    </item>
    <item>
      <title>编写干净的JavaScript</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">编写干净的JavaScript</source>
      <description>我们应该编写不言自明、易于理解、易于修改或易于扩展新功能的代码。因为代码常常需要被阅读，这就是为什么如此强调干净代码的原因。 我们的源代码可读性越强，则： 越容易维护 新开发人员理解代码所需的时间越少 越容易发现哪些代码可以重用 在这篇文章中，我将分享一些通用的干净编码原则以及一些特定于 JavaScript 的干净编码实践。 命名 不要把命名变成猜谜游戏。变量和函数的名称最好能够揭示最初创建的意图。 如此一来，即使有新的开发人员加入团队，也不至于需要像看天书一样艰难地理解代码。 Bad 👎</description>
      <category>记录</category>
      <pubDate>Mon, 16 Jan 2023 08:44:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们应该编写不言自明、易于理解、易于修改或易于扩展新功能的代码。因为代码常常需要被阅读，这就是为什么如此强调干净代码的原因。</p>
<p>我们的源代码可读性越强，则：</p>
<p>越容易维护<br>
新开发人员理解代码所需的时间越少<br>
越容易发现哪些代码可以重用<br>
在这篇文章中，我将分享一些通用的干净编码原则以及一些特定于 JavaScript 的干净编码实践。</p>
<ol>
<li>命名<br>
不要把命名变成猜谜游戏。变量和函数的名称最好能够揭示最初创建的意图。<br>
如此一来，即使有新的开发人员加入团队，也不至于需要像看天书一样艰难地理解代码。<br>
Bad 👎</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，不要在变量名或函数名中添加多余的不必要的字母。<br>
Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>条件句<br>
避免否定条件语句。否定语句通常比肯定语句更难理解。</li>
</ol>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>
<p>函数应该专注做单一一件事<br>
函数的平均行数不应超过 30 行（不包括空格和注释）。函数越小，则越容易理解和重构。你可以用函数修改或查询某些内容，但不能同时修改或查询。</p>
</li>
<li>
<p>使用默认参数<br>
使用默认参数而不是短路或条件语句。</p>
</li>
</ol>
<p>默认参数通常比短路更干净。请记住，在你使用默认参数的时候，函数将只为未定义的参数提供默认值。其他虚假值，例如 ''、""、false、null、0 和 NaN，不会被默认值替换。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>单级抽象（SLA）<br>
在编写函数时，如果你有多个抽象级别，那么函数通常会做不止一件事情。将一个大的函数分成多个函数会使其更具可重用性，并且测试起来更容易。</li>
</ol>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>不要忽略被捕获的异常<br>
对捕获的异常错误不采取任何措施，即意味着不修复特定的错误也不对其做出反应。</li>
</ol>
<p>将错误记录到控制台(console.log)并没有好多少，因为记录经常会在控制台的其他内容中丢失。</p>
<p>如果你在 try/catch 中包装了哪怕一点点代码，也意味着你认为那里可能会发生错误，因此你应该对何时发生错误有一个计划。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6">
<li>尽量减少注释<br>
仅注释具有业务逻辑复杂性的代码部分。</li>
</ol>
<p>注释不是必需的。好的代码大多数可以自我说明。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>“多余的注释就是谎言和错误信息的垃圾桶。” ——Robert C. Martin</code> 7. 移除注释掉的代码<br>
不要在代码库中留下注释掉的代码，版本控制的存在是有原因的。将旧代码留在历史记录中。如果你需要的话，再从 git 历史记录中获取。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="8">
<li>只导入你需要的<br>
ES6 引入了解构。它可以将数组中的值或对象中的属性解包为不同的变量。你可以将其用于任何类型的对象或模块。</li>
</ol>
<p>例如，如果你只需要另一个模块中的 add()和 subtract()函数：<br>
Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只导入需要在文件中使用的函数而不是整个模块，然后从中访问特定函数是有意义的。 9. 保持函数参数不超过 3 个（理想情况下）<br>
限制函数参数的数量非常重要，因为这样可以更轻松地测试函数。参数超过 3 个会导致需要测试大量不同的情况。</p>
<p>1-3 个参数是最理想的情况，正常情况下，参数数量应避免任何超出此范围。</p>
<p>通常，如果你有三个以上的参数，那么说明函数要做的事情太多了，违反 SRP（单一职责原则）。 10. 使用数组展开来复制数组<br>
Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="11">
<li>写线性代码<br>
嵌套的代码很难理解。所以我们应该尽可能地编写线性代码，这样的代码简单、干净、易于阅读和维护，使开发人员的工作更轻松。</li>
</ol>
<p>例如，在回调上使用 promise 可以大大提高可读性。 12. 使用 ESLint 和 Prettier<br>
始终使用 ESLint 和 Prettier 来强制跨团队和开发人员使用通用的编码风格。</p>
<p>还可以尝试使用 JavaScript 的最新功能来编写代码，例如解构、展开运算符、异步等待、模板字面量、可选链等等。 13. 适当使用括号<br>
使用运算符时，请将它们括在括号中。唯一的例外是标准算术运算符：+、- 和 *<em>，因为它们的优先级被广泛理解。强烈建议将 /、</em> 和 % 括在括号中，因为当它们一起使用时，其优先级可能会引起困惑。</p>
<p>这不但提高了可读性，而且阐明了开发人员的意图。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>14.早早地从函数中返回<br>
为避免 if 语句的深层嵌套，始终尽可能早地返回函数的值。</p>
<p>Bad 👎</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Good 👍</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个特殊的例子甚至可以进一步改进：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同理，同样的事情也可以应用于循环。</p>
<p>大的循环肯定会消耗大量时间。这就是为什么你应该尽可能早地跳出循环。</p>
]]></content:encoded>
    </item>
    <item>
      <title>美食项目考核总结</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">美食项目考核总结</source>
      <description>从项目开始到结束，经过了差不多一个月，项目功能基本实现，考核中，才知道自己原来还有很多问题没有考虑周到，这次之后我会格外注意，各种漏洞，要尽可能去想用户会怎么操作做这个页面，应对多种情况，防止一些操作直接使得网页崩溃，这次考核中出现的很多问题，例如用户界面的关注，收藏什么的没有做成分页的形式，导致内容很多的时候浏览器压力很大，导致崩溃，项目后续会进行完善，增加功能，同时修改原先的 bug,增加更加人性化的操作，还有在 css 动画效果上，我会尽量使用原生的 js,css 去写动画效果，JQ 只用一个 ajax 就够了，锻炼自己的能力，项目上我负责的是网站前台部分。整个部分的结构不复杂，应用的技术不是不是很难，这次主要锻炼一下使用 promise 的能力。才知道，promise 的状态只能改变一次，要不就重新返回一个 new promise</description>
      <category>记录</category>
      <pubDate>Sun, 08 May 2022 15:18:10 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>从项目开始到结束，经过了差不多一个月，项目功能基本实现，考核中，才知道自己原来还有很多问题没有考虑周到，这次之后我会格外注意，各种漏洞，要尽可能去想用户会怎么操作做这个页面，应对多种情况，防止一些操作直接使得网页崩溃，这次考核中出现的很多问题，例如用户界面的关注，收藏什么的没有做成分页的形式，导致内容很多的时候浏览器压力很大，导致崩溃，项目后续会进行完善，增加功能，同时修改原先的 bug,增加更加人性化的操作，还有在 css 动画效果上，我会尽量使用原生的 js,css 去写动画效果，JQ 只用一个 ajax 就够了，锻炼自己的能力，项目上我负责的是网站前台部分。整个部分的结构不复杂，应用的技术不是不是很难，这次主要锻炼一下使用 promise 的能力。才知道，promise 的状态只能改变一次，要不就重新返回一个 new promise</p>
<p>我们项目组三个人，两个前端，一个后端，合作起来还算可以，进度基本能够相互配合，这次考核学到很多东西，有了做项目的经验，团队合作，分工好，才能更高效的完成任务，前后端交流好,互相说明一下需求，交互起来更加容易，得心应手。这次的评论我做的不好，评论的回复，子评论的回复后显示，直接刷新整个评论，这样确实更简单了，但是确实多流量的浪费，如果评论有很多那么就会非常浪费资源，接下来我会尽量改进这个评论功能；</p>
<p>考核中没有使用 thymeleaf,这是应该会的，但是我不太会用，所以从一开始就没有用，到了中期再用也比较麻烦。下次有机会一定会用的，这个方法,thymeleaf 的话，是在服务器渲染页面，而直接 ajax 是再客户端渲染页面，</p>
<p>下一阶段，我计划加强自己的代码规范，尽量原生 JS 写所有的内容，加油</p>
]]></content:encoded>
    </item>
    <item>
      <title>近期学习随笔</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">近期学习随笔</source>
      <description>前些天闭组了，虽然闭组了，但是我还是每天坚持来小组学习，开始认真学习专业课程，闭组第一天我早上睡到了九点多，睡了个懒觉，起来之后神清气爽，非常有精神，带上书包就去小组学习了，小组的人很少，没有了往日的热闹和紧张的氛围，但是在这的人还是非常认真的在学习，坐到这里才有学习的动力，在寝室老是想玩游戏，不能很好的学习效率很低，所以我每天还是来小组学习，养成一个好习惯，闭组这段时间我每天晚上都是十点回去，没有像往常一样十点四十回去，毕竟还是想放轻松一下，现在是大一觉得不应该那么卷，还是想轻松一点，适度学习，适度躺平。 马上就要放假了，回家每天学习点 JS，我觉得应该能够把那个一百多集的视频看完，并学会。希望小组的任务能够轻松一些，每天肝个几个小时就能完成的那种。我们家那边疫情比较严重，只能在家，任务应该都能完成。希望寒假不会延期开学，希望明年疫情消退，让我们大一的出去玩玩吧。寒假我也出不去，我们周口疫情挺严重的，家周围都封闭了，回去还要隔离七天，只有电脑陪我了。期末加油！</description>
      <category>记录</category>
      <pubDate>Wed, 29 Dec 2021 17:16:22 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>前些天闭组了，虽然闭组了，但是我还是每天坚持来小组学习，开始认真学习专业课程，闭组第一天我早上睡到了九点多，睡了个懒觉，起来之后神清气爽，非常有精神，带上书包就去小组学习了，小组的人很少，没有了往日的热闹和紧张的氛围，但是在这的人还是非常认真的在学习，坐到这里才有学习的动力，在寝室老是想玩游戏，不能很好的学习效率很低，所以我每天还是来小组学习，养成一个好习惯，闭组这段时间我每天晚上都是十点回去，没有像往常一样十点四十回去，毕竟还是想放轻松一下，现在是大一觉得不应该那么卷，还是想轻松一点，适度学习，适度躺平。</p>
<p>马上就要放假了，回家每天学习点 JS，我觉得应该能够把那个一百多集的视频看完，并学会。希望小组的任务能够轻松一些，每天肝个几个小时就能完成的那种。我们家那边疫情比较严重，只能在家，任务应该都能完成。希望寒假不会延期开学，希望明年疫情消退，让我们大一的出去玩玩吧。寒假我也出不去，我们周口疫情挺严重的，家周围都封闭了，回去还要隔离七天，只有电脑陪我了。期末加油！</p>
]]></content:encoded>
    </item>
    <item>
      <title>迭代器(iterator)原理</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">迭代器(iterator)原理</source>
      <description>目录 1.iterator 介绍 &amp;nbsp; &amp;nbsp; 2.itertor 作用 &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; 3.iterator 的遍历原理</description>
      <category>记录</category>
      <pubDate>Sat, 03 Sep 2022 10:38:50 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p><strong>目录</strong></p>
<p><a href="#1.iterator%E4%BB%8B%E7%BB%8D">1.iterator 介绍 &nbsp; &nbsp;</a></p>
<p><a href="#2.itertor%E4%BD%9C%E7%94%A8">2.itertor 作用 &nbsp; &nbsp; &nbsp;&nbsp;</a></p>
<p><a href="#3.iterator%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">3.iterator 的遍历原理</a></p>
<hr>
<h2> 1.iterator 介绍</h2>
<p>iterator 是一种接口，为各种不同数据结构提供一种统一的访问机制，任何数据只要部署 iterator 接口，就可以完成遍历操作，</p>
<h2> <strong>2.itertor 作用</strong></h2>
<p>iterator 的作用有三个：一是为各种数据结构，提供一个统一的，简便的访问接口；二是使得数据结构的成员能够按照某种次序排列，三是 ES6 创造了一种新的遍历命令 for···of 循环，iterator 接口主要供 for···of 消费</p>
<h2> 3.iterator 的遍历原理</h2>
<p>(1) 创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器本质上是一个指针对象</p>
<p>(2) 第一次调用指针对象的 next&nbsp; 方法 &nbsp; &nbsp; 可以将指针指向数据结构的第一个成员</p>
<p>(3) 第二次调用指针对象的 next 方法 &nbsp; &nbsp; 指针对象将指向数据结构的第二个成员</p>
<p>(4) 不断调用指针对象的 next 方法， 直到它指向数据结构的结束位置，每一次调用 next 方法，都会返回数据结构的当前成员信息，具体来说就是返回一个包含 value 和 done&nbsp; 两个属性的对象其中 value 是当前成员的值，done 属性是一个布尔值 &nbsp; ，表示遍历是否结束</p>
<p><strong>模拟例子</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>makeIterator 是一个迭代器生成函数，作用就是返回一个遍历器对象，对数组['a','b']&nbsp; 执行这个函数</p>
<p>返回该数组的迭代器对象（即指针对象）</p>
<p>2021 字节跳动 web 工程师笔试题</p>
<h2> 第一题</h2>
<blockquote>
<p>[<br>
{num: 12, city: ‘beijing’},<br>
{num: 56, city: ‘shanghai’},<br>
{num: 167, city: ‘guangzhou’},<br>
{num: 23, city: ‘shenzhen’},<br>
{num: 45, city: ‘caoxian’}<br>
]<br>
写一个方法实现把上面的数组转换成下面这种格式：<br>
{beijing: 12, shanghai: 56,…}</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历数组添加到对象就行了</p>
<p>本周主要进行了复习，对 JS 基础 &nbsp; JS 高级 &nbsp; ES6 进行了回顾 &nbsp; 剩余时间在学习 Vue&nbsp; 加油！</p>
]]></content:encoded>
    </item>
    <item>
      <title>错误日志1</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">错误日志1</source>
      <description>vue2 中 axios 请求遇到的问题 当请求是报出如图上错误时，有两种情况 就是错误的把 axios 当作插件在全局注册 就是我范的错误， 把axios的配置项写错了也会造成这样的结果</description>
      <category>记录</category>
      <pubDate>Mon, 13 Feb 2023 17:01:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> vue2 中 axios 请求遇到的问题</h2>
<p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230213091759.png" alt="" loading="lazy"><br>
当请求是报出如图上错误时，有两种情况</p>
<ol>
<li>就是错误的把 axios 当作插件在全局注册</li>
<li>就是我范的错误，<br>
<img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230213170505.png" alt="" loading="lazy"><br>
<code>把axios的配置项写错了也会造成这样的结果</code></li>
</ol>
<p>虽然是个小问题，但是耽误了我几个小时，写代码一定要规范起来</p>
]]></content:encoded>
      <enclosure url="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ截图20230213091759.png" type="image/png"/>
    </item>
    <item>
      <title>队列,链表,集合,字典，树</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">队列,链表,集合,字典，树</source>
      <description>用 JS 数组方法模拟队列 队列实例演示视频，可以看出是先进先出 JS 异步中的任务队列 JS 是单线程的，无法同时处理异步中的并发任务 使用任务队列先后处理异步任务 链表模拟 //链表 模拟 const a = { val: &amp;quot;a&amp;quot; }; const b = { val: &amp;quot;b&amp;quot; }; const c = { val: &amp;quot;c&amp;quot; }; const d = { val: &amp;quot;d&amp;quot; }; a.next = b; b.next = c; c.next = d; //遍历链表 let p = a; while (p) { console.log(p.val); p = p.next; } //插入 改变next指向 const e = { val: &amp;quot;e&amp;quot; }; c.next = e; e.next = d; while (p) { console.log(p.val); p = p.next; } //删除e c.next = d;</description>
      <category>记录</category>
      <pubDate>Tue, 01 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 用 JS 数组方法模拟队列</h2>
<p>队列实例演示视频，可以看出是先进先出</p>
<iframe height="419" width="745" src="https://player.youku.com/embed/XNTkwMjUzNjY2OA==" frameborder="0" allowfullscreen="true"></iframe>
<h2> JS 异步中的任务队列</h2>
<ul>
<li>JS 是单线程的，无法同时处理异步中的并发任务</li>
<li>使用任务队列先后处理异步任务</li>
</ul>
<h2> 链表模拟</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 集合</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 字典</h2>
<ul>
<li>与集合类似，字典也是一种储存为一只的数据结构，但他是以键值对的形式来储存</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 树</h2>
<ul>
<li>一种分层数据抽象模型</li>
<li>前端工作中常见的树包括，DOM 数，级联选择,树形控件<br>
js 中没有树，但是可以用 Object 和 Array 构建数</li>
<li>树的常用操作，深度/广度操作
<ul>
<li>深度优先遍历 1.访问根节点 2.对根节点的 chidren 挨个进行深度优先遍历<br>
就是递归的使用</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果<br>
<img src="https://s2.loli.net/2022/09/17/minX4Qz2MsVFBlJ.png" alt="执行结果" loading="lazy"></p>
<ul>
<li>广度优先遍历
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队，并访问</li>
<li>把对头的 children 挨个入队</li>
<li>重读第二，三步直到队列为空<br>
接续用上述的 tree 使用广度优先遍历实现</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 二叉树的前中后序遍历</h1>
<h2> 先序遍历</h2>
<ul>
<li>先序遍历算法口诀
<ul>
<li>访问根节点</li>
<li>对根节点的左子树进行先序遍历</li>
<li>对根节点的右子树进行先序遍历</li>
</ul>
</li>
</ul>
<p>如下二叉树</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据算法口诀先序遍历</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://s2.loli.net/2022/09/18/dVHLJOCIUrQKbGN.png" alt="QQ截图20220918085919.png" loading="lazy">;<br>
按照这个顺序进行遍历<br>
得到<br>
<img src="https://s2.loli.net/2022/09/18/Ord5Uhp2lgqvTKW.png" alt="QQ截图20220918090811.png" loading="lazy"></p>
<h2> 中序遍历算法口诀</h2>
<ol>
<li>对根节点的左子树进行中序遍历</li>
<li>访问根节点</li>
<li>对根节点的右子树进行中序遍历<br>
code 实现</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历顺序图<br>
<img src="https://s2.loli.net/2022/09/18/UGCem8DWR7atn6o.png" alt="QQ截图20220918091819.png" loading="lazy"><br>
结果图<br>
<img src="https://s2.loli.net/2022/09/18/DfS3ZzAEIidNbn9.png" alt="QQ截图20220918091844.png" loading="lazy"></p>
<h2> 后续遍历</h2>
<ol>
<li>对根节点中的左子树进行遍历</li>
<li>对根节点的右子树进行遍历</li>
<li>访问根节点<br>
code</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历顺序<br>
<img src="https://s2.loli.net/2022/09/18/pdosLHDP3RBNVuS.png" alt="QQ截图20220918092612.png" loading="lazy"><br>
结果；<br>
<img src="https://s2.loli.net/2022/09/18/5ayDoIKxzgvPcmO.png" alt="QQ截图20220918092620.png" loading="lazy"><br>
结果如图<br>
<img src="https://s2.loli.net/2022/09/17/xjUY4a9K2bX3uMT.png" alt="结果" loading="lazy"></p>
<h3> 解压小视频</h3>
<iframe height="419" width="745" src="https://player.youku.com/embed/XMzMxMjE0MjY4NA==" frameborder="0" allowfullscreen="true"></iframe>
]]></content:encoded>
      <enclosure url="https://s2.loli.net/2022/09/17/minX4Qz2MsVFBlJ.png" type="image/png"/>
    </item>
    <item>
      <title>防抖与节流</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">防抖与节流</source>
      <description>防抖与节流 复习一下 function debounce(fn, delay) { let timerID = null; return function () { const context = this; if (timeID) { window.clearTimeout(timerID); } timerID = setTimeout(() =&amp;gt; { fn.apply(context, arguments); }, delay); }; }</description>
      <category>记录</category>
      <pubDate>Tue, 14 Mar 2023 17:40:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 防抖与节流</h3>
<p>复习一下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>浏览器如何渲染的</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">浏览器如何渲染的</source>
      <description>面试题 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是解析 HTML。</description>
      <category>记录</category>
      <pubDate>Sun, 02 Apr 2023 13:40:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 面试题</h1>
<h2> 浏览器是如何渲染页面的？</h2>
<p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<hr>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<hr>
<p>渲染的第一步是<strong>解析 HTML</strong>。</p>
<p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p>
<p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<hr>
<p>渲染的下一步是<strong>样式计算</strong>。</p>
<p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<hr>
<p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<hr>
<p>下一步是<strong>分层</strong></p>
<p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p>
<hr>
<p>再下一步是<strong>绘制</strong></p>
<p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<hr>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<hr>
<p>分块完成后，进入<strong>光栅化</strong>阶段。</p>
<p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图</p>
<hr>
<p>最后一个阶段就是<strong>画</strong>了</p>
<p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<h2> 什么是 reflow？</h2>
<p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p>
<h2> 什么是 repaint？</h2>
<p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<h2> 为什么 transform 的效率高？</h2>
<p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目总结篇</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">项目总结篇</source>
      <description>从开始项目到现在也快 40 天了，在这个过程中不得不说，交流真的很重要，要是交流多一点，项目估计早就完成了，找 bug 也找的差不多了，项目现在还有些功能不太完善，学分认证系统功能应该朝着实用性，和安全性出发，这是最重要的，还有交互体验很重要，能够简单明了的一眼看出网站的使用规则，而不是功能隐藏起来，轻松上手，快速使用。 项目 bug 正在修复，代码嵌入，功能失效·······啥的，正在改,还有交互体验上，各种信息的提示需要做出来，给用户足够的反馈信息。明白咋回事， 学习方面，主要还是项目经验吧，还有各种第三方工具的使用，接下来继续努力，加油</description>
      <category>记录</category>
      <pubDate>Sun, 31 Jul 2022 09:48:26 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>从开始项目到现在也快 40 天了，在这个过程中不得不说，交流真的很重要，要是交流多一点，项目估计早就完成了，找 bug 也找的差不多了，项目现在还有些功能不太完善，学分认证系统功能应该朝着实用性，和安全性出发，这是最重要的，还有交互体验很重要，能够简单明了的一眼看出网站的使用规则，而不是功能隐藏起来，轻松上手，快速使用。</p>
<p>项目 bug 正在修复，代码嵌入，功能失效·······啥的，正在改,还有交互体验上，各种信息的提示需要做出来，给用户足够的反馈信息。明白咋回事，</p>
<p>学习方面，主要还是项目经验吧，还有各种第三方工具的使用，接下来继续努力，加油</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目最后总结</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">项目最后总结</source>
      <description>这次项目就快要结束了，项目希望这几天能够做完，做好，保质保量， 最后会进行 bug 测试，尽量使得项目能够像一个正常的网站能够正常使用，在这一周的的过程中，发现项目还是有点不够人性化，希望让用户用着舒服，不追求功能多么厉害，但是要好用，评论还差点，希望我能够顺利完成，之后会进行拓展功能的实现，后台希望能够尽快与网页主体实现正常功能。 其他也没什么说的 把我项目的工具库函数发出来吧 function getStyle(obj, name) { if (window.getComputedStyle) { return getComputedStyle(obj, null)[name]; } else { return obj.currentStyle[name]; } } function imgup(obj) { let file = obj.files[0]; let reader = new FileReader(); let name1 = obj.parentNode.children[0]; reader.readAsDataURL(file); reader.onload = function (ev) { /* $(name).attr(&amp;quot;src&amp;quot;, ev.target.result); */ name1.setAttribute(&amp;quot;src&amp;quot;, ev.target.result); }; } function outdifficulty(obj) { let text = obj.innerText; $(&amp;quot;.pr-inner-xz:eq(0)&amp;quot;).attr(&amp;quot;value&amp;quot;, text); } function outdifficulty2(obj) { let text = obj.innerText; $(&amp;quot;.pr-inner-xz:eq(1)&amp;quot;).attr(&amp;quot;value&amp;quot;, text); } //删除功能 function del(obj) { let a = obj.parentNode; a.parentNode.removeChild(a); } function del1(obj) { let a = obj.parentNode.parentNode; a.parentNode.removeChild(a); } function userkouweitext(obj) { let text = obj.innerText; console.log(text); $(&amp;quot;.kouweiinput&amp;quot;).val(text); $(&amp;quot;.kouweilist&amp;quot;).fadeOut(200); } function pushcode(obj) { $.ajax({ async: true, dataType: &amp;quot;json&amp;quot;, type: &amp;quot;get&amp;quot;, url: &amp;quot;http://localhost:8080/user/getSession&amp;quot;, success: function (date) { if (date.data == null) { console.log(&amp;quot;未登录&amp;quot;); } else { obj.src = &amp;quot;http://localhost:8080/recipe/getCode?id=&amp;quot; + date.data.id + &amp;quot;&amp;amp;&amp;quot; + Math.random(); } }, }); } function pushcode2(obj) { $.ajax({ async: true, dataType: &amp;quot;json&amp;quot;, type: &amp;quot;get&amp;quot;, url: &amp;quot;http://localhost:8080/user/getSession&amp;quot;, success: function (date) { if (date.data == null) { console.log(&amp;quot;未登录&amp;quot;); } else { obj.src = &amp;quot;http://localhost:8080/menu/getCode?id=&amp;quot; + date.data.id + &amp;quot;&amp;amp;&amp;quot; + Math.random(); } }, }); } function outlogin() { let userimgtab = document.getElementsByClassName(&amp;quot;userimgmodel&amp;quot;)[0]; let longin = document.getElementsByClassName(&amp;quot;longin&amp;quot;)[0]; userimgtab.style.display = &amp;quot;none&amp;quot;; longin.style.display = &amp;quot;block&amp;quot;; $.get(&amp;quot;http://localhost:8080/user/exist&amp;quot;, {}, function () {}); window.location.assign(&amp;quot;./home-page.html&amp;quot;); } function logintest() { let userimgtab = document.getElementsByClassName(&amp;quot;userimgmodel&amp;quot;)[0]; let admin = document.getElementsByClassName(&amp;quot;userimgtab&amp;quot;)[0]; let longin = document.getElementsByClassName(&amp;quot;longin&amp;quot;)[0]; $.ajax({ async: true, dataType: &amp;quot;json&amp;quot;, type: &amp;quot;get&amp;quot;, url: &amp;quot;http://localhost:8080/user/getSession&amp;quot;, success: function (date) { if (date.data == null) { console.log(&amp;quot;未登录&amp;quot;); userimgtab.style.display = &amp;quot;none&amp;quot;; longin.style.display = &amp;quot;block&amp;quot;; } else { userimgtab.style.display = &amp;quot;block&amp;quot;; longin.style.display = &amp;quot;none&amp;quot;; } if (date.data.sign == 1) { $(admin.children[0]).append( `&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;./back-html/background.html&amp;quot;&amp;gt;进入后台&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;` ); } else { console.log(&amp;quot;普通用户&amp;quot;); } }, }); } function upmsg(param) { $.ajax({ async: true, dataType: &amp;quot;json&amp;quot;, type: &amp;quot;get&amp;quot;, url: &amp;quot;http://localhost:8080/user/getSession&amp;quot;, success: function (date) { if (date.data == null) { } else { $.get( &amp;quot;http://localhost:8080/user/getUser&amp;quot;, { id: date.data.id, }, function (date) { let userimgmodel = document.getElementsByClassName(&amp;quot;userimgmodel&amp;quot;)[0]; $(userimgmodel.children[0].children[0]).attr( &amp;quot;src&amp;quot;, date.data.userInfo.photo ); } ); } }, }); } //获取URL传递的参数 function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(&amp;quot;&amp;amp;&amp;quot;); for (var i = 0; i &amp;lt; vars.length; i++) { var pair = vars[i].split(&amp;quot;=&amp;quot;); if (pair[0] == variable) { return pair[1]; } } return false; } function getQueryVariable2(variable, url) { var query = url.substring(1); var vars = query.split(&amp;quot;&amp;amp;&amp;quot;); for (var i = 0; i &amp;lt; vars.length; i++) { var pair = vars[i].split(&amp;quot;=&amp;quot;); if (pair[0] == variable) { return pair[1]; } } return false; } function hasclass(obj, join) { var reg = new RegExp(&amp;quot;\\b&amp;quot; + join + &amp;quot;\\b&amp;quot;); return reg.test(obj.className); } function addClass(obj, join) { if (!hasclass(obj, join)) { obj.className += &amp;quot; &amp;quot; + join; } } function deleteclass(obj, join) { var reg = new RegExp(&amp;quot;\\b&amp;quot; + join + &amp;quot;\\b&amp;quot;); obj.className = obj.className.replace(reg, &amp;quot;&amp;quot;); } function statuswitch(i) { let type1 = document.getElementsByClassName(&amp;quot;type-head&amp;quot;)[0]; for (let i = 0; i &amp;lt; 3; i++) { deleteclass(type1.children[i], &amp;quot;active&amp;quot;); $(&amp;quot;.state:eq(&amp;quot; + (i + 2) + &amp;quot;)&amp;quot;).css(&amp;quot;color&amp;quot;, &amp;quot;#020202&amp;quot;); } $(&amp;quot;.state:eq(&amp;quot; + (i + 2) + &amp;quot;)&amp;quot;).css(&amp;quot;color&amp;quot;, &amp;quot;rgb(255,197,82)&amp;quot;); addClass(type1.children[i], &amp;quot;active&amp;quot;); $(&amp;quot;.content2&amp;quot;).empty(); //清空后用根据选择的项目进行ajax请求获取对应数据 //------------------------------------------------------- //收藏内部的加载 if (i == 2) { $(&amp;quot;.recipe-head&amp;quot;).css(&amp;quot;display&amp;quot;, &amp;quot;block&amp;quot;); $(&amp;quot;.content2&amp;quot;).empty(); //ajax请求收藏菜谱的数据！！ } else { $(&amp;quot;.recipe-head&amp;quot;).css(&amp;quot;display&amp;quot;, &amp;quot;none&amp;quot;); } } function search(param) { let tabsearchcontent = document.getElementsByClassName(&amp;quot;tabsearchcontent&amp;quot;)[0]; console.log(tabsearchcontent.value); window.location.assign(`searchpage.html?name=${tabsearchcontent.value}`); } function zuiresousuo(obj) { let url = encodeURI(`searchpage.html?name=${obj.children[0].innerText}`); window.location.assign(url); } function search1(param) { let tabsearchcontent = document.getElementsByClassName(&amp;quot;tabsearchcontent&amp;quot;)[0]; console.log(tabsearchcontent.value); window.location.assign(`../searchpage.html?name=${tabsearchcontent.value}`); } function fenlei(obj) { let url = encodeURI(`../searchpage.html?name=${obj.innerText}`); window.location.assign(url); } function fenlei1(obj) { let url = encodeURI(`./searchpage.html?name=${obj.innerText}`); window.location.assign(url); } function textnums(obj) { console.log(obj.value); if (200 - obj.value.lenght &amp;lt;= 0) { obj.value.lenght = 200; } $(&amp;quot;.talknums&amp;quot;).text(`还可以输入${200 - obj.value.length}`); } function zitinums(obj) { let obj1 = obj.parentNode; let kuang = obj1.children[1].children[0]; if (200 - obj.value.lenght &amp;lt;= 0) { obj.value.lenght = 200; } $(kuang).text(`还可以输入${200 - obj.value.length}`); }</description>
      <category>记录</category>
      <pubDate>Sat, 30 Apr 2022 23:16:17 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这次项目就快要结束了，项目希望这几天能够做完，做好，保质保量， 最后会进行 bug 测试，尽量使得项目能够像一个正常的网站能够正常使用，在这一周的的过程中，发现项目还是有点不够人性化，希望让用户用着舒服，不追求功能多么厉害，但是要好用，评论还差点，希望我能够顺利完成，之后会进行拓展功能的实现，后台希望能够尽快与网页主体实现正常功能。</p>
<p>其他也没什么说的</p>
<p>把我项目的工具库函数发出来吧</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有注释，因为也就我一个人看 😎</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目继续进行</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">项目继续进行</source>
      <description>这次的考核内容的完善项目，我准备把项目进行进一步的完善，改一改 bug，这次新加的内容全部使用原生 JS，除了 ajax 用 JQ 其他的都使用原生的，本次后端使用了 spring boot 这就要求我们要使用 th 前几天我对 th 进行了学习，现在项目到了后期阶段，想要全换成 th 是不太可能的，再写的内容尽量使用 th，我会吸取上次的教训，把学长们提出的问题进行修复，使得页面看起来更加合理，各种内容的分页处理，增删改查，美食网站，我尽量让它看起来像美食网站，</description>
      <category>记录</category>
      <pubDate>Sun, 15 May 2022 09:18:33 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>这次的考核内容的完善项目，我准备把项目进行进一步的完善，改一改 bug，这次新加的内容全部使用原生 JS，除了 ajax 用 JQ 其他的都使用原生的，本次后端使用了 spring boot 这就要求我们要使用 th 前几天我对 th 进行了学习，现在项目到了后期阶段，想要全换成 th 是不太可能的，再写的内容尽量使用 th，我会吸取上次的教训，把学长们提出的问题进行修复，使得页面看起来更加合理，各种内容的分页处理，增删改查，美食网站，我尽量让它看起来像美食网站，</p>
]]></content:encoded>
    </item>
    <item>
      <title>高度塌陷问题的解决办法</title>
      <link>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</link>
      <guid>https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">高度塌陷问题的解决办法</source>
      <description>在 HTML 文档中元素默认是在文档流中的，在文档流中块级元素会独占一行从上至下排列，而内联元素，所谓的行内元素，指的是只占自身大小的元素，不会占用一行 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 首先什么是高度坍塌？ 在文档流中，父元素的高度默认是被子元素撑开的。 也就是子元素多高，父元素多高。 但是当子元素设置浮动时，子元素会脱离文档流</description>
      <category>记录</category>
      <pubDate>Sun, 05 Dec 2021 19:54:30 GMT</pubDate>
      <content:encoded><![CDATA[<!--more-->
<p>在 HTML 文档中元素默认是在文档流中的，在文档流中块级元素会独占一行从上至下排列，而内联元素，所谓的行内元素，指的是只占自身大小的元素，不会占用一行</p>
<p>行内元素有：a b span img input select strong（强调的语气）<br>
块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</p>
<p><strong>首先什么是高度坍塌？</strong></p>
<p>在文档流中，父元素的高度默认是被子元素撑开的。</p>
<p>也就是子元素多高，父元素多高。</p>
<p>但是当子元素设置浮动时，子元素会脱离文档流</p>
<p>此时将会导致子元素无法撑起父元素的高度造成父元素塌陷，则父元素下的所有元素都会上移这样导致页面布局混乱。</p>
<p>解决办法有好几种，但是某些办法有局限性。在不同浏览器中也会出现不兼容的问题</p>
<p>**一.**把浮动元素所在盒子的高度定死，设置一个不可变的高度。这样容易出现内容溢出的问题。造成布局混乱</p>
<p><strong>二</strong>、开启 BFC 属性<br>
根据 W3C 的标准，在我们的页面中元素都有一个隐含的属性叫做“Block&nbsp;Formatting&nbsp;Context”，简称 BFC，该属性可以设置打开或者关闭，默认是关闭的。当我们开启元素的 BFC 以后，元素会具有以下特性：<br>
1.父元素的垂直外边距不会和子元素重叠<br>
2.开启 BFC 的元素不会被浮动元素覆盖<br>
3.开启 BFC 的元素可以包含浮动的子元素<br>
如何开启元素的 BFC：<br>
1.设置元素的浮动：&nbsp; 这种方式开启虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且这种方式也会导致下边的元素上移，不能解决问题。<br>
2.设置元素的绝对定位</p>
<p>3.将我们元素的 overflow 设置为 hidden 是副作用最小的开启 BFC 的方式。</p>
<p><strong>三</strong>、可以直接在高度塌陷的父元素的最后，添加一个空白的 div<br>
由于添加的 div 并没有浮动，所以他是可以撑开父元素的高度的，再对其进行清除浮动，可以通过空白的 div 来撑开父元素的高度，基本没有副作用。使用这种方式，虽然可以解决问题，但是会在页面中添加多余的结构</p>
<p>**四、**通过 after 伪类来选中父元素的后面<br>
可以通过 after 伪类向元素的的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加 div 的原理一样，可以达到相同的效果，而且不会再页面中添加多余的 div，最为推荐使用的方式，几乎没有副作用</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于本站</title>
      <link>https://oragekk.me/Zzh/about.html</link>
      <guid>https://oragekk.me/Zzh/about.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">关于本站</source>
      <description>关于本站 ✨📒 详细记录一下此次建站过程 开始 之前的博客是基于jekyll打造的，要添加和定制化的东西都只能基于html+js+css完成，有些麻烦，所以一直有想更换引擎的想法 直到偶然间发现vuepress，首先是被vue3+typescript+vite吸引，然后看到默认主题属实有点不合符我的期待，自己动手成本又太高，也没有太急着去折腾，直到无意中发现了 vuepress-theme-hope，漂亮的外观一下子就吸引到我了，然后去官网深入研究了一番，发现二次开发的成本并不高，对于我来说比较友好，基本都是基于选项的配置型，和一小部分的定制开发，也可以基于vue来写，这让我觉得很合适。所以，一步步折腾了起来……</description>
      <category>Blog</category>
      <pubDate>Tue, 14 Mar 2023 21:45:45 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 关于本站</h1>
<div class="hint-container info">
<p class="hint-container-title">✨📒</p>
<p>详细记录一下此次建站过程</p>
</div>
<h2> 开始</h2>
<p>之前的博客是基于jekyll打造的，要添加和定制化的东西都只能基于html+js+css完成，有些麻烦，所以一直有想更换引擎的想法<br>
直到偶然间发现vuepress，首先是被<code>vue3</code>+<code>typescript</code>+<code>vite</code>吸引，然后看到默认主题属实有点不合符我的期待，自己动手成本又太高，也没有太急着去折腾，直到无意中发现了<br>
<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>，漂亮的外观一下子就吸引到我了，然后去官网深入研究了一番，发现二次开发的成本并不高，对于我来说比较友好，基本都是基于选项的配置型，和一小部分的定制开发，也可以基于vue来写，这让我觉得很合适。所以，一步步折腾了起来……</p>
<h2> Markdown增强</h2>
<p>hope主题的markdown效果是出乎意料的好，而且支持了很多普通markdown不支持的东西，如自定义容器、带tab的代码块，最方便的是可以直接写流程图了，可选高亮主题（本站代码高亮基于shikiPlugin,虽不如默认的prismjs轻量高效，但能提供更准确的语法高亮）具体效果看这里☞<a href="/Zzh/demo/markdown.html" target="blank">Markdown展示</a></p>
<h2> 目录结构</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 框架支持</h2>
<p><a href="https://v2.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vuepress2.x</a></p>
<h2> 主题支持</h2>
<p><a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<h2> 自定义内容</h2>
<p>基于原主题进行了继承，个性化内容如下，主要自定义内容分为</p>
<ol>
<li>
<p><strong>自定义布局</strong></p>
<ul>
<li>NotFound.vue</li>
<li>Layout.vue(增加打赏组件)</li>
<li>News.vue(说说列表布局)</li>
</ul>
</li>
<li>
<p><strong>自定义组件</strong></p>
<ul>
<li>BlogHero.vue</li>
<li>PageFooter.vue</li>
<li>Sponsor.vue（打赏组件）</li>
<li>NewsList.vue （说说列表）</li>
<li>NewsItem.vue （说说item）</li>
</ul>
</li>
<li>
<p><strong>本地插件开发</strong></p>
<ul>
<li>vuepress-plugin-canvas（支持彩虹背景和动态几何图形两种）</li>
<li>vuepress-plugin-gradient-cover （遮罩背景）</li>
<li>vuepress-plugin-hitokoto （一言插件）</li>
<li>vuepress-plugin-live2DAssist （看板娘辅助，由于子页有sidebar，看板娘会挡住，所以写了一个子页隐藏的小东西）</li>
<li>vuepress-plugin-popper （鼠标特效，基于<a href="https://github.com/moefyit/moefy-canvas" target="_blank" rel="noopener noreferrer">@moefy-canvas/theme-popper</a>）</li>
</ul>
</li>
<li>
<p><strong>引用外部内容</strong></p>
<ul>
<li>
<p><a href="https://github.com/oh-my-live2d/vuepress-plugin-oh-my-live2d" target="_blank" rel="noopener noreferrer">vuepress-plugin-oh-my-live2d</a> 看板娘插件</p>
</li>
<li>
<p>不蒜子统计</p>
</li>
<li>
<p><a href="https://github.com/moefyit/moefy-canvas" target="_blank" rel="noopener noreferrer">@moefy-canvas/theme-popper</a>原有插件只支持vuepress1.x，自己基于moefy-canvas进行了支持vuepress2.x的本地化插件开发</p>
</li>
<li>
<p><a href="https://v2.vuepress.vuejs.org/zh/reference/plugin/google-analytics.html" target="_blank" rel="noopener noreferrer">@vuepress/plugin-google-analytics</a> 支持Google Analytics 4 正好看到通知原来的UA也要被强制转换了，所以更换了G4</p>
</li>
</ul>
</li>
<li>
<p><strong>配置内容</strong></p>
<ul>
<li>navbar</li>
<li>sidebar</li>
<li>评论基于 <a href="https://waline.js.org/" target="_blank" rel="noopener noreferrer">Waline</a></li>
<li>搜索基于<a href="https://www.algolia.com/developers/?utm_content=powered_by&amp;utm_source=localhost&amp;utm_medium=referral&amp;utm_campaign=docsearch" target="_blank" rel="noopener noreferrer">algolia</a></li>
<li>启用 copyright 版权信息插件</li>
<li>feed rss插件</li>
<li>增加文章类型-说说，为说说markdown图片添加预览选择器</li>
</ul>
</li>
<li>
<p><strong>零碎</strong></p>
<ul>
<li>运行时间统计</li>
<li>CSS 样式美化</li>
<li>引入字体，品如手写体，夏行楷体</li>
<li>wanlie 增加自定义emoji，并修改展示样式</li>
<li>个性log</li>
<li>自动推送新文章url到搜索引擎（百度、Bing、Google）👉<a href="/platform/github/github-action" target="_blank" rel="noopener noreferrer">详细配置</a></li>
</ul>
</li>
</ol>
<h2> 总结</h2>
<blockquote>
<p>未完待续，持续优化中</p>
</blockquote>
<p>本地插件，喜欢自取，源码公开，点击右上角，github图标即可，当然不要忘记点个✨哦</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://oragekk.me/Zzh/intro.html</link>
      <guid>https://oragekk.me/Zzh/intro.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">关于我</source>
      <description>关于我 Profile Profile 大前端工程师 ReactNative、React、Vue、Electron 是主要方向| 期待与你一起发现更大的世界 测试 Skills Languages</description>
      <category>About</category>
      <pubDate>Sun, 12 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 关于我</h1>

<h2> Profile</h2>
<div class="hint-container tip">
<p class="hint-container-title">Profile</p>
<p>大前端工程师 ReactNative、React、Vue、Electron 是主要方向| 期待与你一起发现更大的世界 测试</p>
</div>
<h2> Skills</h2>
<h3> Languages</h3>
<img src="https://skillicons.dev/icons?i=javascript,ts,html,css,java,md,sass,bash&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Frameworks</h3>
<img src="https://skillicons.dev/icons?i=vue,nodejs,react,reactivex,redux&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Databases</h3>
<img src="https://skillicons.dev/icons?i=mysql,mongodb&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Hardwares</h3>
<img src="https://skillicons.dev/icons?i=raspberrypi&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Others</h3>
<img src="https://skillicons.dev/icons?i=vim,vscode,androidstudio,figma,git,github,gitlab,idea,linux,postman,powershell,svg,twitter&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h2> Github Summary</h2>
<img src="https://github-profile-trophy.vercel.app/?username=Zzhgitup&amp;theme=radical&amp;margin-w=25" alt="Github Summary">
<img src="https://github-readme-stats.vercel.app/api/top-langs/?username=Zzhgitup&amp;theme=radical&amp;layout=compact&amp;bg_color=30,ef475d,904e95&amp;title_color=fff&amp;text_color=fff">
<img src="https://github-readme-stats.vercel.app/api?username=Zzhgitup&amp;count_private=true&amp;show_icons=true&amp;theme=radical&amp;bg_color=30,ef475d,904e95&amp;title_color=fff&amp;text_color=fff">
<!-- ## Preview

![:Augenestern-creator](https://count.getloli.com/get/@:Zzhgitup?theme=gelbooru-h) -->
<h2> Activity Graph</h2>
<figure><a href="https://github.com/Zzhgitup/github-readme-activity-graph" target="_blank" rel="noopener noreferrer"><img src="https://github-readme-activity-graph-sandy.vercel.app/graph?username=Zzhgitup&amp;theme=dracula" alt="Ashutosh's github activity graph" tabindex="0" loading="lazy"></a><figcaption>Ashutosh's github activity graph</figcaption></figure>
<h2> 关于本站</h2>
<p><a href="/about" target="_blank" rel="noopener noreferrer">传送门</a></p>
]]></content:encoded>
      <enclosure url="https://count.getloli.com/get/@:Zzhgitup?theme=gelbooru-h" type="image/"/>
    </item>
    <item>
      <title>Markdown 展示</title>
      <link>https://oragekk.me/Zzh/demo/markdown.html</link>
      <guid>https://oragekk.me/Zzh/demo/markdown.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Markdown 展示</source>
      <description>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。 你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</description>
      <category>使用指南</category>
      <pubDate>Sat, 11 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。</p>
<p>你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</p>
<!-- more -->
<h2> Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<h2> Markdown 配置</h2>
<p>VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a>。</p>
</div>
<h2> Markdown 扩展</h2>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a> 。</p>
<h3> VuePress 扩展</h3>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h3> 主题扩展</h3>
<p>通过 <a href="https://md-enhance.vuejs.press/zh/" target="_blank" rel="noopener noreferrer"><code>vuepress-plugin-md-enhance</code></a>，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。</p>
<h4> 自定义容器</h4>
<div v-pre="">
<p>安全的在 Markdown 中使用 {{ variable }}。</p>
</div>
<div class="hint-container info">
<p class="hint-container-title">自定义标题</p>
<p>信息容器，包含 <code>代码</code> 与 <a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8">链接</a>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<div class="hint-container tip">
<p class="hint-container-title">自定义标题</p>
<p>提示容器</p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">自定义标题</p>
<p>警告容器</p>
</div>
<div class="hint-container danger">
<p class="hint-container-title">自定义标题</p>
<p>危险容器</p>
</div>
<details class="hint-container details"><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/container.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 代码块</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/code-tabs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 上下角标</h4>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 自定义对齐</h4>
<div style="text-align:center">
<p>我是居中的</p>
</div>
<div style="text-align:right">
<p>我在右对齐</p>
</div>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/align.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Attrs</h4>
<p>一个拥有 ID 的 <strong id="word">单词</strong>。</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/attrs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 脚注</h4>
<p>此文字有脚注<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">.</a></p><a class="footnote-anchor" id="footnote-ref1">
</a><ul><a class="footnote-anchor" id="footnote-ref1">
</a><li><a class="footnote-anchor" id="footnote-ref1"></a><a href="https://theme-hope.vuejs.press/zh/guide/markdown/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 标记</h4>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/mark.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 任务列表</h4>
<ul class="task-list-container">
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 计划 1</label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 计划 2</label></p>
</li>
<li>
<p><a href="https://theme-hope.vuejs.press/zh/guide/markdown/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
</ul>
<h3> 图片增强</h3>
<p>支持为图片设置颜色模式和大小</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/image.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 图表</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/chart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Echarts</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/echarts.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 流程图</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/flowchart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Mermaid</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/mermaid.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Tex 语法</h4>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><msup><mi mathvariant="normal">∂</mi><mi>r</mi></msup><mrow><mi mathvariant="normal">∂</mi><msup><mi>ω</mi><mi>r</mi></msup></mrow></mfrac><mrow><mo fence="true">(</mo><mfrac><msup><mi>y</mi><mi>ω</mi></msup><mi>ω</mi></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mfrac><msup><mi>y</mi><mi>ω</mi></msup><mi>ω</mi></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">{</mo><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>i</mi></msup><mi>r</mi><mo>⋯</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mrow><mi>r</mi><mo>−</mo><mi>i</mi></mrow></msup></mrow><msup><mi>ω</mi><mi>i</mi></msup></mfrac><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3414em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0277em;vertical-align:-1.2777em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3414em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5017em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">}</span></span></span></span></span></span></span></p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/tex.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 导入文件</h4>
<ul>
<li>
<p><a href="/Zzh/demo/markdown.html" target="blank">Markdown 展示</a></p>
</li>
<li>
<p><a href="/Zzh/demo/page.html" target="blank">页面展示</a></p>
</li>
<li>
<p><a href="/Zzh/demo/disable.html" target="blank">禁用展示</a></p>
</li>
</ul>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/include.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 代码演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/demo.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 样式化</h4>
<p>向 Mr.Hope 捐赠一杯咖啡。 </p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/stylize.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 交互演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Vue 交互演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/vue-playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 幻灯片</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/presentation.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>这是脚注内容 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://oragekk.me/Zzh/demo/slides.html</link>
      <guid>https://oragekk.me/Zzh/demo/slides.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">幻灯片页</source>
      <description>slidestart 幻灯片演示 一个简单的幻灯片演示与各种小贴士。 作者 Mr.Hope. 请滚动鼠标滚轮进入下一页 标注幻灯片 👇 (#/1/1) -- 标注幻灯片 使用 --- 标注水平幻灯片 在水平幻灯片中使用 -- 分割垂直幻灯片 使用 在幻灯片上添加属性 使用 在前一个 HTML 元素上添加属性 Markdown 你可以在幻灯片中使用 M...</description>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<!-- markdownlint-disable MD024 MD033 MD051 -->
]]></content:encoded>
      <enclosure url="https://oragekk.me/Zzh/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>如何利用GitHub Action提交URL到搜索引擎</title>
      <link>https://oragekk.me/Zzh/blog/auto-push.html</link>
      <guid>https://oragekk.me/Zzh/blog/auto-push.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">如何利用GitHub Action提交URL到搜索引擎</source>
      <description>相关信息 这是一个GitHub Actions的配置文件，整体思路是，获取本次更新的url （通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了sitemap.xml文件，再利用python脚本进行url推送到百度、Bing、Google 脚本代码请看这里👉提交URL到搜索引擎（百度、Bing、Google）</description>
      <category>Blog</category>
      <pubDate>Mon, 17 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>这是一个<code>GitHub Actions</code>的配置文件，整体思路是，获取本次更新的url<br>
（通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了<code>sitemap.xml</code>文件，再利用python脚本进行url推送到百度、Bing、Google</p>
<p>脚本代码请看这里👉<a href="/posts/Python/submit-url" target="_blank" rel="noopener noreferrer">提交URL到搜索引擎（百度、Bing、Google）</a></p>
</div>
<!-- more -->
<p>前些天不是写了Bing的提交脚本吗，但是每次都要自己手动跑脚本也很麻烦，但我又没有服务器，所以用上了GitHub Actions了嘛<br>
总的来说做了以下事情：</p>
<ol>
<li>提交代码并修改sitemap.xml 后触发工作流</li>
<li>比对上一次提交和本次提交的新增URL</li>
<li>将URL分别提交给百度站长、Bing、Google 供搜索引擎快速收录</li>
<li></li>
</ol>
<h2> 流程解读</h2>
<h2> 配置代码</h2>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 配置解读</h2>
<h4> 触发</h4>
<p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
</ol>
<h4> 配置运行环境</h4>
<p>这里指定<code>ubuntu-latest</code></p>
<h4> 步骤</h4>
<ol>
<li>
<p>拉取 gh-pages 分支代码到路径<code>gh-pages</code></p>
</li>
<li>
<p>获取上一次提交SHA-1值使用如下命令，将获取到的倒数第二次git提交SHA-1值存储到环境变量<code>GITHUB_OUTPUT</code><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">中，方便后续使用</a></p><a class="footnote-anchor" id="footnote-ref1">
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a></li><a class="footnote-anchor" id="footnote-ref1">
<li>
<p>获取上一步存储到到<code>GITHUB_OUTPUT</code>的commitid，并拉取代码代码到路径prev，ref可以是分支，tag，commitid</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>拉取main分支代码到路径main</p>
</li>
<li>
<p>安装python环境并设置缓存</p>
</li>
<li>
<p>安装python依赖库</p>
</li>
<li>
<p>运行脚本读取配置在仓库--&gt;Settings--&gt;Secrets and variables--&gt;Actions--&gt;Repository secrets中的环境变量，并把上次提交的sitemap.xml和本次提交的sitemap.xml作为命令行参数提交给python脚本</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/17/67c1bc7646f4be1d.png" alt="Repository secrets" tabindex="0" loading="lazy"><figcaption>Repository secrets</figcaption></figure>
</li>
</a></ol><a class="footnote-anchor" id="footnote-ref1">
<hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref1">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref1">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref1"></a><p><a class="footnote-anchor" id="footnote-ref1"></a><a href="https://docs.github.com/zh/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable" target="_blank" rel="noopener noreferrer">设置步骤的输出参数</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/l3/wallhaven-l3xk6q.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>评论系统从多说迁移到disqus指南</title>
      <link>https://oragekk.me/Zzh/blog/disqus.html</link>
      <guid>https://oragekk.me/Zzh/blog/disqus.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">评论系统从多说迁移到disqus指南</source>
      <description>由于多说评论系统将于 6 月 1 日下线，所以准备迁移至disqus，相比较的话对于国内环境还是多说好用一点，毕竟加载快，支持各大媒体的分享，也不用小伙伴们翻墙；而 disqus 分享也只支持 Facebook 和 twitter。。PS:貌似现在又被墙了，以后有时间再换吧，目前就先这样，国内据说畅言还不错</description>
      <category>Blog</category>
      <pubDate>Fri, 14 Apr 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>由于多说评论系统将于 6 月 1 日下线，所以准备迁移至<a href="https://disqus.com/" target="_blank" rel="noopener noreferrer">disqus</a>，相比较的话对于国内环境还是多说好用一点，毕竟加载快，支持各大媒体的分享，也不用小伙伴们翻墙；而 disqus 分享也只支持 Facebook 和 twitter。。PS:貌似现在又被墙了，以后有时间再换吧，目前就先这样，国内据说<a href="http://changyan.kuaizhan.com/static/help/" target="_blank" rel="noopener noreferrer">畅言</a>还不错</p>
</blockquote>
<h2> 迁移过程</h2>
<h3> 1.首先为了不丢失原有评论，导出多说评论</h3>
<figure><img src="http://i2.muimg.com/567571/f0d7b62ff410decf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.文件转换</h3>
<ul>
<li>由于 disqus 不支持多说导出的.json 文件，所以需要进行转换为 xml 文件，此处使用 github 上的轮子<a href="https://github.com/JamesPan/duoshuo-migrator" target="_blank" rel="noopener noreferrer">JamesPan/duoshuo-migrator</a></li>
<li>使用步骤
<ol>
<li>下载<a href="https://github.com/JamesPan/duoshuo-migrator/blob/master/duoshuo-migrator.py?raw=true" target="_blank" rel="noopener noreferrer">duoshuo-migrator.py</a>并安装依赖<br>
<img src="http://i2.muimg.com/567571/f98e1281fec1cdd7.png" alt="" loading="lazy"></li>
<li>执行 <code>python duoshuo-migrator.py -i ~/Desktop/export.json  -o disqus.xml</code>命令<br>
<img src="http://i2.muimg.com/567571/8e27bcddc31c29b2.png" alt="" loading="lazy"></li>
<li>将转换完成文件导入<br>
<img src="http://i2.muimg.com/567571/213761ad8cf62886.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
]]></content:encoded>
      <enclosure url="http://i2.muimg.com/567571/f0d7b62ff410decf.png" type="image/png"/>
    </item>
    <item>
      <title>Jekyll旧站回忆</title>
      <link>https://oragekk.me/Zzh/blog/jekyll.html</link>
      <guid>https://oragekk.me/Zzh/blog/jekyll.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Jekyll旧站回忆</source>
      <description>“Yeah It&amp;apos;s on. ” 前言 Oragekk 的 Blog 就这么开通了。 跳过废话，直接看技术实现 2016 年，11 月 总算有个地方可以好好写点东西了。 作为一个程序员， 看多了别人的 Blog 这种轮子都是酷炫的不要不要的，自己其实一种想搞一个，前两天发现了 GitHub Pages +Jekyll 的技术方案，一下子就上瘾了。 终于可以有自己的自留地了，之前一直在简书上写一些技术类的文章，这次可以有个自己的地盘，想怎么写就怎么写。😝 哈哈。不过这些前端的东西对我也是一种挑战，似懂非懂的看着模板，和一堆 js+css+html 的代码。。一顿头大。。对照着效果，一步步自己改。改好了之后也是蛮有成就感的嘛</description>
      <category>Blog</category>
      <pubDate>Thu, 03 Nov 2016 12:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>“Yeah It's on. ”</p>
</blockquote>
<h2> 前言</h2>
<p>Oragekk 的 Blog 就这么开通了。</p>
<p><a href="#build">跳过废话，直接看技术实现 </a></p>
<p>2016 年，11 月 总算有个地方可以好好写点东西了。</p>
<p>作为一个程序员， 看多了别人的 Blog 这种轮子都是酷炫的不要不要的，自己其实一种想搞一个，前两天发现了 GitHub Pages +Jekyll 的技术方案，一下子就上瘾了。</p>
<p>终于可以有自己的自留地了，之前一直在简书上写一些技术类的文章，这次可以有个自己的地盘，想怎么写就怎么写。😝 哈哈。不过这些前端的东西对我也是一种挑战，似懂非懂的看着模板，和一堆 js+css+html 的代码。。一顿头大。。对照着效果，一步步自己改。改好了之后也是蛮有成就感的嘛</p>
<h2> <p id="build"></p></h2>
<h2> 正文</h2>
<p>接下来说说搭建这个博客的技术细节。</p>
<p>正好之前就有关注过 <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a> + <a href="http://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p>
<p>其优点非常明显：</p>
<ul>
<li><strong>Markdown</strong> 带来的优雅写作体验</li>
<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>
<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
<ul>
<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>
</ul>
</li>
<li>Jekyll 的自定制非常容易，基本就是个模版引擎</li>
<li>Jekyll 的安装倒是不难，难的是安装它之前的一堆安装</li>
</ul>
<hr>
<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手</p>
<p>大的 Jekyll 主题直接 fork 了 Hux Blog<br>
本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功，现在淘宝的镜像地址也重定向了到<a href="http://gems.ruby-china.org/" target="_blank" rel="noopener noreferrer">gems.ruby-china.org</a> 公司的新电脑，正好连带配环境，装 rvm，ruby，gems，jekyll。搞定。不过最后的本地预览还是没搞好。索性我就改了 commit，去站点看效果。</p>
<p>之后看到域名还是 github 提供的固定域名，心里觉得不够高大上，果断万网去买了一个。还很便宜咯。。不过价格就不告诉你们了 😜</p>
<hr>
<p>以下引用自 Theme 作者</p>
<blockquote>
<p>Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），**不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……**所以为了体验，也补了不少 CSS 进去</p>
</blockquote>
<blockquote>
<p>最后就进入了耗时反而最长的<strong>做图、写字</strong>阶段，也算是进入了<strong>写博客</strong>的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。</p>
</blockquote>
<blockquote>
<p>第二天考虑中文字体的渲染，fork 了 <a href="http://www.typeisbeautiful.com/" target="_blank" rel="noopener noreferrer">Type is Beautiful</a> 的 <code>font</code> CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。</p>
</blockquote>
<hr>
<h2> 后记</h2>
<p>回顾这个博客的诞生，纯粹是出于个人兴趣。为了有个块自留地，可以无聊了写写，不开心了写写。</p>
<p>如果你恰好逛到了这里，希望你也能喜欢这个博客</p>
<p>—— 黄坤 后记于 2016.11</p>
]]></content:encoded>
    </item>
    <item>
      <title>评论插件 Waline 之邮件通知配置</title>
      <link>https://oragekk.me/Zzh/blog/waline-mail.html</link>
      <guid>https://oragekk.me/Zzh/blog/waline-mail.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">评论插件 Waline 之邮件通知配置</source>
      <description>评论插件 Waline 之邮件通知配置 ✨ 陆续优化中……这次到了评论的邮件通知，由于 waline 带后端，可以开启评论通知，我是部署在 Vercel 上的，配置一下就可以了，模版要感谢小波同学 前置注意点 1.邮件要注意每日发信限制，短时密集评论会导致直接被封，禁止发信 2.最好不要使用自己平常使用的邮箱，使用一个单独的邮箱来操作 3.有服务器的同学，自己部署SMTP服务可以不受限制</description>
      <category>Blog</category>
      <pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 评论插件 Waline 之邮件通知配置</h1>
<div class="hint-container info">
<p class="hint-container-title">✨</p>
<p>陆续优化中……这次到了评论的邮件通知，由于 waline 带后端，可以开启评论通知，我是部署在 Vercel 上的，配置一下就可以了，模版要感谢<a href="https://blog.ganxb2.com/" target="_blank" rel="noopener noreferrer">小波同学</a></p>
<p>前置注意点</p>
<p>1.邮件要注意每日发信限制，短时密集评论会导致直接被封，禁止发信</p>
<p>2.最好不要使用自己平常使用的邮箱，使用一个单独的邮箱来操作</p>
<p>3.有服务器的同学，自己部署SMTP服务可以不受限制</p>
</div>
<p>老规矩先放效果图:</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/29/8958076dc393c8df.png" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h2> 1. waline 官方邮件通知环境变量说明<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></h2><a class="footnote-anchor" id="footnote-ref1">
</a><h3><a class="footnote-anchor" id="footnote-ref1"></a> 1.1 waline 邮件通知必填环境变量</h3>
<p><code>SMTP_SERVICE: SMTP</code> 邮件发送服务提供商。例如 163 在受支持的运营商列表可以直接填写 163</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>你可以在 <a href="https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json" target="_blank" rel="noopener noreferrer">这里</a> 查看所有支持的运营商。</p>
<p>如果你的运营商不受支持，你必须填写 <code>SMTP_HOST 和 SMTP_PORT</code>。</p>
<ul>
<li>
<p><code>SMTP_HOST</code>: SMTP 服务器地址，一般可以在邮箱的设置中找到。</p>
</li>
<li>
<p><code>SMTP_PORT</code>: SMTP 服务器端口，一般可以在邮箱的设置中找到。</p>
</li>
</ul>
</div>
<p><code>SMTP_USER</code>: SMTP 邮件发送服务的用户名，一般为登录邮箱【切记要完整填写xxx@xxx.xx】。</p>
<p><code>SMTP_PASS</code>: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。 <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup></p><a class="footnote-anchor" id="footnote-ref2">
<p><code>SMTP_SECURE</code>: 是否使用 SSL 连接 SMTP。</p>
<p><code>SITE_NAME</code>: 网站名称，用于在消息中显示。</p>
<p><code>SITE_URL</code>: 网站地址，用于在消息中显示。</p>
<p><code>AUTHOR_EMAIL</code>: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。</p>
<div class="hint-container tip">
<p class="hint-container-title">注意</p>
<p>其中<code>SITE_NAME</code>如果有类似 <code>xxxx's Blog</code> 这种的网站名称，在 Vercel 中配置的时候，可以使用<code>xxxx Blog</code> 格式<br>
因为<code>'</code>单引号会在模版中被转义为<code>&amp;#39;s</code></p>
</div>
</a><h3><a class="footnote-anchor" id="footnote-ref2"></a> 1.2 waline 邮件通知选填环境变量</h3>
<p><code>SENDER_NAME</code>: 自定义发送邮件的发件人</p>
<p><code>SENDER_EMAIL</code>: 自定义发送邮件的发件地址</p>
<div class="hint-container tip">
<p class="hint-container-title">注意</p>
<p>其中<code>SENDER_NAME</code>和<code>SENDER_EMAIL</code> 要成对出现</p>
</div>
<h3> 1.3 waline 邮件通知模版环境变量</h3>
<p><code>MAIL_SUBJECT</code>: 自定义评论回复邮件标题</p>
<p><code>MAIL_TEMPLATE</code>: 自定义评论回复邮件内容</p>
<p><code>MAIL_SUBJECT_ADMIN</code>: 自定义新评论通知邮件标题</p>
<p><code>MAIL_TEMPLATE_ADMIN</code>: 自定义新评论通知邮件内容</p>
<h3> 1.4 waline邮件通知模版index.js服务端配置参数</h3>
<ul>
<li>
<p><code>mailSubject</code> 类型: string</p>
<p>评论回复邮件标题自定义，等同于环境变量 <code>MAIL_SUBJECT</code>。</p>
</li>
<li>
<p><code>mailTemplate</code> 类型: string</p>
<p>评论回复邮件内容自定义，等同于环境变量 <code>MAIL_TEMPLATE</code>。</p>
</li>
<li>
<p><code>mailSubjectAdmin</code> 类型: string</p>
<p>新评论通知邮件标题自定义，等同于环境变量 <code>MAIL_SUBJECT_ADMIN</code>。</p>
</li>
<li>
<p><code>mailTemplateAdmin</code> 类型: string</p>
<p>新评论通知邮件内容自定义，等同于环境变量 <code>MAIL_TEMPLATE_ADMIN</code>。</p>
</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>自此以下配置都是关于邮件模版的，1.3和1.4二选一配置即可，1.1是必填配置，自行填写即可。</p>
</div>
<h2> 2.根据部署方式选择合适的邮件模版修改方法</h2>
<h3> 2.1 vercel</h3>
<ul>
<li>环境变量<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></li><a class="footnote-anchor" id="footnote-ref3">
<li>私有walie仓库index.js文件【推荐】</li>
</a></ul><a class="footnote-anchor" id="footnote-ref3">
</a><h3><a class="footnote-anchor" id="footnote-ref3"></a> 2.2 独立部署</h3>
<ul>
<li>修改服务端入口文件index.js</li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>如果你使用模板，请额外注意你需要自行保存这些配置，因为它们会在拉取官方最新模板时被覆盖。</p>
<p>建议将官方最新模板上传到自己的仓库，并进行修改。</p>
</div>
<h2> 3.开始配置</h2>
<h3> 3.1 设置完毕1.1中Vercel配置必须的环境变量</h3>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/29/ab416544129053c3.png" alt="1.1" tabindex="0" loading="lazy"><figcaption>1.1</figcaption></figure>
<h3> 3.2 继续使用环境变量设置模版</h3>
<p><code>MAIL_SUBJECT_ADMIN</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>MAIL_TEMPLATE_ADMIN</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MAIL_SUBJECT</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MAIL_TEMPLATE</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 使用服务端入口文件index.js变量设置模版</h3>
<p>文件初始内容为:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container danger">
<p class="hint-container-title">注意!!!</p>
<p>在我查阅资料的过程中，发现很多教程中填写index.js的方式都是错误的，如下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是导致很多人index.js配置不成功的原因，把模版配置写在了postSave这个钩子函数里边,在Vercel部署的过程中就会直接报错，语法不正确</p>
</div>
<p>正确使用姿势:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 结语</h3>
<p>至此，大功告成，所有的注意点我都写在上边了</p>
<p>此模版来自SaraKale<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup><a class="footnote-anchor" id="footnote-ref4">，经</a><a href="https://blog.ganxb2.com/" target="_blank" rel="noopener noreferrer">小波同学</a>修改美化<br>
其他模版同理，可以去SaraKale这里看看</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p><a href="https://waline.js.org/guide/features/notification.html" target="_blank" rel="noopener noreferrer">https://waline.js.org/guide/features/notification.html</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>如 163 的 SMTP 授权码只生成一次，要复制存下来，如果丢失，后续不会再显示，只能重新生成 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p>Vercel 的环境变量大小限制为 4KB ，所以如果您的模板很长，请使用代码配置， <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote4" class="footnote-item"><p><a href="https://www.sarakale.top/blog/posts/537344b2.html" target="_blank" rel="noopener noreferrer">waline 邮件通知模板样式一览</a> <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/29/8958076dc393c8df.png" type="image/png"/>
    </item>
    <item>
      <title>一人一句宋词</title>
      <link>https://oragekk.me/Zzh/private/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8F%A5%E5%AE%8B%E8%AF%8D.html</link>
      <guid>https://oragekk.me/Zzh/private/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8F%A5%E5%AE%8B%E8%AF%8D.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">一人一句宋词</source>
      <description>Bing 每日壁纸 写来留待日后慢慢欣赏 😜 苏轼 十年生死两茫茫， 不思量，自难忘。 陆游 红酥手，黄藤酒， 满城春色宫墙柳。 李清照 此情无计可消除， 才下眉头，却上心头。</description>
      <pubDate>Mon, 16 Jan 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="https://file.mo7.cc/api/public/bz?idx=1" alt="Bing 每日壁纸" tabindex="0" loading="lazy"><figcaption>Bing 每日壁纸</figcaption></figure>
<blockquote>
<p>写来留待日后慢慢欣赏 😜</p>
</blockquote>
<h3> 苏轼</h3>
<p>十年生死两茫茫，<br>
不思量，自难忘。</p>
<h3> 陆游</h3>
<p>红酥手，黄藤酒，<br>
满城春色宫墙柳。</p>
<h3> 李清照</h3>
<p>此情无计可消除，<br>
才下眉头，却上心头。</p>
<h3> 辛弃疾</h3>
<p>众里寻他千百度。<br>
蓦然回首，那人却在，灯火阑珊处。</p>
<h3> 柳永</h3>
<p>多情自古伤离别，<br>
更那堪冷落清秋节！</p>
<h3> 范仲淹</h3>
<p>羌管悠悠霜满地，<br>
人不寐，将军白发征夫泪。</p>
<h3> 晏殊</h3>
<p>无可奈何花落去，<br>
似曾相识燕归来。</p>
<h3> 岳飞</h3>
<p>三十功名尘与土，八千里路云和月。<br>
莫等闲、白了少年头，空悲切！</p>
<h3> 秦观</h3>
<p>两情若是久长时，<br>
又岂在朝朝暮暮。</p>
<h3> 李之仪</h3>
<p>只愿君心似我心，<br>
定不负相思意。</p>
<h3> 欧阳修</h3>
<p>人生自是有情痴，<br>
此恨不关风与月。</p>
<h3> 唐婉</h3>
<p>世情薄，人情恶，<br>
雨送黄昏花易落。</p>
<h3> 姜夔</h3>
<p>二十四桥仍在，<br>
波心荡、冷月无声。</p>
<h3> 晏几道</h3>
<p>琵琶弦上说相思。<br>
当时明月在，曾照彩云归。</p>
<h3> 李冠</h3>
<p>一寸相思千万绪。<br>
人间没个安排处。</p>
<h3> 宋祁</h3>
<p>绿杨烟外晓寒轻，<br>
红杏枝头春意闹。</p>
<h3> 周彦邦</h3>
<p>执手霜风吹鬓影，<br>
去意徊徨，别语愁难听。</p>
<h3> 万俟咏</h3>
<p>短长亭，古今情。<br>
楼外凉蟾一晕生，雨余秋更清。</p>
<h3> 蒋捷</h3>
<p>流光容易把人抛，<br>
红了樱桃，绿了芭蕉。</p>
<h3> 吴潜</h3>
<p>老去惜花心，相对花无语。</p>
<h3> 刘著</h3>
<p>江南几度梅花发，<br>
人在天涯鬓已斑。</p>
<h3> 贺铸</h3>
<p>试问闲情都几许。<br>
一川烟草，满城风絮。梅子黄时雨。</p>
<h3> 严蕊</h3>
<p>不是爱风尘，似被前缘误。<br>
花落花开自有时，总赖东君主。</p>
<h3> 黄庭坚</h3>
<p>若有人知春去处。<br>
唤取归来同住。</p>
<h3> 张先</h3>
<p>天不老，情难绝。<br>
心似双丝网，中有千千结。</p>
<h3> 晁补之</h3>
<p>人生无奈别离何。<br>
夜长嫌梦短，泪少怕愁多。</p>
<h3> 乐婉</h3>
<p>若是前生未有缘，<br>
待重结、来生愿。</p>
<h3> 朱淑真</h3>
<p>把酒送春春不语。黄昏却下潇潇雨。</p>
<blockquote>
<p>看完了，跪安吧。╮(╯_╰)╭</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://file.mo7.cc/api/public/bz?idx=1" type="image/"/>
    </item>
    <item>
      <title>素材设计</title>
      <link>https://oragekk.me/Zzh/site/design.html</link>
      <guid>https://oragekk.me/Zzh/site/design.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">素材设计</source>
      <description>相关信息 素材、设计相关好用的网站 工具类</description>
      <category>收藏</category>
      <pubDate>Tue, 11 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>素材、设计相关好用的网站</p>
</div>
<h2> 工具类</h2>
]]></content:encoded>
    </item>
    <item>
      <title>公开API</title>
      <link>https://oragekk.me/Zzh/site/public-api.html</link>
      <guid>https://oragekk.me/Zzh/site/public-api.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">公开API</source>
      <description>相关信息 免费公开的API网站，提供多种公共接口服务</description>
      <category>收藏</category>
      <pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>免费公开的API网站，提供多种公共接口服务</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Vercel deploy忽略指定分支</title>
      <link>https://oragekk.me/Zzh/tutorial/vercel-deploy.html</link>
      <guid>https://oragekk.me/Zzh/tutorial/vercel-deploy.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Vercel deploy忽略指定分支</source>
      <description>Vercel Ignored Build Step使用</description>
      <category>Vercel</category>
      <pubDate>Fri, 31 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>一招教你解决Vercel deploy时总是任意分支都可以触发，如果你的项目有多个分支，可以指定某一个或几个有提交时触发deploy</p>
<!-- more -->
<h2> 1. 前言</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>这不是刚把博客部署从GitHub Pages转移到了Vercel上，稍微加快了一点国内的访问速度，然后发现了一个新问题~</p>
<p>原先是推送到<code>main</code>分之，通过Github Action 工作流进行部署到<code>gh-page</code> 分支上</p>
<p>转移到Vercel之后，工作流我并没有删掉，所以流程还是一样，就导致<code>main</code>提交了---&gt;Action----&gt;<code>gh-page</code>提交</p>
<p>会触发两次Vercel的部署，当然<code>gh-page</code>是存放静态页面的分支，buid肯定是失败的。下边来解决这个问题吧</p>
</div>
<h2> 2. 步骤</h2>
<p>如图所示，打开setting-Git-Ignored Build Step</p>
<p>启用“忽略构建步骤”字段。如果命令返回“0”，则将跳过构建。但是，如果返回代码“1”或更大，则将生成新的部署。</p>
<p>我是使用系统环境变量来做的，方式有很多，看自己方便吧，在Command处输入以下脚本表示只构建main分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统环境变量默认是曝光的，如果不生效，在Environment Variables 中勾选</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> Automatically expose System Environment Variables</label></li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/31/5ae4ba35bd181dcf.png" alt="setting-Git-Ignored Build Step" tabindex="0" loading="lazy"><figcaption>setting-Git-Ignored Build Step</figcaption></figure>
<h2> 3. 使用脚本</h2>
<p>要在“忽略构建步骤”中运行 bash 脚本，您需要在该字段中设置以下内容：请注意该文件应该存在于您的存储库中。 bash 脚本示例： bash script.shbash 脚本的示例：<code>bash script.sh</code></p>
<p><strong>注意</strong> 您也可以使用 Node 脚本（例如 ）。<code>node ignore-step.js</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 脚本，其中只允许部署对生产环境所做的提交。应将环境变量“VERCEL_ENV”添加到您的项目中。</p>
<p>通过使用此命令，Vercel 将仅在“VERCEL_ENV”的值为“production”时构建部署。该变量已添加到环境变量 UI，使其可用于项目。</p>
<h2> 4. <a href="#_7-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%80%E8%A7%88%E8%A1%A8">使用环境变量</a></h2>
<p>您可以直接在 Ignored Build Step 字段中创建引用系统环境变量的命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 命令，其中只允许部署对生产环境所做的提交。</p>
<p>下面是一个示例脚本，它将有条件地构建某些分支：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 命令，其中只允许部署从分支“main”和“staging”进行的提交。</p>
<h2> 5. 使用文件夹和工作区</h2>
<p>在继续之前，请记住 Ignored Build Step 在您选择的“根目录”的同一文件夹中运行。因此，您可能需要稍微调整一下以适应您的需要。要构建仅考虑特定文件夹的新部署，您可以使用以下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略构建步骤”命令的示例。如果将更改提交给“./packages/frontend/”，该命令将产生一个非空响应，从而允许构建继续进行。<br>
通过使用此命令，Vercel 将仅在目录内进行更改时构建部署。如果该文件夹是您选择的“根目录”，则可以使用：<code>packages/frontend/``./packages/frontend/</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略的生成步骤”命令的示例。如果将更改提交到 “.”，则该命令将生成非空响应，从而允许继续生成。</p>
<p>您还可以访问部署中的其他文件夹以检查更改。如果您在构建前端时选择了“根目录”，并且您的应用程序必须仅在进行更改时部署，您可以使用： <code>packages/web</code> <code>../../packages/docs</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略的生成步骤”命令的示例。如果将更改提交到“../../packages/docs“，该命令将产生一个非空响应，允许构建继续。</p>
<h2> 6. 在本地调试命令</h2>
<p>要在本地调试忽略的构建步骤命令，首先使用可以复制 Vercel 上可用设置的文件夹非常重要。为此，您可以应用以下步骤：</p>
<ol>
<li>使用 将存储库克隆到另一个文件夹。<code>git clone --depth=10 (...)</code></li>
<li>在终端中运行命令或脚本。</li>
<li>您可以使用 检查最后一个命令返回的退出代码。<code>echo $?</code></li>
</ol>
<h2> 7. 系统环境变量一览表</h2>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>VERCEL</code></td>
<td style="text-align:left">指示应用已在 Vercel 上部署和运行的指示器。 例：。<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CI</code></td>
<td style="text-align:left">指示代码在<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener noreferrer">持续集成</a>环境中运行的指示器。 例：。 <strong>注意：</strong> 此变量仅在<a href="https://vercel.com/docs/concepts/deployments/configure-a-build" target="_blank" rel="noopener noreferrer">构建步骤</a>期间公开。<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_ENV</code></td>
<td style="text-align:left">部署和运行应用<a href="https://vercel.com/docs/concepts/projects/environment-variables#environments" target="_blank" rel="noopener noreferrer">的环境</a>。该值可以是 、 或 。<code>production``preview``development</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_URL</code></td>
<td style="text-align:left"><a href="https://vercel.com/docs/concepts/deployments/generated-urls" target="_blank" rel="noopener noreferrer">生成的部署 URL</a> 的域名。例：。该值不包括协议方案。<code>*.vercel.app``https://</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_REGION</code></td>
<td style="text-align:left">运行应用的<a href="https://vercel.com/docs/concepts/edge-network/regions" target="_blank" rel="noopener noreferrer">区域的</a> ID。 例：。 <strong>注意：</strong> 此变量仅在<a href="https://vercel.com/docs/concepts/functions" target="_blank" rel="noopener noreferrer">无服务器函数</a>的运行时公开。<code>cdg1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PROVIDER</code></td>
<td style="text-align:left">从中触发部署的 Git 提供程序。 例：。<code>github</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_SLUG</code></td>
<td style="text-align:left">从中触发部署的源存储库。 例：。<code>my-site</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_OWNER</code></td>
<td style="text-align:left">拥有从中触发部署的存储库的帐户。 例：。<code>acme</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_ID</code></td>
<td style="text-align:left">从中触发部署的存储库的 ID。 例：。<code>117716146</code></td>
</tr>
<tr>
<td style="text-align:left"><mark><code>VERCEL_GIT_COMMIT_REF</code></mark></td>
<td style="text-align:left">触发部署的提交的 git 分支。 例：。<code>improve-about-page</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_SHA</code></td>
<td style="text-align:left">触发部署的提交的 git <a href="https://help.github.com/articles/github-glossary/#commit" target="_blank" rel="noopener noreferrer">SHA</a>。 例：。<code>fa1eade47b73733d6312d5abfad33ce9e4068081</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_MESSAGE</code></td>
<td style="text-align:left">附加到触发部署的提交的消息。 例：。<code>Update about page</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_AUTHOR_LOGIN</code></td>
<td style="text-align:left">附加到部署项目的提交作者的用户名。 例：。<code>johndoe</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_AUTHOR_NAME</code></td>
<td style="text-align:left">附加到部署项目的提交的作者的名称。 例：。<code>John Doe</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PREVIOUS_SHA</code></td>
<td style="text-align:left">项目和分支的上次成功部署的 git <a href="https://help.github.com/articles/github-glossary/#commit" target="_blank" rel="noopener noreferrer">SHA</a>。 例：。 <strong>注意：</strong> 仅当提供了<a href="https://vercel.com/docs/concepts/projects/overview#ignored-build-step" target="_blank" rel="noopener noreferrer">忽略的生成步骤</a>时，才会公开此变量。<code>fa1eade47b73733d6312d5abfad33ce9e4068080</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PULL_REQUEST_ID</code></td>
<td style="text-align:left">触发部署的拉取请求 ID。如果在发出拉取请求之前在分支上创建了部署，则此值将为空字符串。 例：。<code>23</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/31/5ae4ba35bd181dcf.png" type="image/png"/>
    </item>
    <item>
      <title>终端究极美化iTerm2+Pure</title>
      <link>https://oragekk.me/Zzh/posts/Linux/iterm2-pure.html</link>
      <guid>https://oragekk.me/Zzh/posts/Linux/iterm2-pure.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">终端究极美化iTerm2+Pure</source>
      <description>提示 之前介绍了ZSH的安装和使用，这次把最终成果介绍一下，就是ZSH + iTerm2 + Pure 前置工作：安装ZSH，请参照之前的文章👉zsh安装</description>
      <category>Linux</category>
      <pubDate>Fri, 24 Mar 2023 16:40:37 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>之前介绍了ZSH的安装和使用，这次把最终成果介绍一下，就是ZSH + iTerm2 + Pure</p>
<p>前置工作：安装ZSH，请参照之前的文章👉<a href="/Zzh/posts/Linux/zsh.html" target="blank">zsh安装</a></p>
</div>
<!-- more -->
<h2> 目录</h2>

<h2> 先看效果图</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/140a5562a8b9e334.png" alt="界面" tabindex="0" loading="lazy"><figcaption>界面</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/810d0c1d2a4d7069.png" alt="命令提示" tabindex="0" loading="lazy"><figcaption>命令提示</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/052c26b51ecde528.png" alt="流输出" tabindex="0" loading="lazy"><figcaption>流输出</figcaption></figure>
<h2> 安装pure</h2>
<p>👉<a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>可以使用 npm 或手动安装。需要 Git 2.15.2+ 和 ZSH 5.2+。已知旧版本的 ZSH 可以工作，但不推荐使用。</p>

<p>如果是手动安装的，将克隆的 repo 的路径添加到 $HOME/.zshrc 中的 $fpath 。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将以下内容复制到 <code>.zshrc</code>文件中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 .zshrc 中设置 ZSH_THEME="" 以禁用 oh-my-zsh 主题。</p>
<p>到这里就基本完成了，如果要基于pure做详细定制，请参考文档</p>
<h2> iTerm2</h2>
<p>👉戳这里下载 <a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener noreferrer">官方下载地址</a></p>
<p>效果图我自用的配置文件在这里 👉 <a href="https://pan.baidu.com/s/1cG-gSwoPouYXeZ-P2pjmAg" target="_blank" rel="noopener noreferrer">链接</a>  密码:74aq</p>
<h3> 1.主题配置</h3>
<p>访问iTerm2主题网站👉<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener noreferrer">iTerm2-Color-Schemes</a></p>
<p>可以下载zip包并解压到本地，进入解压缩的文件目录，找到schemes文件夹，里边全是主题配置，可以对照github上的效果图来选择</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/2eee92812c17fc48.png" alt="导入" tabindex="0" loading="lazy"><figcaption>导入</figcaption></figure>
<h3> 2. 标签页配色</h3>
<p>标签配色默认为黑色，不能与操作页面保持统一</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/9995b0382a76bba8.png" alt="默认" tabindex="0" loading="lazy"><figcaption>默认</figcaption></figure>
<p>打开iTerm2，打开Preferences配置界面，Appearence -&gt; General，将 Theme 改为 Minimal</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/411e917c7fb3d2b9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 设置 Status bar</h3>
<p>iTerm2 提供了不少的 Status bar，开启后我们可以在终端的最上方非常方便的实时查看本机的一些信息。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/d93a133dcd5fe00c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>打开iTerm2，打开Preferences配置界面，Profiles -&gt; session-&gt; 勾选 Status bar enable-&gt; configure Status bar，选择自己想要的展示内容即可。向下托动放入Active Components 中即可,我这里只选了CPU、内存、网络</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/918522902136668f.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 光标选择</h3>
<p>iterm提供了三种光标可供选择：_、|、[]。</p>
<p>打开iTerm2，打开Preferences配置界面，Profiles -&gt; text-&gt; cursor，选择自己想要的光标即可。</p>
<h3> 5.配置SSH快速连接</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果出现没有权限，就命令前面加上sudo</p>
<p>键盘输入i编辑文件，插入以下内容：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>myserver.sh文件中变量解释：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入完成后键盘esc 然后输入:wq退出，接下来给文件赋权</p>
<p>chmod 777 <a href="http://myserver.sh" target="_blank" rel="noopener noreferrer">myserver.sh</a><br>
打开iTerm2，打开Preferences配置界面，Profiles -&gt; general，左下角点击+号，新建profile，参考下面图片在对应位置输入内容即可。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/349fdd06e7bc428d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Name:根据需求输入，通常选择标识性较强的内容便于区分，例如服务器的IP地址</p>
<p>Command：这里选择login Shell</p>
<p>Send text at start ：填写格式形如A B C D E这样，每一个部分之间用空格隔开，根据自己实际情况填写,下面是对每一部分内容的解释</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>A 代表咱们上面写的本机保存sh脚本的路径：/Users/iterm/myserver.sh</p>
<p>B 代表服务器端口号一般远程连接端口为：22</p>
<p>C 代表服务器用户名一般为：root</p>
<p>D 代表服务器IP：公网IP填写</p>
<p>E 代表服务器密码：根据自己实际的服务器密码填写<br>
设置好之后打开iTerm2，点击profiles，点击前面自己新增的连接远程服务器的profile的名字</p>
<p>首次连接需要输入一次服务器密码，之后再连接就免密码登陆了</p>
</div>
<h2> 结语</h2>
<p>当然这里只介绍一部分，还有很多高级玩法，需要用到的时候自己去研究一下了</p>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/24/140a5562a8b9e334.png" type="image/png"/>
    </item>
    <item>
      <title>Unix/Linux 扫盲笔记</title>
      <link>https://oragekk.me/Zzh/posts/Linux/unix-linux-note.html</link>
      <guid>https://oragekk.me/Zzh/posts/Linux/unix-linux-note.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Unix/Linux 扫盲笔记</source>
      <description>This document is not completed and will be updated anytime. Catagory Catagory Unix Unix-like Single UNIX Specification Apple iOS XNU Kernel Linux Linux Kernel GNU Project Android Android Kernel Android ROM Chrome OS Chromium OS</description>
      <category>Linux</category>
      <pubDate>Tue, 14 Apr 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>This document is not completed and will be updated anytime.</p>
</blockquote>
<h2> Catagory</h2>
<ul>
<li><a href="#catagory">Catagory</a></li>
<li><a href="#unix">Unix</a></li>
<li><a href="#unix-like">Unix-like</a>
<ul>
<li><a href="#single-unix-specification">Single UNIX Specification</a></li>
<li><a href="#apple-ios">Apple iOS</a></li>
<li><a href="#xnu-kernel">XNU Kernel</a></li>
</ul>
</li>
<li><a href="#linux">Linux</a>
<ul>
<li><a href="#linux-kernel">Linux Kernel</a></li>
<li><a href="#gnu-project">GNU Project</a></li>
<li><a href="#android">Android</a></li>
<li><a href="#android-kernel">Android Kernel</a></li>
<li><a href="#android-rom">Android ROM</a></li>
<li><a href="#chrome-os">Chrome OS</a></li>
<li><a href="#chromium-os">Chromium OS</a></li>
</ul>
</li>
</ul>
<hr>
<h2> Unix</h2>
<blockquote>
<p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p>
</blockquote>
<p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p>
<ul>
<li>
<h4> Bell Labs</h4>
Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。<br>
<strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</li>
</ul>
<p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p>
<ul>
<li>
<h4> Xenix</h4>
<p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p>
</li>
<li>
<h4> BSD</h4>
<p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term "BSD" is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支) - <strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple's OS X and iOS ） - BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</p>
</li>
<li>
<h4> FreeBSD &amp; Apple</h4>
<p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p>
</li>
<li>
<h4> NeXTSTEP</h4>
<p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several "kits".<br>
大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p>
</li>
<li>
<h4> Darwin</h4>
<p>[Darwin](<a href="http://en.wikipedia.org/wiki/Darwin_(operating_system%5C)" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Darwin_(operating_system\)</a>), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)<br>
<strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p>
</li>
<li>
<h4> POSIX</h4>
<p>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS. - Fully POSIX compliant: - OS X - QNX OS (BlackBerry) - Mostly complicant: - Linux - OpenBSD/FreeBSD - Darwin (Core of <strong>iOS</strong> &amp; OS X) - <strong>Android</strong> - Complicant via compatibility feature （通过兼容功能实现兼容） - Windows NT Kernel - Windows Server 2000, 2003, 2008, 2008 R2, 2012 - Symbian OS (with PIPS) - Symbian was a closed-source OS.</p>
</li>
</ul>
<hr>
<h2> Unix-like</h2>
<blockquote>
<p>A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the <strong>Single UNIX Specification</strong>.</p>
</blockquote>
<p>There is no standard for defining the term.<br>
其实 Unix-like 是个相对模糊的概念：</p>
<ul>
<li>最狭义的 Unix 单指 Bell Labs's Unix</li>
<li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li>
<li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li>
</ul>
<h4> Single UNIX Specification</h4>
<p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name "Unix"</strong>, like <strong>POSIX</strong>.</p>
<h4> Apple iOS</h4>
<p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p>
<p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p>
<h4> XNU Kernel</h4>
<p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p>
<hr>
<h2> Linux</h2>
<blockquote>
<p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p>
</blockquote>
<figure><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png" alt="Unix_timeline" tabindex="0" loading="lazy"><figcaption>Unix_timeline</figcaption></figure>
<h4> Linux Kernel</h4>
<p>严格来讲，术语 Linux 只表示 <a href="http://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener noreferrer">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p>
<p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p>
<p>这类操作系统也被称为 <strong>GNU/Linux</strong></p>
<h4> GNU Project</h4>
<p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p>
<ul>
<li>Users are free to run the software, share (copy, distribute), study and modify it.</li>
<li>GNU software guarantees these freedom-rights legally (via its license).</li>
<li>So it is not only FREE but, more important, FREEDOM.</li>
</ul>
<p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p>
<p>This OS is decided to called <strong>GNU (a recursive acronym meaning "GNU is not Unix")</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p>
<p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p>
<p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p>
<p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p>
<ul>
<li><strong>GPL</strong>: GNU General Public License</li>
<li><strong>GCC</strong>: GNU Compiler Collection</li>
</ul>
<p>其他与 GPL 相关的自由/开源软件公共许可证：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Mozilla_Public_License" target="_blank" rel="noopener noreferrer">Mozilla Public License</a></li>
<li><a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener noreferrer">MIT License</a></li>
<li><a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener noreferrer">BSD Public License</a>
<ul>
<li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li>
</ul>
</li>
<li><a href="http://en.wikipedia.org/wiki/Apache_License" target="_blank" rel="noopener noreferrer">Apache License</a></li>
</ul>
<figure><img src="http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png" alt="Public License" tabindex="0" loading="lazy"><figcaption>Public License</figcaption></figure>
<h4> Android</h4>
<p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it's definitely <strong>Unix-like</strong>.</p>
<p><strong>Linux is under GPL so Android has to be open source</strong>.<br>
Android's source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em></p>
<h4> Android Kernel</h4>
<p>Android's kernel is based on one of the Linux kernel's long-term support (LTS) branches.</p>
<p><strong>Android's variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p>
<p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p>
<h4> Android ROM</h4>
<p>既然提到 Android 就不得不提提 Android ROM</p>
<p>ROM 的本义实际上是只读内存：</p>
<p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p>
<p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash</p>
<ul>
<li>PROM (Programmable read-only memory)</li>
<li>EPROM (Erasable programmable read-only memory)</li>
<li>EEPROM (Electrically erasable programmable read-only memory)
<ul>
<li>Flash memory (闪存)</li>
</ul>
</li>
</ul>
<p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为 U 盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p>
<p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p>
<p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href="http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares" target="_blank" rel="noopener noreferrer">List of custom Android firmwares</a></p>
<blockquote>
<p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p>
</blockquote>
<p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p>
<p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p>
<h4> Chrome OS</h4>
<p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p>
<p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p>
<ul>
<li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li>
<li><strong>Android App Runtime</strong> (run Android applications natively...fxxking awesome)</li>
</ul>
<p>平复一下激动的心情，还是回到正题来：</p>
<h4> Chromium OS</h4>
<p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p>
<p>For Detail, Chromium OS based on <a href="http://en.wikipedia.org/wiki/Gentoo_Linux" target="_blank" rel="noopener noreferrer">Gentoo Linux</a>, emm...</p>
]]></content:encoded>
      <enclosure url="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png" type="image/png"/>
    </item>
    <item>
      <title>更优雅强大的终端ZSH</title>
      <link>https://oragekk.me/Zzh/posts/Linux/zsh.html</link>
      <guid>https://oragekk.me/Zzh/posts/Linux/zsh.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">更优雅强大的终端ZSH</source>
      <description>MacOS 自带的 bash 作为几乎所有 Linux 发行版的默认终端，正常使用时没什么问题的 这里介绍一个更强大的终端神器 目录 背景介绍 在 unix 内核的操作系统中,当然现在衍生出好多分支,linux ,OS X 都算. shell 就算和上面这些系统内核指令打交道的一座桥梁,我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令) 然后 shell 解析这种命令再反馈给内核去执行一系列操作. zsh 和 shell 有什么关系呢?</description>
      <category>Linux</category>
      <pubDate>Wed, 24 Jul 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MacOS 自带的 bash 作为几乎所有 Linux 发行版的默认终端，正常使用时没什么问题的</p>
<p>这里介绍一个更强大的终端神器</p>
</blockquote>
<h2> 目录</h2>

<h2> 背景介绍</h2>
<p>在 unix 内核的操作系统中,当然现在衍生出好多分支,linux ,OS X 都算.</p>
<p>shell 就算和上面这些系统内核指令打交道的一座桥梁,我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令)</p>
<p>然后 shell 解析这种命令再反馈给内核去执行一系列操作.</p>
<p>zsh 和 shell 有什么关系呢?</p>
<p>其实 zsh 也是一种 shell ,但是并不是我们系统默认的 shell ,unix 衍生系统的默认 shell 都是 bash。</p>
<p>查看已安装 shell<br>
查看 Mac 上已有的 shell,一共有 6 种</p>
<hr>
<p><code>cat /etc/shells</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 安装 <strong>oh my zsh</strong></h2>

<p>安装成功：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成以后，默认<code>Shell</code>的<code>~/.bashrc</code>文件默认不再加载了，替代的是<code>~/.zlogin</code>和<code>~/.zshrc</code>。所以如果你在<code>~/.bashrc</code>里配置了某些设置，需要把她们复制到<code>~/.zshrc</code>中。</p>
<p>在<code>~/.zshrc</code> 中添加以下行</p>
<p><code>source ~/.bash_profile</code></p>
<h4> 切换终端为 zsh</h4>
<p><code>chsh -s /bin/zsh</code></p>
<h4> oh my zsh 目录结构</h4>
<p>进入<code>~/.oh-my-zsh</code>目录后，看看该目录的结构</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>lib 提供了核心功能的脚本库</li>
<li>tools 提供安装、升级等功能的快捷工具</li>
<li>plugins 自带插件的存在放位置</li>
<li>templates 自带模板的存在放位置</li>
<li>themes 自带主题文件的存在放位置</li>
<li>custom 个性化配置目录，自安装的插件和主题可放这里</li>
</ul>
<h3> 配置</h3>
<p><code>zsh</code> 的配置主要集中在<code>~/.zshrc</code>里，用 <code>vim</code> 或你喜欢的其他编辑器打开<code>.zshrc</code>。</p>
<p>可以在此处定义自己的环境变量和别名，当然，<code>oh my zsh</code> 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p>
<h4> 别名设置：</h4>
<p><code>zsh</code>不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p>
<ul>
<li><code>alias -s html=vi</code>，意思就是你在命令行输入 <code>hello.html</code>，<code>zsh</code>会为你自动打开<code>vim</code>并读取<code>hello.html</code>；</li>
<li><code>alias -s gz='tar -xzvf'</code>，表示自动解压后缀为<code>gz</code>的压缩包。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【其他】</p>
<ul>
<li><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener noreferrer">github zsh 主题参考</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_71539d240101fh8s.html" target="_blank" rel="noopener noreferrer">自定义 zsh 提示符</a></li>
</ul>
<h4> 主题设置：</h4>
<p><code>oh my zsh</code> 提供了数十种主题，相关文件在<code>~/.oh-my-zsh/themes</code>目录下，你可以自己选择，也可以自己编写主题。</p>
<p>在<code>.zshrc</code>里找到<code>ZSH_THEME</code>，就可以设置主题了，默认主题是：<code>ZSH_THEME=”robbyrussell”</code></p>
<p><code>ZSH_THEME="random"</code>，主题设置为随机，这样我们每打开一个窗口，都会随机在默认主题中选择一个。</p>
<h4> 插件设置：</h4>
<p><code>oh my zsh</code>项目提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下，默认提供了 100 多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 <code>zsh</code> 文件看一下就知道了。插件也是在<code>.zshrc</code>里配置，找到<code>plugins</code>关键字，你就可以加载自己的插件了，系统默认加载<code>git</code>，你可以在后面追加内容，如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> 安装 <code>zsh-autosuggestions</code></h5>
<p>autosuggestions 它是 Oh-myszh 的一个插件，作用基本上是根据历史输入指令的记录即时的提示，能够很大的提高效率</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加至 <code>plugins</code></p>
<h5> 安装 <code>zsh-syntax-highlighting</code></h5>
<p>代码高亮插件可以让终端颜色更加绚丽</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加至 <code>plugins</code></p>
<p><code>plugins=(zsh-autosuggestions git zsh-syntax-highlighting)</code></p>
<h2> 效果图</h2>
<figure><a href="https://imgchr.com/i/MarNhq" target="_blank" rel="noopener noreferrer"><img src="https://s2.ax1x.com/2019/11/15/MarNhq.md.png" alt="MarNhq.md.png" tabindex="0" loading="lazy"></a><figcaption>MarNhq.md.png</figcaption></figure>
<h3> 卸载 oh my zsh</h3>
<p>直接在终端中，运行<code>uninstall_oh_my_zsh</code>既可以卸载。</p>
]]></content:encoded>
      <enclosure url="https://s2.ax1x.com/2019/11/15/MarNhq.md.png" type="image/png"/>
    </item>
    <item>
      <title>前端-Q&amp;A</title>
      <link>https://oragekk.me/Zzh/posts/Web/Q_A.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/Q_A.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">前端-Q&amp;A</source>
      <description>前端-Q&amp;amp;A 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</description>
      <category>浏览器</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 前端-Q&amp;A</h1>
<h2> 浏览器是如何渲染页面的？</h2>
<p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<!-- more -->
<hr>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<hr>
<p>渲染的第一步是<strong>解析 HTML</strong>。</p>
<p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p>
<p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<hr>
<p>渲染的下一步是<strong>样式计算</strong>。</p>
<p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<hr>
<p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<hr>
<p>下一步是<strong>分层</strong></p>
<p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p>
<hr>
<p>再下一步是<strong>绘制</strong></p>
<p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<hr>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<hr>
<p>分块完成后，进入<strong>光栅化</strong>阶段。</p>
<p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图</p>
<hr>
<p>最后一个阶段就是<strong>画</strong>了</p>
<p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<h2> 什么是 reflow？</h2>
<p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p>
<h2> 什么是 repaint？</h2>
<p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<h2> 为什么 transform 的效率高？</h2>
<p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<h2> 阐述一下 JS 的事件循环</h2>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，<mark>微队列的任务一定具有最高的优先级，必须优先调度执行</mark>。</p>
<h2> JS 中的计时器能做到精确计时吗？为什么？</h2>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Actions 使用介绍</title>
      <link>https://oragekk.me/Zzh/tutorial/github/github-action.html</link>
      <guid>https://oragekk.me/Zzh/tutorial/github/github-action.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">GitHub Actions 使用介绍</source>
      <description>GitHub Actions 是什么？ Github Actions 是 Github 官方出的持续集成服务, 挺早之前就推出了。类似的还有如微软的DevOps、GitLab CI、Circle CI、Travis CI等等。大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</description>
      <category>GitHub</category>
      <pubDate>Fri, 14 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<!-- more -->

<h2> GitHub Actions 是什么？</h2>
<p>Github Actions 是 Github 官方出的持续集成服务, 挺早之前就推出了。类似的还有如微软的DevOps、GitLab CI、Circle CI、Travis CI等等。大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p>
<p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
<p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p>
<h2> 什么是CI/CD？</h2>
<p><a href="https://link.zhihu.com/?target=https%3A//www.redhat.com/en/topics/devops/what-is-ci-cd" target="_blank" rel="noopener noreferrer">What is CI/CD? (redhat.com)</a></p>
<p>字面意思就是持续集成Continuous Intergation/持续分发Continuous Delivery持续部署Continuous Deployment，网上有太多同质的解释都太过于晦涩，</p>
<p>提到CI/CD就离不开一个词叫流水线。流水线上每个人的工作是分工明确的，而且工程是有先后顺序，就像造一台车，先造零件，然后组装、喷涂、内饰最后还要测试。软件开发同样如此，有前期的产品设计，UI设计、单元的开发，产品的测试，优化迭代等都由不同的人负责。</p>
<p>CI/CD另一个作用就是解决团队代码中的冲突或错误。你提交的代码是否会和其他人的有冲突，如果有就不准你提交，回去再和其他哥们儿商量下。同样这一点也能解决你上传BUG代码的问题，同样禁止你。</p>
<p>如果要做的这几点那就一定需要一个中心化的工厂而且有另一个高效的团队来管理这个工厂的正常运行。CI/CD背后的提供商就是这样的工厂，而为了保证“持续”这个词，任何人都不可能24小时不睡觉帮你在工厂审核你的代码，所以自动化也是CI/CD的一个关键，自动触发机制使得以上所有的操作都是自动化完成的。所以这个工厂其实是无人化的工厂。</p>
<p>说到底CI/CD并不是一项新的技术，而是一种行业的标准，任何人在其上工作都必须遵守的标准，正因有这样的标准化流程，才能让团队的每一个人都能在自己的岗位上有效输出。说白了也就是领导团队想方设法提高员工效率榨干每一分钟的防摸鱼工具。（笑）</p>
<p>确实是这样，CI/CD的标准化工具的出现使得从开发到部署的周期大幅度缩短，再配上云开发的代码仓，那简直就是：云仓CI，法力无边。Github Action出现了。</p>
<h2> 基本概念</h2>
<p>GitHub Actions 有一些自己的术语。</p>
<p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p>
<p>（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p>
<p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
<p>（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
<h2> 关于工作流程</h2>
<p>工作流是一个可配置的自动化过程，将运行一个或多个作业。工作流由签入到存储库的YAML文件定义，并将在存储库中的事件触发时运行，或者可以手动触发，或者按照定义的计划。</p>
<p>工作流定义在存储库的 <code>.github/workflows</code> 目录中，一个存储库可以有多个工作流，每个工作流可以执行一组不同的任务。例如，您可以有一个工作流来构建和测试拉取请求，另一个工作流在每次创建发布时部署您的应用程序，还有一个工作流在每次有人打开新问题时添加标签。</p>
<p>workflow 文件的配置字段非常多，详见<a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">官方文档</a>。下面是一些基本字段。</p>
<p><strong>（1）<code>name</code></strong></p>
<p><code>name</code>字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>（2）<code>on</code></strong></p>
<p><code>on</code>字段指定触发 workflow 的条件，通常是某些事件。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码指定，<code>push</code>事件触发 workflow。</p>
<p><code>on</code>字段也可以是事件的数组。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码指定，<code>push</code>事件或<code>pull_request</code>事件都可以触发 workflow。</p>
<p>完整的事件列表，请查看<a href="https://help.github.com/en/articles/events-that-trigger-workflows" target="_blank" rel="noopener noreferrer">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p>
<p><strong>（3）<code>on.&lt;push|pull_request.&lt;tags|branches</code></strong></p>
<p>指定触发事件时，可以限定分支或标签。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码指定，只有<code>master</code>分支发生<code>push</code>事件时，才会触发 workflow。</p>
<p><strong>（4）<code>jobs.&lt;job_id.name</code></strong></p>
<p>workflow 文件的主体是<code>jobs</code>字段，表示要执行的一项或多项任务。</p>
<p><code>jobs</code>字段里面，需要写出每一项任务的<code>job_id</code>，具体名称自定义。<code>job_id</code>里面的<code>name</code>字段是任务的说明。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的<code>jobs</code>字段包含两项任务，<code>job_id</code>分别是<code>my_first_job</code>和<code>my_second_job</code>。</p>
<p><strong>（5）<code>jobs.&lt;job_id.needs</code></strong></p>
<p><code>needs</code>字段指定当前任务的依赖关系，即运行顺序。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>job1</code>必须先于<code>job2</code>完成，而<code>job3</code>等待<code>job1</code>和<code>job2</code>的完成才能运行。因此，这个 workflow 的运行顺序依次为：<code>job1</code>、<code>job2</code>、<code>job3</code>。</p>
<p><strong>（6）<code>jobs.&lt;job_id.runs-on</code></strong></p>
<p><code>runs-on</code>字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p>
<ul>
<li><code>ubuntu-latest</code>，<code>ubuntu-18.04</code>或<code>ubuntu-16.04</code></li>
<li><code>windows-latest</code>，<code>windows-2019</code>或<code>windows-2016</code></li>
<li><code>macOS-latest</code>或<code>macOS-10.14</code></li>
</ul>
<p>下面代码指定虚拟机环境为<code>ubuntu-18.04</code>。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>（7）<code>jobs.&lt;job_id.steps</code></strong></p>
<p><code>steps</code>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p>
<ul>
<li><code>jobs.&lt;job_id.steps.name</code>：步骤名称。</li>
<li><code>jobs.&lt;job_id.steps.run</code>：该步骤运行的命令或者 action。</li>
<li><code>jobs.&lt;job_id.steps.env</code>：该步骤所需的环境变量。</li>
</ul>
<p>下面是一个完整的 workflow 文件的范例。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>steps</code>字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p>
<h3> 工作流基础</h3>
<p>工作流必须包含以下基本组件：</p>
<ol>
<li>一个或多个将触发工作流的事件。</li>
<li>一个或多个作业，每个作业都将在运行机器上执行并运行一系列一个或多个步骤。</li>
<li>每个步骤都可以运行您定义的脚本或运行操作，这是一个可重用的扩展，可以简化您的工作流程。</li>
</ol>
<h3> 工作流触发</h3>
<p>可以有多种触发方式，具体参见<a href="https://docs.github.com/zh/actions/using-workflows/triggering-a-workflow" target="_blank" rel="noopener noreferrer">官方文档</a>,下面以我的一个工作流举例讲解触发事件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
<li>每天 UTC 23:00触发<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></li><a class="footnote-anchor" id="footnote-ref1">
<li>push下的分支和文件要同时触发才会使工作流运行</li>
</a></ol><a class="footnote-anchor" id="footnote-ref1">
<div class="hint-container danger">
<p class="hint-container-title">注意!!!</p>
<p>虽然官方文档未提及需要把<code>.github/workflows</code>目录下的工作流文件存储于指定触发分支下，但我实际操作中发现，如我设置的触发分支为<code>gh-pages</code>但假如我的.yaml文件在<code>main</code>分支下不在<code>gh-pages</code>根目录的<code>.github/workflows</code>文件夹下，实际并不会触发。</p>
</div>
</a><h2><a class="footnote-anchor" id="footnote-ref1"></a> 实例</h2>
<hr>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>这是一个<code>GitHub Actions</code>的配置文件，整体思路是，获取本次更新的url<br>
（通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了<code>sitemap.xml</code>文件，再利用python脚本进行url推送到百度、Bing、Google</p>
<p>脚本代码请看这里👉<a href="/posts/Python/submit-url" target="_blank" rel="noopener noreferrer">提交URL到搜索引擎（百度、Bing、Google）</a></p>
</div>
<!-- more -->
<p>前些天不是写了Bing的提交脚本吗，但是每次都要自己手动跑脚本也很麻烦，但我又没有服务器，所以用上了GitHub Actions了嘛<br>
总的来说做了以下事情：</p>
<ol>
<li>提交代码并修改sitemap.xml 后触发工作流</li>
<li>比对上一次提交和本次提交的新增URL</li>
<li>将URL分别提交给百度站长、Bing、Google 供搜索引擎快速收录</li>
<li></li>
</ol>
<h2> 流程解读</h2>
<h2> 配置代码</h2>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 配置解读</h2>
<h4> 触发</h4>
<p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
</ol>
<h4> 配置运行环境</h4>
<p>这里指定<code>ubuntu-latest</code></p>
<h4> 步骤</h4>
<ol>
<li>
<p>拉取 gh-pages 分支代码到路径<code>gh-pages</code></p>
</li>
<li>
<p>获取上一次提交SHA-1值使用如下命令，将获取到的倒数第二次git提交SHA-1值存储到环境变量<code>GITHUB_OUTPUT</code><sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup><a class="footnote-anchor" id="footnote-ref2">中，方便后续使用</a></p><a class="footnote-anchor" id="footnote-ref2">
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a></li><a class="footnote-anchor" id="footnote-ref2">
<li>
<p>获取上一步存储到到<code>GITHUB_OUTPUT</code>的commitid，并拉取代码代码到路径prev，ref可以是分支，tag，commitid</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>拉取main分支代码到路径main</p>
</li>
<li>
<p>安装python环境并设置缓存</p>
</li>
<li>
<p>安装python依赖库</p>
</li>
<li>
<p>运行脚本读取配置在仓库--&gt;Settings--&gt;Secrets and variables--&gt;Actions--&gt;Repository secrets中的环境变量，并把上次提交的sitemap.xml和本次提交的sitemap.xml作为命令行参数提交给python脚本</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/17/67c1bc7646f4be1d.png" alt="Repository secrets" tabindex="0" loading="lazy"><figcaption>Repository secrets</figcaption></figure>
</li>
</a></ol><a class="footnote-anchor" id="footnote-ref2">
<hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref2">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref2">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref2"></a><p><a class="footnote-anchor" id="footnote-ref2">可以使用 </a><a href="https://crontab.guru/" target="_blank" rel="noopener noreferrer">crontab guru</a> 帮助生成 cron 语法并确认其运行时间。 为了帮助入门，还提供了 <a href="https://crontab.guru/examples.html" target="_blank" rel="noopener noreferrer">crontab guru 示例</a>列表。计划工作流程的通知将发送给最后修改工作流程文件中的 cron 语法的用户。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/notifications-for-workflow-runs" target="_blank" rel="noopener noreferrer">工作流程运行通知</a>”。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p><a href="https://docs.github.com/zh/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable" target="_blank" rel="noopener noreferrer">设置步骤的输出参数</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/j3/wallhaven-j3zvvp.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Dart 中的并发</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/Flutter/concurrency.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/Flutter/concurrency.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Dart 中的并发</source>
      <description>Dart 通过 async-await、isolate 以及一些异步类型概念（例如 Future 和 Stream）支持了并发代码编程。本篇文章会对 async-await、Future 和 Stream 进行简略的介绍，而侧重点放在 isolate 的讲解上。 在应用中，所有的 Dart 代码都在 isolate 中运行。每一个 Dart 的 isolate 都有独立的运行线程，它们无法与其他 isolate 共享可变对象。在需要进行通信的场景里，isolate 会使用消息机制。很多 Dart 应用都只使用一个 isolate，也就是 main isolate。你可以创建额外的 isolate 以便在多个处理器核心上执行并行代码。</description>
      <category>Flutter</category>
      <category>Dart</category>
      <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Dart 通过 async-await、isolate 以及一些异步类型概念（例如 <code>Future</code> 和 <code>Stream</code>）支持了并发代码编程。本篇文章会对 async-await、<code>Future</code> 和 <code>Stream</code> 进行简略的介绍，而侧重点放在 isolate 的讲解上。</p>
<p>在应用中，所有的 Dart 代码都在 <strong>isolate</strong> 中运行。每一个 Dart 的 isolate 都有独立的运行线程，它们无法与其他 isolate 共享可变对象。在需要进行通信的场景里，isolate 会使用消息机制。很多 Dart 应用都只使用一个 isolate，也就是 main isolate。你可以创建额外的 isolate 以便在多个处理器核心上执行并行代码。</p>
<p>尽管 Dart 的 isolate 模型设计是基于操作系统提供的进程和线程等更为底层的原语进行设计的， Dart 虚拟机对其的使用是一个具体的实现，在本篇文章中，我们不对其具体实现展开讨论。</p>
<h2> 异步的类型和语法</h2>
<p>如果你已经对 <code>Future</code>、<code>Stream</code> 和 async-await 比较熟悉了，可以直接跳到 <a href="https://dart.cn/guides/language/concurrency#how-isolates-work" target="_blank" rel="noopener noreferrer">isolate 部分</a> 进行阅读。</p>
<h3> Future 和 Stream 类型</h3>
<p>Dart 语言和库通过 <code>Future</code> 和 <code>Stream</code> 对象，来提供会在当前调用的未来返回某些值的功能。以 JavaScript 中的 Promise 为例，在 Dart 中一个最终会返回 <code>int</code> 类型值的 promise，应当声明为 <code>Future&lt;int&gt;</code>；一个会持续返回一系列 <code>int</code> 类型值的 promise，应当声明为 <code>Stream&lt;int&gt;</code>。</p>
<p>让我们用 dart:io 来举另外一个例子。<code>File</code> 的同步方法 <a href="https://api.dart.cn/stable/dart-io/File/readAsStringSync.html" target="_blank" rel="noopener noreferrer"><code>readAsStringSync()</code></a> 会以同步调用的方式读取文件，在读取完成或者抛出错误前保持阻塞。这个会返回 <code>String</code> 类型的对象，或者抛出异常。而与它等效的异步方法 <a href="https://api.dart.cn/stable/dart-io/File/readAsString.html" target="_blank" rel="noopener noreferrer"><code>readAsString()</code></a>，会在调用时立刻返回 <code>Future&lt;String&gt;</code> 类型的对象。在未来的某一刻，<code>Future&lt;String&gt;</code> 会结束，并返回一个字符串或错误。</p>
<h4> 为什么异步的代码如此重要？</h4>
<p>It matters whether a method is synchronous or asynchronous because most apps need to do more than one thing at a time.</p>
<p>大部分应用需要在同一时刻做很多件事。例如，应用可能会发起一个 HTTP 请求，同时在请求返回前对用户的操作做出不同的界面更新。异步的代码会有助于应用保持更高的可交互状态。</p>
<p>异步场景包括调用系统 API，例如非阻塞的 I/O 操作、HTTP 请求或与浏览器交互。还有一些场景是利用 Dart 的 isolate 进行计算，或等待一个计时器的触发。这些场景要么是在不同的线程运行，要么是被系统或 Dart 运行时处理，让 Dart 代码可以在计算时同步运行。</p>
<h3> async-await 语法</h3>
<p><code>async</code> 和 <code>await</code> 关键字是用声明来定义异步函数和获取它们的结果的方式。</p>
<p>下面是一段同步代码调用文件 I/O 时阻塞的例子：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是类似的代码，但是变成了 <strong>异步调用</strong>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>main()</code> 函数在调用 <code>_readFileAsync()</code> 前使用了 <code>await</code> 关键字，让原生代码（文件 I/O）执行的同时，其他的 Dart 代码（例如事件处理器）能继续执行。使用 <code>await</code> 后，<code>_readFileAsync()</code> 调用返回的 <code>Future&lt;String&gt;</code> 类型也转换为了 <code>String</code>。从而在将结果 <code>content</code> 赋予变量时，隐式转换为 <code>String</code> 类型。</p>
<p><strong>备注:</strong></p>
<p><code>await</code> 关键字仅在函数体前定义了 <code>async</code> 的函数中有效。</p>
<p>如下图所示，无论是在 Dart VM 还是在系统中， Dart 代码都会在 <code>readAsString()</code> 执行非 Dart 代码时暂停。在 <code>readAsString()</code> 返回值后，Dart 代码将继续执行。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-await.png" alt="类似于流程图的图形显示了应用程序代码从开始到退出的执行过程，在这之间等待本地I/O" tabindex="0" loading="lazy"><figcaption>类似于流程图的图形显示了应用程序代码从开始到退出的执行过程，在这之间等待本地I/O</figcaption></figure>
<p>如果你想了解更多关于 <code>async</code>、<code>await</code> 和 <code>Future</code> 的内容，可以访问 <a href="https://dart.cn/codelabs/async-await" target="_blank" rel="noopener noreferrer">异步编程 codelab</a> 进行学习。</p>
<h2> Isolate 的工作原理</h2>
<p>现代的设备通常会使用多核 CPU。开发者为了让程序在设备上有更好的表现，有时会使用共享内容的线程来并发运行代码。然而，状态的共享可能会 <a href="https://baike.baidu.com/l/kex6qKvt" target="_blank" rel="noopener noreferrer">产生竞态条件，从而造成错误</a>，也可能会增加代码的复杂度。</p>
<p>Dart 代码并不在多个线程上运行，取而代之的是它们会在 isolate 内运行。每一个 isolate 会有自己的堆内存，从而确保 isolate 之间互相隔离，无法互相访问状态。由于这样的实现并不会共享内存，所以你也不需要担心 <a href="https://baike.baidu.com/l/My2bXiba" target="_blank" rel="noopener noreferrer">互斥锁和其他锁</a>。</p>
<p>在使用 isolate 时，你的 Dart 代码可以在同一时刻进行多个独立的任务，并且使用可用的处理器核心。 Isolate 与线程和进程近似，但是<mark>每个 isolate 都拥有独立的内存，以及运行事件循环的独立线程。</mark></p>
<p><strong>Platform note:</strong> Only the <a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">Dart Native platform</a> implements isolates. To learn more about the Dart Web platform, see the <a href="https://dart.cn/guides/language/concurrency#concurrency-on-the-web" target="_blank" rel="noopener noreferrer">Concurrency on the web</a> section.</p>
<div class="hint-container info">
<p class="hint-container-title">平台说明</p>
<p>只有<a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">Dart Native</a>平台实现了隔离器。要了解更多关于Dart网络平台的信息，请参见<a href="#%E5%9C%A8web%E7%9A%84%E5%B9%B6%E5%8F%91">Web的并发性部分</a>。</p>
</div>
<h3> 主 isolate</h3>
<p>在一般场景下，你完全无需关心 isolate。通常一个 Dart 应用会在主 isolate 下执行所有代码，如下图所示：</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-main-isolate.png" alt="图中显示了一个主隔离区，它运行，对事件作出反应，然后退出" tabindex="0" loading="lazy"><figcaption>图中显示了一个主隔离区，它运行<code>main()</code>，对事件作出反应，然后退出</figcaption></figure>
<p>就算是只有一个 isolate 的应用，只要通过使用 async-await 来处理异步操作，也完全可以流畅运行。一个拥有良好性能的应用，会在快速启动后尽快进入事件循环。这使得应用可以通过异步操作快速响应对应的事件。</p>
<h3> Isolate 的生命周期</h3>
<p>如下图所示，每个 isolate 都是从运行 Dart 代码开始的，比如 <code>main()</code> 函数。执行的 Dart 代码可能会注册一些事件监听，例如处理用户操作或文件读写。当 isolate 执行的 Dart 代码结束后，如果它还需要处理已监听的事件，那么它依旧会继续被保持。处理完所有事件后，isolate 会退出。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-isolate.png" alt="一个更一般的图显示，任何隔离体都会运行一些代码，选择性地对事件做出反应，然后退出" tabindex="0" loading="lazy"><figcaption>一个更一般的图显示，任何隔离体都会运行一些代码，选择性地对事件做出反应，然后退出</figcaption></figure>
<h3> 事件处理</h3>
<p>在客户端应用中，主 isolate 的事件队列内，可能会包含重绘的请求、点击的通知或者其他界面事件。例如，下图展示了包含四个事件的事件队列，队列会按照先进先出的模式处理事件。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-loop.png" alt="一个显示事件被逐一送入事件循环的图。" tabindex="0" loading="lazy"><figcaption>一个显示事件被逐一送入事件循环的图。</figcaption></figure>
<p>如下图所示，在 <code>main()</code> 方法执行完毕后，事件队列中的处理才开始，此时处理的是第一个重绘的事件。而后主 isolate 会处理点击事件，接着再处理另一个重绘事件。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-handling.png" alt="显示主隔离区逐一执行事件处理程序的图" tabindex="0" loading="lazy"><figcaption>显示主隔离区逐一执行事件处理程序的图</figcaption></figure>
<p>如果某个同步执行的操作花费了很长的处理时间，应用看起来就像是失去了响应。在下图中，处理点击事件的代码比较耗时，导致紧随其后的事件并没有及时处理。这时应用可能会产生卡顿，所有的动画都无法流畅播放。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-jank.png" alt="图中显示了一个执行时间过长的分接处理程序" tabindex="0" loading="lazy"><figcaption>图中显示了一个执行时间过长的分接处理程序</figcaption></figure>
<p>在一个客户端应用中，耗时过长的同步操作，通常会导致 <a href="https://flutter.cn/docs/perf/rendering-performance" target="_blank" rel="noopener noreferrer">卡顿的动画</a>。而最糟糕的是，应用界面可能完全失去响应。</p>
<h3> 后台运行对象</h3>
<p>如果你的应用受到耗时计算的影响而出现卡顿，例如 <a href="https://flutter.cn/docs/cookbook/networking/background-parsing" target="_blank" rel="noopener noreferrer">解析较大的 JSON 文件</a>，你可以考虑将耗时计算转移到单独工作的 isolate，通常我们称这样的 isolate 为 <strong>后台运行对象</strong>。下图展示了一种常用场景，你可以生成一个 isolate，它将执行耗时计算的任务，并在结束后退出。这个 isolate 工作对象退出时会把结果返回。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/isolate-bg-worker.png" alt="A figure showing a main isolate and a simple worker isolate" tabindex="0" loading="lazy"><figcaption>A figure showing a main isolate and a simple worker isolate</figcaption></figure>
<p>每个 isolate 都可以通过消息通信传递一个对象，这个对象的所有内容都需要满足可传递的条件。并非所有的对象都满足传递条件，在无法满足条件时，消息发送会失败。举个例子，如果你想发送一个 <code>List&lt;Object&gt;</code>，你需要确保这个列表中所有元素都是可被传递的。假设这个列表中有一个 <code>Socket</code>，由于它无法被传递，所以你无法发送整个列表。</p>
<p>你可以查阅 <a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code> 方法</a> 的文档来确定哪些类型可以进行传递。</p>
<p>Isolate 工作对象可以进行 I/O 操作、设置定时器，以及其他各种行为。它会持有自己内存空间，与主 isolate 互相隔离。这个 isolate 在阻塞时也不会对其他 isolate 造成影响。</p>
<h2> 代码示例</h2>
<p>本节将重点讨论使用 <code>Isolate</code> API 实现 isolate 的一些示例。</p>
<h3> 实现一个简单的 isolate 工作对象</h3>
<p>这些例子实现了一个主隔离器，它生成了一个简单的工作隔离器。 <a href="https://api.dart.cn/dev/dart-isolate/Isolate/run.html" target="_blank" rel="noopener noreferrer"><code>Isolate.run()</code></a> 简化了设置和管理工作者隔离区的步骤:</p>
<ol>
<li>生成（启动并创建）一个隔离器</li>
<li>在生成的隔离体上运行一个函数</li>
<li>捕获结果</li>
<li>将结果返回给主隔离区</li>
<li>工作完成后，终止隔离区的运行</li>
<li>检查、捕获并将异常和错误抛回给主隔离区</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">备注</p>
<p>如果你使用Flutter，考虑使用<a href="https://api.flutter-io.cn/flutter/foundation/compute-constant.html" target="_blank" rel="noopener noreferrer">Flutter的<code>compute()</code>函数</a>而不是<code>Isolate.run()</code>。<code>compute</code>函数允许你的代码在<a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">本地和非本地平台</a>上工作。当只针对原生平台时，使用<code>Isolate.run()</code>以获得更符合人类工程学的的API。</p>
</div>
<h4> 在一个新的隔离区中运行一个现有的方法</h4>
<p>主 isolate 的代码如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的隔离器会执行作为第一个参数传递的函数, <code>_readAndParseJson</code>:</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li><code>Isolate.run()</code> 产生了一个隔离器，即后台工作者， 而 <code>main()</code> 则在等待结果</li>
<li>生成的隔离器会执行传递给 <code>run()</code>的参数: the function <code>_readAndParseJson()</code>.</li>
<li><code>Isolate.run()</code> 从返回中获取结果，并将该值送回主隔离区，从而关闭工作隔离区。</li>
<li>工作者隔离区会将保存结果的内存<em>转移</em>到主隔离区。它并<em>不复制</em>数据。工作者隔离区会执行一个验证通道，以确保对象被允许转移。</li>
</ol>
<p><code>_readAndParseJson()</code> 是一个现有的异步函数，可以很容易地直接在主隔离区中运行。使用 <code>Isolate.run()</code> 来运行它，从而实现了并发性。工作者隔离区完全抽象了<code>_readAndParseJson()</code>的计算过程。它可以在不阻塞主隔离区的情况下完成。</p>
<p><code>Isolate.run()</code> 的结果总是一个Future，因为主隔离区的代码仍在继续运行。工作者隔离区执行的计算是同步的还是异步的，并不影响主隔离区，因为无论如何，它都是在并发地运行。</p>
<h4> Sending closures with isolates</h4>
<p>您也可以在主隔离区中直接使用函数字面或闭包，用<code>run()</code> 创建一个简单的工作隔离区。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的完成情况与前一个例子相同。一个新的隔离器产生了，计算了一些东西，并把结果送了回来。</p>
<p>不过，现在这个隔离体发送的是一个<a href="https://dart.cn/guides/language/language-tour#anonymous-functions" target="_blank" rel="noopener noreferrer">闭包</a>。与典型的命名函数相比，闭包的限制较少，无论是在功能上还是在代码中的编写方式上。在这个例子中，<code>Isolate.run()</code>执行的是看起来像本地代码的东西，同时进行。在这个意义上，你可以把<code>run()</code>想象成一个 "并行运行 "的<a href="https://dart.cn/guides/language/language-tour#control-flow-statements" target="_blank" rel="noopener noreferrer">控制流操作符</a>。</p>
<h3> 实现一个简单的 isolate 工作对象</h3>
<p><code>Isolate.run()</code> a抽取了一些较低级别的、与隔离物相关的API，以简化隔离物管理：</p>
<ul>
<li><a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawn()</code></a> and <a href="https://api.dart.cn/stable/dart-isolate/Isolate/exit.html" target="_blank" rel="noopener noreferrer"><code>Isolate.exit()</code></a></li>
<li><a href="https://api.dart.cn/stable/dart-isolate/ReceivePort-class.html" target="_blank" rel="noopener noreferrer"><code>ReceivePort</code></a> and <a href="https://api.dart.cn/stable/dart-isolate/SendPort-class.html" target="_blank" rel="noopener noreferrer"><code>SendPort</code></a></li>
</ul>
<p>您可以直接使用这些基元来对隔离区的功能进行更精细的控制。例如，<code>run()</code>在返回一条消息后就会关闭其隔离区。如果您想允许多个消息在隔离区之间传递，该怎么办呢？您可以用与<code>run()</code>的实现方式大致相同的方式来设置自己的隔离区，只是以稍微不同的方式利用<code>SendPort</code>的<a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code>方法</a>。</p>
<p>如果你想在 isolate 之间建立更多的通信，那么你需要使用 <code>SendPort</code> 的 <a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code> 方法</a>。下图展示了一种常见的场景，主 isolate 会发送请求消息至 isolate 工作对象，然后它们之间会继续进行多次通信，进行请求和回复。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/isolate-custom-bg-worker.png" alt="图中显示了主隔离器催生隔离器，然后发送请求消息，工作隔离器用回复消息进行响应；显示了两个请求-回复循环。" tabindex="0" loading="lazy"><figcaption>图中显示了主隔离器催生隔离器，然后发送请求消息，工作隔离器用回复消息进行响应；显示了两个请求-回复循环。</figcaption></figure>
<p>下方列举的 <a href="https://github.com/dart-lang/samples/tree/master/isolates" target="_blank" rel="noopener noreferrer">isolate 示例</a> 包含了发送多次消息的使用方法：</p>
<ul>
<li><a href="https://github.com/dart-lang/samples/tree/master/isolates/bin/send_and_receive.dart" target="_blank" rel="noopener noreferrer">send_and_receive.dart</a> 展示了如何从主 isolate 发送消息至生成的 isolate，与前面的示例较为接近，不过没有使用 <code>run()</code> 方法；</li>
<li><a href="https://github.com/dart-lang/samples/tree/master/isolates/bin/long_running_isolate.dart" target="_blank" rel="noopener noreferrer">long_running_isolate.dart</a> 展示了如何生成一个长期运行、且多次发送和接收消息的 isolate。</li>
</ul>
<h2> 性能和 isolate 组</h2>
<p>当一个 isolate 调用了 <a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawn()</code></a>，两个 isolate 将拥有同样的执行代码，并归入同一个 <strong>isolate 组</strong> 中。 Isolate 组会带来性能优化，例如新的 isolate 会运行由 isolate 组持有的代码，即共享代码调用。同时，<code>Isolate.exit()</code> 仅在对应的 isolate 属于同一组时有效。</p>
<p>某些场景下，你可能需要使用 <a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawnUri.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawnUri()</code></a>，使用执行的 URI 生成新的 isolate，并且包含代码的副本。然而，<code>spawnUri()</code> 会比 <code>spawn()</code> 慢很多，并且新生成的 isolate 会位于新的 isolate 组。另外，当 isolate 在不同的组中，它们之间的消息传递会变得更慢。</p>
<div class="hint-container tip">
<p class="hint-container-title">备注</p>
<p><img src="https://dart.cn/assets/img/shared/flutter/icon/64.png" alt="Flutter logo" width="20" loading="lazy">Flutter 不支持 <code>Isolate.spawnUri()</code>。</p>
</div>
<h2> 在Web的并发</h2>
<p>所有的Dart应用程序都可以使用<code>async-await</code>、<code>Future</code>和<code>Stream</code>进行非阻塞、交错的计算。然而，<a href="(https://dart.cn/overview#platform)">Dart web 平台</a>并不支持隔离器。Dart网络应用程序可以使用网络工作者在后台线程中运行脚本，这与隔离程序类似。不过，<a href="https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener noreferrer">web workers</a>的功能和能力与隔离器有些不同。</p>
<p>例如，当Web工作者在线程之间发送数据时，他们会来回复制数据。不过，数据复制的速度可能非常慢，尤其是对于大的消息。隔离器也做同样的事情，但也提供了API，可以更有效地传输保存消息的内存。</p>
<p>创建Web Worker和Isolates也有不同。你只能通过声明一个单独的程序入口并单独编译来创建网络工作者。启动Web Worker类似于使用<code>Isolate.spoonUri</code>来启动一个隔离器。您也可以使用<code>Isolate.spown</code>来启动一个隔离器，这需要的资源较少，因为它<a href="https://dart.cn/guides/language/concurrency#performance-and-isolate-groups" target="_blank" rel="noopener noreferrer">重用了一些与催生隔离器相同的代码和数据</a>。Web Worker没有一个同等的API。</p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/72/wallhaven-7286w9.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 基础大集合</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/Flutter/newbie.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/Flutter/newbie.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Flutter 基础大集合</source>
      <description>Flutter初学，demo</description>
      <category>Flutter</category>
      <category>前端跨平台</category>
      <pubDate>Mon, 20 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>把之前学习时候写的demo拿出来记录一下<br>
地址：<br>
<a href="https://github.com/OrageKK/flutter_my_app" target="_blank" rel="noopener noreferrer">flutter_my_app</a></p>
</div>
<p>demo是照着B站的视频敲的，现在可能用不上了，但是还是觉得当时写的demo对于想学习flutter的新手来说作用还是有的，因为视频课程很零散，所以我边看边写了一个app，里边基本介绍了大部分基础的用法，当然进阶的东西，这部分demo是没有的，最近也在忙，有空了再补一部分进阶的东西吧</p>
<p>现在在做的内容是native+flutter混编，其中坑也不少，有时间会慢慢记录一下</p>
<h2> 预览</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/b4d8d0a22fcdfd1a.png" alt="home" width="500" tabindex="0" loading="lazy"><figcaption>home</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/a4e70357270289d9.png" alt="side" width="500" tabindex="0" loading="lazy"><figcaption>side</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/88359eef4b2eee2f.png" alt="animation" width="500" tabindex="0" loading="lazy"><figcaption>animation</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/a1e88c9565dd0831.png" alt="search" width="500" tabindex="0" loading="lazy"><figcaption>search</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/5e6fe8f921ad4079.png" alt="alert" width="500" tabindex="0" loading="lazy"><figcaption>alert</figcaption></figure>
<h2> Getting Started</h2>
<p>This project is a starting point for a Flutter application.</p>
<p>A few resources to get you started if this is your first Flutter project:</p>
<ul>
<li><a href="https://docs.flutter.dev/get-started/codelab" target="_blank" rel="noopener noreferrer">Lab: Write your first Flutter app</a></li>
<li><a href="https://docs.flutter.dev/cookbook" target="_blank" rel="noopener noreferrer">Cookbook: Useful Flutter samples</a></li>
</ul>
<p>For help getting started with Flutter development, view the<br>
<a href="https://docs.flutter.dev/" target="_blank" rel="noopener noreferrer">online documentation</a>, which offers tutorials,<br>
samples, guidance on mobile development, and a full API reference.</p>
<h2> 包含</h2>
<ul>
<li>路由管理</li>
<li>基础组件（Text、Image、Icon）</li>
<li>布局组件
<ul>
<li>容器组件Container</li>
<li>线性布局Row、Column</li>
<li>弹性布局Flex</li>
<li>流式布局Wrap</li>
<li>层叠布局Stack、Positioned</li>
<li>对齐与相对定位Align</li>
</ul>
</li>
<li>容器类组件
<ul>
<li>填充Padding</li>
<li>装饰容器DecoratedBox</li>
<li>变换Transform</li>
<li>剪裁Clip</li>
<li>页面骨架Scaffold、AppBar</li>
<li>抽屉菜单Drawer</li>
<li>底部Tab导航</li>
<li>页面body</li>
</ul>
</li>
<li>可滚动组件
<ul>
<li>GridView</li>
<li>ListView</li>
<li>TabBarView</li>
<li>CustomScrollView 和 Slivers</li>
</ul>
</li>
<li>动画
<ul>
<li>隐式动画</li>
<li>显式动画</li>
<li>交错动画</li>
<li>动画切换组件（AnimatedSwitcher）</li>
</ul>
</li>
</ul>
<h2> 使用库</h2>
<ul>
<li>fluttertoast: ^8.0.9</li>
<li>cached_network_image: ^3.2.2</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Flutter 工作原理</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/Flutter/principle.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/Flutter/principle.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Flutter 工作原理</source>
      <description>Flutter 工作原理 本文档解释了使 Flutter API 正常工作的 Flutter 工具包内部工作原理。由于 Flutter widget 是以积极组合的形式构建的，所以使用 Flutter 构建的用户界面含有大量 widget。为了支撑这些负载，Flutter 使用了次线性算法来布局和构建 widget，这些数据结构使树形结构优化更加高效，并且具有很多常量因子优化。通过一些额外的机制，该设计也允许开发者利用回调（用于构建用户可见的 widget）来轻松创建无限滚动列表。 积极可组合性 组合性是 Flutter 最为出众的一个特性。widget 通过组合其他 widget 的方式进行构建，并且这些 widget 自身由更基础的 widget 构建。比如，Padding 是一个 widget 而非其他 widget 的属性。因此，使用 Flutter 创建的用户界面是由多个 widget 组成的。</description>
      <category>Flutter</category>
      <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Flutter 工作原理</h1>
<p>本文档解释了使 Flutter API 正常工作的 Flutter 工具包内部工作原理。由于 Flutter widget 是以积极组合的形式构建的，所以使用 Flutter 构建的用户界面含有大量 widget。为了支撑这些负载，Flutter 使用了次线性算法来布局和构建 widget，这些数据结构使树形结构优化更加高效，并且具有很多常量因子优化。通过一些额外的机制，该设计也允许开发者利用回调（用于构建用户可见的 widget）来轻松创建无限滚动列表。</p>
<h2> 积极可组合性</h2>
<p>组合性是 Flutter 最为出众的一个特性。widget 通过组合其他 widget 的方式进行构建，并且这些 widget 自身由更基础的 widget 构建。比如，<code>Padding</code> 是一个 widget 而非其他 widget 的属性。因此，使用 Flutter 创建的用户界面是由多个 widget 组成的。</p>
<p>widget 递归构建的底层是 RenderObjectwidget，它将在渲染树的底部创建子节点。渲染树是一种存储用户界面几何信息的数据结构，该几何信息在 <strong>布局</strong> 期间计算并在 <strong>绘制</strong> 及 <strong>命中测试</strong> 期间使用。大多数 Flutter 开发者无需直接创建这些对象，而是使用 widget 来操纵渲染树。</p>
<p>为了支持 widget 层的积极可组合性， Flutter 在 widget 和树渲染层使用了大量的高效算法和优化措施，这些将在下面小节中进行介绍。</p>
<h3> 次线性布局</h3>
<p>使用大量 widget 及渲染对象并保持高性能的关键是使用高效的算法。其中最重要的是确定渲染对象几何空间（比如大小和位置）的<strong>布局</strong>算法的性能。其他一些工具包使用 O(N²) 或更糟糕的布局算法（例如，约束域中的不动点迭代）。 Flutter 的目标在于布局初始化的线性性能，及一般情况下更新现有布局的<code>次线性布局性能</code>。通常情况下，布局所花费的时间应该比对象渲染要多得多。</p>
<p>Flutter 对每一帧执行一次布局操作，且布局算法仅在一次传递中完成。 <strong>约束</strong>信息通过父节点调用每个子节点的布局方法向下传递。子节点递归执行自身的布局操作，并在它们的布局方法中返回<strong>几何</strong>信息以便将其添加到渲染树中。需要注意的是，一旦渲染对象从布局中返回，该对象将不会被再次访问 <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">，直到下一帧布局的执行。该策略将可能存在的单独测量和布局传递合并为单次传递，因此，每个渲染对象在布局过程中<strong>最多</strong>被访问<strong>两次</strong> <sup class="footnote-ref"></sup></a><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2">：一次在树的向下传递过程中，一次在树的向上传递过程中。</a></p><a class="footnote-anchor" id="footnote-ref2">
</a><p><a class="footnote-anchor" id="footnote-ref2">针对这个通用协议，Flutter 拥有多种实现。最常用的是 <code>RenderBox</code>，它以二维的笛卡尔坐标进行运算。在盒子布局中，约束是最小及最大宽高。在布局过程中，子节点通过选择这些边界内的大小来确定其几何信息。子节点在布局中返回后，由父节点确定该子节点在父坐标系中的位置 <sup class="footnote-ref"></sup></a><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3">。注意，子节点的布局并不取决于它的位置，这是因为它的位置直到它从布局中返回后才确定。因此父节点可以在无需重新计算子节点布局的情况下重新定位子节点的位置信息。</a></p><a class="footnote-anchor" id="footnote-ref3">
<p>更广泛地讲，在布局期间，从父节点流向子节点的<strong>唯一</strong>信息是约束信息，从子节点流向父节点的<strong>唯一</strong>信息是几何信息。通过这些不变量可减少布局期间所需的工作量：</p>
<ul>
<li>如果父节点对子节点使用与上一次布局中相同的约束，且子节点没有将自己的布局标记为脏，那么该节点可立即从布局中返回，以切断布局的向下传递。</li>
<li>当父节点调用子节点的布局方法时，父节点会表明它是否使用从子节点返回的大小信息。如果父节点经常不使用此信息，即使子节点重新选择了大小，父节点依旧无需重新计算其布局，这是因为父节点需要保证新的大小符合现有约束。</li>
<li><strong>严格</strong>约束是指恰好由一个有效几何满足的约束。比如，如果最小最大宽度彼此相等，且最小最大高度彼此相等，那么满足这些约束的唯一大小便是具有该宽度及高度的大小。如果父节点提供了严格约束，即便父节点在布局中使用了子节点的大小，在子节点重新计算布局时，父节点的布局也无需重新计算，这是因为子节点在没有父节点新约束的情况下无法更改其大小。</li>
<li>渲染对象可以声明仅使用父节点提供的约束来确定其几何信息。此类声明通知框架： <strong>即便约束为非严格约束，以及父节点的布局取决于子节点的大小，</strong> 该渲染对象父节点的布局在子节点的布局重新计算时仍无需重新计算，这是因为子节点在没有父节点新约束的情况下无法更改其大小。</li>
</ul>
<p>这些优化措施的效果是，当渲染对象包含脏节点时，在布局过程中，只有这些节点以及它们周围子树的有限节点才允许被访问。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref3"></a> 次线性 widget 构建</h3>
<p>Flutter 使用类似于布局的次线性算法来构建 widget。widget 构建完成后，它们将被保留了用户页面逻辑结构的 <strong>element 树</strong> 保存。 Element 树是非常有必要的，这是因为 widget 自身是<strong>不可变的</strong>，这意味着（其他情况除外），它们无法记住父（或子）节点与其他 widget 的关系。 Element 还保存了与 Stateful widget 相关联的 <strong>state</strong> 对象。</p>
<p>由于用户输入（或来自其他地方的响应），比如开发者在关联的 state 对象上调用了 <code>setState()</code> 方法，element 可能会变脏。框架维护了一个脏 element 列表，使得 <strong>构建</strong> 过程可跳过干净的 element，直接跳转到脏的 element。构建过程中，信息在 element 树中向下 <strong>单向</strong> 传递，这意味着该阶段中每个 element 最多会被访问一次。一个 element 一旦被清洗，它将不会再次变脏，这是因为通过归纳，它所有的祖先 element 也都是干净的 <sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup><a class="footnote-anchor" id="footnote-ref4">。</a></p><a class="footnote-anchor" id="footnote-ref4">
<p>由于 widget 是<strong>不可变的</strong>，因此父节点使用相同的 widget 来重新构建 element，如果 element 没有将自己标记为脏，那么该 element 可立即从构建中返回，以切断构建的向下传递。另外，element 只需比较两个 widget 所引用的对象标识来确定新 widget 与旧 widget 是否相同。开发者可利用该优化实现<strong>投影</strong>模式，即 widget 包含了被存储为成员变量、在构建过程中预先构建的子 widget</p>
<p>构建过程中，Flutter 同时使用 <code>Inheritedwidgets</code> 来避免父链的遍历。如果 widget 经常遍历它们的父链，比如确定当前的主题颜色，那么构建阶段树的深底将变为 O(N²)，由于 Flutter 的积极可组合性，其数量可能非常巨大。为了避免这些父链的遍历，框架通过在每个 element 上维护一个 <code>Inheritedwidget</code> 哈希表来向下传递 element 树中的信息。通常情况下，多个 element 引用相同的哈希表，并且该表仅在 element 引入新的 <code>Inheritedwidget</code> 时改变。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref4"></a> 线性协调</h3>
<p>不同于传统做法，Flutter 没有使用树差异比较算法。相反，框架通过使用 O(N) 算法独立地检查每个 element 的子节点来决定是否重用该 element。子列表协调算法针对以下情况进行了优化：</p>
<ul>
<li>旧的子列表为空。</li>
<li>两个列表完全相同。</li>
<li>在列表的某个位置插入或删除一个或多个 widget。</li>
<li>如果新旧列表都包含相同 key <sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup><a class="footnote-anchor" id="footnote-ref5"> 的 widget，那么这两个 widget 就会被认为是相同的。</a></li><a class="footnote-anchor" id="footnote-ref5">
</a></ul><a class="footnote-anchor" id="footnote-ref5">
<p>通常的做法是从新旧子列表的头部和尾部开始对每一个 widget 的运行时类型和 key 进行匹配，这样就可能找到在两个列表中间所有不匹配子节点的（非空）范围。然后框架将旧子列表中该范围内的子项根据它的 key 放入一个哈希表中。接下来，框架将会遍历新的子列表以寻找该范围内能够匹配哈希表中的 key 的子项。无法匹配的子项将会被丢弃并从头开始重建，匹配到的子项则使用它们新的 widget 进行重建。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref5"></a> 树结构优化</h3>
<p>重用 element 对性能非常重要，这是因为 element 拥有两份关键数据：Stateful widget 的状态对象及底层的渲染对象。当框架能够重用 element 时，用户界面的逻辑状态信息是不变的，并且可以重用之前计算的布局信息，这通常可以避免遍历整棵子树。事实上，重用 element 是非常有价值的，因为 Flutter 支持 <strong>全局</strong> 树更新，以此保留状态和布局信息。</p>
<p>开发者可通过将 <code>GlobalKey</code> 与其中一个 widget 相关联来实施全局树更新。每个全局 key 在整个应用中都是唯一的，并使用特定于线程的哈希表进行注册。在构建过程中，开发者可以使用全局 key 将 widget 移动到 element 树的任意位置。框架将不会在该位置上重新构建 element，而是检查哈希表并将现有的 element 从之前的位置移动到新的位置，从而保留整棵子树。</p>
<p>重新构建的子树中的渲染对象能够保留它们的布局信息，这是因为布局约束是渲染树从父节点传递到子节点的唯一信息。子列表发生变化后，父节点将会被标记为脏，但如果新的父节点传递给子节点的布局约束与该子节点从旧的父节点接收到的相同，那么子节点可立即从布局中返回，从而切断布局的向下传递。</p>
<p>开发者广泛使用全局 key 和全局树更新来实现 hero transition 及导航等效果。</p>
<h3> 恒定因子优化</h3>
<p>除了上述算法优化，实现积极可组合还需依赖几个重要的恒定因子优化。这些优化对于上面所讨论的主要算法是非常重要的。</p>
<ul>
<li><strong>子模型无关</strong>。与大多数使用子列表的工具包不同， Flutter 渲染树不会记住一个特定的子模型。比如，类 <code>RenderBox</code> 存在一个抽象的 <code>visitChildren()</code> 方法，而非具体的 <strong>firstChild</strong> 和 <strong>nextSibling</strong> 接口。许多子类仅支持直接作为其成员变量的单个子项，而非子项列表。比如，由于 <code>RenderPadding</code> 仅支持单个子节点，因此它拥有一个更为简单、高效的布局方法。</li>
<li><strong>视觉渲染树、widget 逻辑树</strong>。在 Flutter 中，渲染树在与设备无关的视觉坐标系中运行，这意味着即使 x 轴的读取方向是从右到左，其左侧的值依旧小于右侧。Widget 树通常在逻辑坐标中运行，这意味着拥有 <strong>开始</strong> 和 <strong>结束</strong> 值的视觉解释取决于读取方向。逻辑坐标到视觉坐标的转换是在 widget 树和渲染树之间的切换中完成的。这种方法更为高效的原因是，渲染树中的布局和绘制计算比 widget 到渲染树的切换更加频繁，并且可以避免重复的坐标转换。</li>
<li><strong>通过专门的渲染对象处理文本</strong>。大多数渲染对象都不清楚文本的复杂性。相反，文本是由专门的渲染对象 <code>RenderParagraph</code> 进行处理，它是渲染树中的一个叶子节点。开发者使用组合形式将文本并入到用户界面中，而非使用文本感知渲染对象进行子类化。该模式意味着 <code>RenderParagraph</code> 可避免文本布局在父节点提供相同布局约束下的重复计算，这是非常常见的，即使在树优化期间也是如此。</li>
<li><strong>可观察对象</strong>。 Flutter 使用模型观察及响应设计模式。显而易见，响应模式占主导地位，但 Flutter 在某些叶子节点的数据结构上使用了可观察对象。比如 <code>Animation</code> 会在值发生变化时通知观察者列表。 Flutter 将这些可观察对象从 widget 树转移到渲染树中，渲染树直接监听这些对象，并在它们改变时仅重绘管道的相关阶段。比如，更改 <code>Animation&lt;Color&gt;</code> 可能只触发绘制阶段，而非整个构建和绘制阶段。</li>
</ul>
<p>总的来说，这些优化对通过积极组合方式产生的大型树结构的性能产生了重大影响。</p>
<h3> 元素和 RenderObject 树的分离</h3>
<p>Flutter 中的<code>RenderObject</code>和<code>Element</code>（Widget）树是同构的（严格来说，<code>RenderObject</code>树是<code>Element</code>树的一个子集）。一个明显的简化是将这些树合并成一棵树。然而，在实践中，将这些树分开是有很多好处的：</p>
<ul>
<li>
<p><strong>性能</strong> 当布局发生变化时，只有布局树的相关部分需要被行走。由于组成的原因，元素树经常有许多额外的节点需要被跳过。</p>
</li>
<li>
<p><strong>明确性</strong> 更清晰的关注点分离允许小部件协议和渲染对象协议各自针对其特定需求进行专业化，简化了 API 表面，从而降低了错误的风险和测试负担。</p>
</li>
<li>
<p><strong>类型安全</strong> 呈现对象树可以更具有类型安全性，因为它可以在运行时保证子代将具有适当的类型（每个坐标系，例如，有自己的呈现对象类型）。组成部件可以不考虑布局时使用的坐标系（例如，同一个部件暴露了应用程序模型的一部分，可以在盒子布局和狭长布局中使用），因此在元素树中，验证呈现对象的类型需要在树上行走。</p>
</li>
</ul>
<h2> 无限滚动</h2>
<p>对于工具包来说，实现无限滚动列表是非常困难的。Flutter 支持基于 <strong>构造器</strong> 模式实现的简单无限滚动列表界面，其中 <code>ListView</code> 使用回调按需构建 widget，即它们只在滚动过程中才对用户可见。该功能需要 <strong>视窗感知布局</strong> 及 <strong>按需构建 widget</strong> 的支持。</p>
<h3> 视窗感知布局</h3>
<p>同 Flutter 中的大多数东西一样，可滚动的 widget 是基于组合模式构建的。可滚动 widget 的外部是一个 <code>Viewport</code>，这是一个拥有更大内部空间的盒子，这意味着它的子节点可以超出视窗口的边界并滚动到可视区域中。但是，视窗口没有 <code>RenderBox</code> 子节点，而是拥有被称为 <strong>sliver</strong>，实现了视窗感知协议的<code>RenderSliver</code> 子节点。</p>
<p>sliver 布局协议中父节点向下传递给子节点的约束信息及接收到的几何信息的结构与盒子布局相同。但约束和几何数据在两个协议之间不同。在 sliver 协议中，子节点接收到的是关于视窗口的信息，这其中包含剩余的可见空间量。它们返回的几何数据支持各种滚动链接效果，包括可折叠标题及视差。</p>
<p>不同的 sliver 以不同的方式填充视窗口中的可用空间。比如，生成线性子列表的 sliver 按顺序排列每个子节点，直到 sliver 中无任何子节点或可用空间。同理，生成二维子节点网格的 sliver 仅填充网格中的可见区域。由于它们知道还有多大的可见空间，sliver 可以生成有限的子节点，即使它们可能生成无限的子节点。</p>
<p>可组合 sliver 来创建特定的滚动布局和效果。比如，单个视窗口可以有一个折叠标题、一个线性列表和一个网格。所有这些 sliver 将按照 sliver 布局协议进行协作，只生成那些在视窗口实际可见的子节点，而不管这些子节点是否属于标题、列表或网格<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup><a class="footnote-anchor" id="footnote-ref6">。</a></p><a class="footnote-anchor" id="footnote-ref6">
</a><h3><a class="footnote-anchor" id="footnote-ref6"></a> 按需构建 widget</h3>
<p>如果 Flutter 拥有一个严格的<strong>从构建到布局，再到绘制</strong>的管道，那么前面的内容将不足以实现无限滚动列表，这是因为只有在布局阶段才能通过视窗口获取可用的空间信息。如果没有额外的机制，在布局阶段构建用于填充空间的 widget 已经太迟了。 Flutter 使用将管道的构建与布局交叉在一起的方式来解决这个问题。在布局阶段的任意时刻，<strong>只要这些 widget 是当前布局的渲染对象的子节点</strong>，框架就可以按需构建新的 widget。</p>
<p>只有严格控制构建及布局中消息传播的算法，才能实现构建和布局的交叉执行。也就是说，在构建过程中，消息只能沿构建树向下传递。当渲染对象进行布局时，布局遍历过程中并没有访问该渲染对象的子树，这意味通过子树构建的写入无法使到目前为止已进入布局计算过程的任何信息失效。无独有偶，一旦布局从渲染对象中返回，在当前布局过程中，该渲染对象将永远不会被再次访问，这意味后续布局计算生成的任何写入都不会使用于构建渲染对象的子树的信息失效。</p>
<p>此外，线性协调及树结构优化对于在滚动过程中有效更新 element，以及当 element 在视窗口边缘滚动进出视图期间修改渲染树至关重要。</p>
<h2> 人机工程 API</h2>
<p>速度只有在框架能够被有效使用时才有意义。为了引导设计更高可用性的 Flutter API， Flutter 已经在与开发者进行的广泛用户体验研究中进行了反复测试。这些研究有时证实了已有的设计决策，有时有助于引导功能的优先级，有时会改变 API 的设计方向。比如，Flutter 的 API 文档很多，用户体验的研究不仅证实了这些文档的价值，也同时强调了示例代码及说明性图表的重要性。</p>
<p>本节将要讨论 Flutter API 设计中为提高可用性所做的一些决策。</p>
<h3> 与开发者思维模式相匹配的专项 API</h3>
<p>Flutter 中 <code>widget</code>、<code>Element</code> 和 <code>RenderObject</code> 的基类节点不定义子类模型。该机制允许每个节点对适用于该节点的子模型进行定制化。</p>
<p>大多数 <code>widget</code> 对象都有一个子 <code>widget</code> 对象，因此它只暴露了一个 <code>child</code> 参数。一些 widget 支持任意数量的子节点，并暴露了一个获取子节点列表的 <code>children</code> 参数。有些 widget 无任何子节点、不保留内存且无任何参数。同样的，<code>RenderObjects</code> 暴露特定于子模型的 API。 <code>RenderImage</code> 是一个没有子节点的叶子节点。 <code>RenderPadding</code> 只持有一个子节点，因此它有一个指向单个子节点的指针存储空间。 <code>RenderFlex</code> 接受任意数量的子节点，并通过链表对其进行管理。</p>
<p>在一些罕见情况下，将使用更复杂的子类模型。渲染对象 <code>RenderTable</code> 的构造函数需要使用二维数组来存储子节点，所以该类暴露了用于控制行和列数量的 getter 及 setter 方法，还有一些可以用 x、y 轴坐标来替换单个子节点的特殊方法，可通过提供一个新的子节点数组来添加新行，并用单个数组及列的个数来替换整个子节点列表。该对象并不像大多数渲染对象那样使用链表，而是使用可索引数组来实现。</p>
<p><code>Chip</code> widget 和 <code>InputDecoration</code> 对象具有与其控制中的插槽相匹配的字段。如果一个通用子模型将强制语义定义在子列表之上，比如将第一个子节点定义为前缀，第二个子节点定义为后缀，那么专用子模型允许使用特有的命名属性。</p>
<p>这种灵活性允许树中的每个子节点以其最常用的方式操作它的角色。很少有人想要在表格中插入一个单元格，从而导致其他所有单元格被环绕；同样的，很少有人想要通过索引而不是通过引用从 flex 行中删除子项。</p>
<p><code>RenderParagraph</code> 对象是最极端的情况：它有一个完全不同类型的子节点，<code>TextSpan</code>。在 <code>RenderParagraph</code> 的边界，<code>RenderObject</code> 树会被转换为 <code>TextSpan</code> 树。</p>
<p>专门用于满足开发者期望的 API 的一切方法不仅适用于子模型。</p>
<p>专门存在一些琐碎的 widget，以便开发者在寻找问题解决方案时能够发现并使用它们。一旦知道如何使用 <code>Expanded</code> 和大小为零的 <code>SizedBox</code> 子部件，就可以轻松地为行或列添加空格，但你会发现这种模式是没有必要的，因为搜索 <code>space</code> 所找到的 <code>Spacer</code>，它是直接使用 <code>Expanded</code> 和 <code>SizedBox</code> 来达到同样的效果的。</p>
<p>同理，可以通过在构建过程中不包含 widget 子树来轻松隐藏 widget 子树。但开发者通常希望有一个 widget 来执行该操作，因此 <code>Visibility</code> 的存在便是将此模式封装在一个简单的可重用 widget 中。</p>
<h3> 明确的参数</h3>
<p>UI 框架往往拥有大量的属性，因此很少有开发者能够记住每个类的每个构造函数参数的作用。由于 Flutter 使用响应式编程范式，因此在 Flutter 中，构建方法通常会对构造函数进行多次调用。通过利用 Dart 的命名参数，Flutter 中的 API 能够使这些构建方法保持清晰易懂。</p>
<p>该模式已被扩展到任何具有多个参数（尤其是具有 boolean 类型参数）的方法，因此独立的 <code>true</code> 或 <code>false</code> 值在方法调用中总是自我描述的。此外，为避免 API 中通常由双重否定所造成的困惑， boolean 类型的参数和属性始终以肯定的形式命名（比如，使用 <code>enabled: true</code> 而非 <code>disabled: false</code>）。</p>
<h3> 参数陷阱</h3>
<p>在 Flutter 框架中被大量使用的一项技术是定义不存在错误条件的 API。这样可以避免考虑整个错误类别。</p>
<p>比如插值函数允许插值的一端或两端为空，而不是将其定义为错误：两个空值之间的插值永远为空，并且从空值或空值插值等效于对指定类型进行零模拟插值。这意味着不小心将 null 传递给插值函数的开发者不会遇到错误，而是会得到一个合理结果。</p>
<p>一个更加微妙的例子是 <code>Flex</code> 布局算法。该布局给予 flex 渲染对象的空间被它的子节点所划分。因此 flex 的大小应该是整个可用空间。在最初的设计中提供无限空间将导致失败：这意味着 flex 应该是无限大且无用的布局设置。然而，通过对 API 的改造，在为 flex 对象提供无限空间时，渲染对象会调整自身大小来满足所需子节点的大小，从而减少可能出现的错误次数。</p>
<p>该方法也可用于避免使用允许创建不符合逻辑的数据的构造函数。例如，<code>PointerDownEvent</code> 的构造函数不允许将 <code>PointerEvent</code> 的 <code>down</code> 属性设置为 <code>false</code>（这种情况是自相矛盾的）；相反，构造函数没有关于字段 <code>down</code> 的参数，且将值始终设置为 <code>true</code>。</p>
<p>一般情况下，该方法用于为输入域中的所有值定义有效的解释。最简单的例子是 <code>Color</code> 的构造函数。相对于接受四个整型参数（分别用于表示红色、绿色、蓝色和 alpha），其中任何一个都可能超出范围，它的默认构造函数仅接受一个整数值，并定义每位的含义（例如，低八位代表红色），以便任何输入都是有效的颜色值。</p>
<p>一个更复杂的例子是 <code>paintImage()</code> 函数。该函数需要 11 个参数，其中一些具有相当宽泛的输入域，但它们都经过精心设计且大部分都能够彼此相交，因此很少出现无效组合。</p>
<h3> 积极报告错误</h3>
<p>并非所有的错误都能被设计出来。对于那些遗漏的错误，在 debug 版本中，Flutter 通常会尝试尽早捕获并立即报告。它使用了大量的断言，对构造函数参数进行了详细的完整性检查，并监视其生命周期，一旦检测到不一致，它们会立即引发异常。</p>
<p>这在某些情况下是极端情况：比如，在执行单元测试时，无论测试用例正在做什么，每个 <code>RenderBox</code> 子类都会主动地检查其内部大小调整方法是否满足内部大小调整契约。这有助于捕获可能无法执行的 API 错误。</p>
<p>当异常抛出时，它们会包含尽可能多的信息。 Flutter 中的一些错误会主动探测相关的堆栈跟踪信息，以确定实际错误最可能发生的位置。其他错误则通过相关树来确定坏数据的来源。最常见的错误包含详细说明（在某些情况下会包含避免错误的示例代码），或指向其他文档的链接。</p>
<h3> 响应式</h3>
<p>可变的基于树结构的 API 受二元访问模式的影响：创建树的原始状态通常使用与后续更新完全不同的操作集。Flutter 的渲染层使用了这种范式，因为它是维护持久树的有效方法，是高效布局和绘制的关键所在。但这也意味着，与渲染层的直接交互是十分笨拙的，甚至极其容易出错。</p>
<p>Flutter 在 widget 层引入了一个使用响应式来操作底层渲染树的组合机制<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup><a class="footnote-anchor" id="footnote-ref7">。该 API 通过将树的创建和更新步骤整合到一个单一的树结构描述（构建）中，从而将树操作抽象出来，这包括：每次系统状态更新之后，开发者用于描述用户界面的新配置；框架对于新配置所需要进行的一系列树更新计算。</a></p><a class="footnote-anchor" id="footnote-ref7">
</a><h3><a class="footnote-anchor" id="footnote-ref7"></a> 插值</h3>
<p>由于 Flutter 鼓励开发者描述与当前应用状态相匹配的界面配置，因此存在一种在这些配置之间执行隐式的动画机制。</p>
<p>例如，假设界面在状态 S1 由一个圆形组成，在状态 S2 时由一个正方形组成。如果没有动画机制，状态更改将导致不和谐的界面更改。隐式动画则允许界面在几个帧的时间里由圆形平滑地过渡到正方形。</p>
<p>每个可执行隐式动画的特性都包含一个 Stateful widget，它用于记录输入的当前值，并在输入值改变时开始执行动画序列，并在指定的持续时间内从当前值转换为新值。</p>
<p>这是使用不可变对象的 <code>lerp</code>（线性插值）函数来实现的。每个状态（这里为圆形和正方形）代表一个配置中包含恰当设置（比如颜色、笔划宽度等）且知道如何绘制自己的不可变对象。在动画绘制中间步骤时，开始和结束值连同表示动画中点的 <strong>t</strong> 值一并传递给 <code>lerp</code>函数。其中 0.0 代表开始 <code>start</code>，1.0 代表结束 <code>end</code><sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup><a class="footnote-anchor" id="footnote-ref8">，并且该方法返回表示中间阶段的第三个不可变对象。</a></p><a class="footnote-anchor" id="footnote-ref8">
<p>对于从圆形到正方形的转换，<code>lerp</code> 函数将返回一个圆角正方形对象，其半径被描述为从 <strong>t</strong> 值导出的分数，使用 <code>lerp</code> 函数进行插值计算的颜色，以及使用 <code>lerp</code> 函数进行双倍插值计算的笔划宽度。该对象与圆形、正方形一样具有相同的接口实现，并且可以在请求时进行自我绘制。</p>
<p>该技术允许状态机、状态到配置的映射、动画和插值机制以及与如何绘制每一桢完全分离的特定逻辑。</p>
<p>在 Flutter 中，该机制得到了广泛应用，无论是像 <code>Color</code> 和 <code>Shape</code> 这样的基本类型，还是像 <code>Decoration</code>，<code>TextStyle</code> 或 <code>Theme</code> 这样更为复杂的类型，都是可以进行插值处理的。它们通常是由可插入组件构成的，并且插入更复杂的对象通常就像递归插入描述复杂对象的所有值一样简单。</p>
<p>一些插值对象由类层次结构定义。比如，形状由 <code>ShapeBorder</code> 接口表示，并且存在多种形状类型，包括： <code>BeveledRectangleBorder</code>、<code>BoxBorder</code>、<code>CircleBorder</code>、<code>RoundedRectangleBorder</code> 和 <code>StadiumBorder</code>。单一的 <code>lerp</code> 函数并不能了解所有可能的类型信息，因此接口定义了 <code>lerpFrom</code> 和 <code>lerpTo</code> 方法以替代静态的 <code>lerp</code> 方法。当被告知从形状 A 切换到 B 时，将首选询问 B 是否 <code>lerpFrom</code> A，如其答案为否，则询问 A 是否可以 <code>lerpTo</code> B （如两者的答案均为否，如果 <code>t</code> 的值小于 0.5 则返回 A，否则返回 B）。</p>
<p>这允许类层次结构的任意扩展，后续新增的能够在先前已知值与它们之间进行插值处理。</p>
<p>在某些情况下，插值本身不能被任何可用的类描述，并且定义一个私有类来描述中间状态。比如在 <code>CircleBorder</code> 和 <code>RoundedRectangleBorder</code> 之间进行插值时就是如此。</p>
<p>该机制的另外一个优点是：它可以处理从中间态到新值的插值。比如，在圆形到正方形过渡的中途，形状可能再次改变，导致动画需要插值到一个三角形。只要该三角形类是 <code>lerpFrom</code> 圆形到正方形的中间类，就可以无缝进行转换。</p>
</a><h2><a class="footnote-anchor" id="footnote-ref8"></a> 结论</h2>
<p>Flutter 一切都是 widget 的口号是围绕着通过组合 widget 来构建用户界面， widget 又由更为基础的 widget 构成。这种积极组合的结果是需要精心设计的算法和数据结构才能有效处理大量的 widget。通过一些额外的机制，这些数据结构还能使开发者轻松构建无限滚动列表，以便在 widget 可见时进行按需构建。</p>
<hr>
<p><strong>脚注：</strong></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>至少对于布局来说。它可能会重新审视绘制、在必要时构建辅助功能树、以及必要时的命中测试。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>现实情况当然更复杂一些。有些布局涉及内部维度及基线测量，这涉及到相关子树的额外遍历 （在最坏的情况下，使用积极缓存来降低潜在的二次性能）。但是，这些情况非常罕见。特别是在常见的 shrink-wrapping 情况下，根本不需要内部尺寸。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p>严格来说，子节点的位置不是其 RenderBox 几何体的一部分，因此无需在布局期间进行实际计算。许多渲染对象隐式地将它们的单个子节点相对于它们自身的原点定位在 0,0 处，这根本不需要进行计算或存储。一些渲染对象避免计算它们子节点的位置直到最后可能需要的时刻（比如，在绘制过程中），以避免以后没有被绘制时的计算。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote4" class="footnote-item"><p>该规则有一个例外。正如 <a href="https://flutter.cn/docs/resources/inside-flutter#building-widgets-on-demand" target="_blank" rel="noopener noreferrer">按需构建 widget</a> 中所描述的，由于布局约束的变化，一些 widget 可以被重建。如果 widget 在同一帧中因与此无关的原因被标记为脏，同时也由于它受布局约束的影响，该 widget 将会被构建两次。该次冗余构建仅限于 widget 自身，并不会影响其后代节点。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote5" class="footnote-item"><p>键是一个可选的与 widget 相关联的不透明对象，它的相等操作符用于影响协调算法。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote6" class="footnote-item"><p>对于可访问性，并在 widget 构建及在窗口显示的过程中为应用提供几毫米的时间，视窗口会在可见 widget 的前后为几百个像素构建（但不进行绘制）widget。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote7" class="footnote-item"><p>该方法首次在 Facebook 的 React 框架中得到了广泛使用。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote8" class="footnote-item"><p>实际上，允许 <strong>t</strong> 值超过 0.0-1.0 的范围，这同样适用于某些曲线。比如 elastic 缓动曲线通过短暂的过冲来表示弹跳效应。插值逻辑通常可以在适当情况下推算出起始或结束点。对于某些类型，比如在插入颜色时，<strong>t</strong> 值被有效地固定到 0.0-1.0 的范围。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/4v/wallhaven-4vp2x3.png" type="image/png"/>
    </item>
    <item>
      <title>ReactNative介绍</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react1.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react1.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">ReactNative介绍</source>
      <description>前置知识点介绍</description>
      <category>前端跨平台</category>
      <pubDate>Sat, 24 Aug 2019 09:38:39 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>ReactNative 是 Facebook 开发的一套用于开发跨平台 App 的技术框架</p>
<p>相比传统开发方式解决了一些痛点：</p>
<p>1.难以复用</p>
<p>2.多平台多次开发</p>
<p>3.效率低下</p>
<p>效率带来的缺点也可想而知就是一些原生可以实现的复杂操作，RN 做不到</p>
</blockquote>
<h2> 前置知识</h2>
<p>React Native 看起来很像 React，只不过其基础组件是原生组件而非 web 组件。要理解 React Native 应用的基本结构，首先需要了解一些基本的 React 的概念，比如 JSX 语法、组件、<code>state</code>状态以及<code>props</code>属性。如果你已经了解了 React，那么还需要掌握一些 React Native 特有的知识，比如原生组件的使用。</p>
<h2> 语言选择</h2>
<p>typeScript 是<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener noreferrer">JavaScript</a>的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener noreferrer">面向对象编程</a>。</p>
<p>本次开发使用 typeScript 作为 ReactNative 的开发语言，对比 JavaScript 有一些优势</p>
<h4> 一、ts 的静态检查</h4>
<p>参考<a href="https://www.zhihu.com/question/64563945" target="_blank" rel="noopener noreferrer">为什么要使用 TypeScript？有哪些情景请简单介绍一下，或者来个例子?</a><br>
TS 对 JS 的改进主要是静态类型检查，静态类型检查有何意义？标准答案是“静态类型更有利于构建大型应用”。为什么静态类型有利于构建大型应用？我总结，利在两点。</p>
<p>其一，静态类型检查可以做到 early fail，即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，语言在编译阶段（解释执行也一样，可以在运行前）即可发现。针对大型应用，测试调试分支覆盖困难，很多代码并不一定能够在所有条件下执行到。而假如你的代码简单到任何改动都可以从 UI 体现出来，这确实跟大型应用搭不上关系，那么静态类型检查确实没什么作用。</p>
<p>配合 vscode 的<strong>TSLint</strong>插件可以很好的实现静态语法检查</p>
<h4> 二、 类型就是最好的注释。</h4>
<p>静态类型对阅读代码是友好的，针对大型应用，方法众多，调用关系复杂，不可能每个函数都有人编写细致的文档，所以静态类型就是非常重要的提示和约束。而假如你的代码像 jQuery 这样所有函数基本全是 API，根本没什么内部函数，而且逻辑关系看起来显而易见，这确实跟大型应用搭不上关系，那么静态类型对阅读代码确实也没什么帮助。总的来说，现代编程语言设计，很多特性已经有非常成熟的理论支持了，如果我们重视计算机基础，那么一些语言的适用场景就像是拼积木，可以用几句话概括。像是 TS 对 JS 这样，只是单一特性变化。</p>
<h4> PS:typeScript 本质上还是一个解释执行的脚本语言，和 JavaScript 一样没有编译过程</h4>
<p>同时也不是强类型语言，**是「静态类型检查」的「弱类型」**语言</p>
<p>真正的强类型语言有：java，swift，C#</p>
<h4> 三、 其他语法特性</h4>
<ol>
<li>
<p>TypeScript 工具使重构更变的容易、快捷。</p>
</li>
<li>
<p>TypeScript 引入了 JavaScript 中没有的“类”概念。</p>
</li>
<li>
<p>引入了 public，private，protected 访问控制符代替下划线私有</p>
</li>
<li>
<p>支持泛型和命名空间</p>
</li>
<li>
<p>TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p>
</li>
<li>
<p>支持接口的定义</p>
<p>……</p>
</li>
</ol>
<h2> JSX</h2>
<p><a href="https://facebook.github.io/jsx/" target="_blank" rel="noopener noreferrer">JSX</a>是一种嵌入式的类似 XML 的语法。 它可以被转换成合法的 JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX 因<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a>框架而流行，但也存在其它的实现。 TypeScript 支持内嵌，类型检查以及将 JSX 直接编译为 JavaScript。</p>
<p>想要使用 JSX 必须做两件事：</p>
<ol>
<li>给文件一个<code>.tsx</code>扩展名</li>
<li>启用<code>jsx</code>选项</li>
</ol>
<p>TypeScript 具有三种 JSX 模式：<code>preserve</code>，<code>react</code>和<code>react-native</code>。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在<code>preserve</code>模式下生成代码中会保留 JSX 以供后续的转换操作使用（比如：<a href="https://babeljs.io/" target="_blank" rel="noopener noreferrer">Babel</a>）。 另外，输出文件会带有<code>.jsx</code>扩展名。 <code>react</code>模式会生成<code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为<code>.js</code>。 <code>react-native</code>相当于<code>preserve</code>，它也保留了所有的 JSX，但是输出文件的扩展名是<code>.js</code>。</p>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>ReactNative开发环境配置，ES6语法介绍</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react2.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react2.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">ReactNative开发环境配置，ES6语法介绍</source>
      <description>ReactNative开发环境配置，ES6语法介绍</description>
      <category>前端跨平台</category>
      <pubDate>Sun, 25 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>接上篇 <a href="/posts/ReactNative/react1.html" target="_blank" rel="noopener noreferrer">ReactNative介绍</a></p>
</blockquote>
<h2> 创建 ReactNative 项目</h2>
<h4> 环境配置</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 配置 rn-cli.config.js</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Create our new project</h4>
<p><code>react-native init AwesomeProject</code></p>
<p><code>cd AwesomeProject react-native run-ios</code></p>
<h4> 项目结构图</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>tsconfig.json</code> 包含我们项目的 TypeScript 特定选项。</li>
<li><code>package.json</code> 包含我们的依赖项，以及我们想要运行的命令的一些快捷方式，用于测试，预览和部署我们的应用程序。</li>
<li><code>public</code>包含静态资产，例如我们计划部署到的 HTML 页面或图像。您可以删除此文件夹中的任何文件<code>index.html</code>。</li>
<li><code>src</code>包含我们的 TypeScript 和 CSS 代码。<code>index.tsx</code>是我们文件的入口点，并且是强制性的。</li>
<li><code>images.d.ts</code>将告诉 TypeScript 可以使用某些类型的图像文件<code>import</code>，create-react-app 支持这些文件。</li>
</ul>
<h4> 添加 TypeScript 配置文件</h4>
<p>我们想将 TypeScript 文件整合到一起 - 这包括我们写的源码和必要的声明文件。</p>
<p>我们需要创建一个<code>tsconfig.json</code>文件，它包含了输入文件列表以及编译选项。 在工程根目录下新建文件<code>tsconfig.json</code>文件，添加以下内容：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以在<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener noreferrer">这里</a>了解更多关于<code>tsconfig.json</code>文件的说明。</p>
<h4> 运行</h4>
<p><code>npm run start</code></p>
<p><code>npm run test</code></p>
<h2> 组件</h2>
<p>示例代码</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例中的这一行<code>&lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt;</code>恐怕很多人看起来也觉得陌生。这叫做 JSX——是一种在 JavaScript 中嵌入 XML 结构的语法。很多传统的应用框架会设计自有的模板语法，让你在结构标记中嵌入代码。React 反其道而行之，设计的 JSX 语法却是让你在代码中嵌入结构标记。初看起来，这种写法很像 web 上的 HTML，只不过使用的并不是 web 上常见的标签如<code>&lt;div&gt;</code>或是<code>&lt;span&gt;</code>等，这里我们使用的是 React Native 的组件。上面的示例代码中，使用的是内置的<code>&lt;Text&gt;</code>组件，它专门用来显示文本，而<code>&lt;View&gt;</code>就类似 html 中的<code>div</code>或是<code>span</code>这样的容器。</p>
<p>上面的代码定义了一个名为<code>HelloWorldApp</code>的新的<code>组件（Component）</code>。你在编写 React Native 应用时，肯定会写出很多新的组件。而一个 App 的最终界面，其实也就是各式各样的组件的组合。组件本身结构可以非常简单——唯一必须的就是在<code>render</code>方法中返回一些用于渲染结构的 JSX 语句。</p>
<h2> Props（属性）</h2>
<p>大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为<code>props</code>（属性）。</p>
<p>以常见的基础组件<code>Image</code>为例，在创建一个图片时，可以传入一个名为<code>source</code>的 prop 来指定要显示的图片的地址，以及使用名为<code>style</code>的 prop 来控制其尺寸。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意<code>{pic}</code>外围有一层括号，我们需要用括号来把<code>pic</code>这个变量嵌入到 JSX 语句中。括号的意思是括号内部为一个 js 变量或表达式，需要执行后取值。因此我们可以把任意合法的 JavaScript 表达式通过括号嵌入到 JSX 语句中。</p>
<p>使用的时候像这样<code>this.props</code>，请注意一点，在自定义组件内部，由外部传入的 props 的属性均为**readonly（只读）**不可在组件内部修改</p>
<h2> ES6 props 使用解构赋值</h2>
<p>组件内部赋值是这样的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而使用解构赋值之后是这样的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> ES6 延展操作符（...）</h2>
<h4> 该运算符主要用于函数调用</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 对象的扩展运算</h4>
<ul>
<li><strong>拷贝对象</strong></li>
</ul>
<p>对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>合并对象</strong></li>
</ul>
<p>扩展运算符可以用于合并两个对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 用于 props，要求参数名一致，此处用法其实是对 copy 对象的一种应用</h4>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/ae0a9ec1f8d6?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener noreferrer">ES6 延展操作符（...）</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>ReactNative State(状态)</title>
      <link>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react3.html</link>
      <guid>https://oragekk.me/Zzh/posts/cross-platform/ReactNative/react3.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">ReactNative State(状态)</source>
      <description>ReactNative State(状态)</description>
      <category>前端跨平台</category>
      <pubDate>Tue, 12 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>接上篇 <a href="/posts/ReactNative/react2.html" target="_blank" rel="noopener noreferrer">ReactNative开发环境配置，ES6语法介绍</a></p>
</blockquote>
<h2> ReactNative State(状态)</h2>
<h3> 概念</h3>
<p>通俗来讲，一个组件，或者一个视图，他们都是 Component，Component 用两个最重要的东西，一个<code>props</code></p>
<p>一个<code>state</code></p>
<p>我们使用两种数据来控制一个组件：<code>props</code>和<code>state</code>。<code>props</code>是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。(<code>props</code>就像一个类的初始化属性一样，只有在创建时可以赋值，并且组件内部不可修改，也就是<code>readonly</code>)</p>
<p>对于需要改变的数据，我们需要使用<code>state</code>。也可以把<code>state</code>理解为一个状态机，对于那些需要改变的数据可以使用<code>state</code>来更改，比如网络接口拿回来的数据，可以放在<code>state</code>里，当需要改变的时候只需要调用<code>setState</code>即可</p>
<h3> 使用</h3>
<p>一般来说，你需要在 class 中声明一个<code>state</code>对象，然后在需要修改时调用<code>setState</code>方法。</p>
<p>假如我们有一个弹窗，想要控制弹窗是不是显示，需要一个<code>modalVisible</code>属性，当更改它的值时从而使界面 UI 产生相应的变化</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一种声明方式，声明在类内部，声明的同时，进行初始化</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>this.state.modalVisible</code>来控制组件是否显示</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更新组件状态使用</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 注意点</h3>
<p>实际开发中，我们一般不会在定时器函数（setInterval、setTimeout 等）中来操作 state。典型的场景是在接收到服务器返回的新数据，或者在用户输入数据之后。你也可以使用一些“状态容器”比如<a href="http://redux.js.org/index.html" target="_blank" rel="noopener noreferrer">Redux</a>来统一管理数据流。</p>
<p>每次调用<code>setState</code>时，BlinkApp 都会重新执行 render 方法重新渲染。</p>
<ul>
<li>render（）中 UI 的变化只有当绑定的 state 中的某个属性变化后，才会变化</li>
<li>一切界面变化都是<code>状态state变化</code></li>
<li><code>state</code>的修改必须通过<code>setState()</code>方法
<ul>
<li>this.state.likes = 100; // 这样的<code>直接赋值修改无效！</code></li>
<li>setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性</li>
<li>setState 是<code>异步</code>操作，修改<code>不会马上生效</code></li>
</ul>
</li>
</ul>
<p>我们可以看到<code>setState</code>内部的声明</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要同步使用，我们可以使用第二个参数 callback?它是可选的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/ae0a9ec1f8d6?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener noreferrer">ES6 延展操作符（...）</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器的事件循环</title>
      <link>https://oragekk.me/Zzh/posts/Web/Browser/event-loop.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/Browser/event-loop.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">浏览器的事件循环</source>
      <description>浏览器的进程模型 何为进程？ 程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</description>
      <category>浏览器</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 浏览器的进程模型</h2>
<h3> 何为进程？</h3>
<p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>
<!-- more -->
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/9e81b88e42fe104f.png" alt="何为进程" tabindex="0" loading="lazy"><figcaption>何为进程</figcaption></figure>
<p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>
<h3> 何为线程？</h3>
<p>有了进程后，就可以运行程序的代码了。</p>
<p>运行代码的「人」称之为「线程」。</p>
<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>
<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/5badc062636572ac.png" alt="何为线程" tabindex="0" loading="lazy"><figcaption>何为线程</figcaption></figure>
<h3> 浏览器有哪些进程和线程？</h3>
<p><strong>浏览器是一个多进程多线程的应用程序</strong></p>
<p>浏览器内部工作极其复杂。</p>
<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/8a913a1d57ab9ad1.png" alt="浏览器有哪些进程和线程" tabindex="0" loading="lazy"><figcaption>浏览器有哪些进程和线程</figcaption></figure>
<blockquote>
<p>可以在浏览器的任务管理器中查看当前的所有进程</p>
</blockquote>
<p>其中，最主要的进程有：</p>
<ol>
<li>
<p>浏览器进程</p>
<p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
</li>
<li>
<p>网络进程</p>
<p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>
</li>
<li>
<p><strong>渲染进程</strong>（本节课重点讲解的进程）</p>
<p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>
<blockquote>
<p>将来该默认模式可能会有所改变，有兴趣的同学可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability" target="_blank" rel="noopener noreferrer">chrome官方说明文档</a></p>
</blockquote>
</li>
</ol>
<h2> 渲染主线程是如何工作的？</h2>
<p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li>解析 HTML</li>
<li>解析 CSS</li>
<li>计算样式</li>
<li>布局</li>
<li>处理图层</li>
<li>每秒把页面画 60 次</li>
<li>执行全局 JS 代码</li>
<li>执行事件处理函数</li>
<li>执行计时器的回调函数</li>
<li>......</li>
</ul>
<blockquote>
<p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>
</blockquote>
<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>
<p>比如：</p>
<ul>
<li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li>
<li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li>
<li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li>
<li>......</li>
</ul>
<p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/3be6637939475013.png" alt="排队" tabindex="0" loading="lazy"><figcaption>排队</figcaption></figure>
<ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li>
<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>
<p><strong>整个过程，被称之为事件循环（消息循环）</strong></p>
<h2> 若干解释</h2>
<h3> 何为异步？</h3>
<p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>
<ul>
<li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li>
<li>网络通信完成后需要执行的任务 -- <code>XHR</code>、<code>Fetch</code></li>
<li>用户操作后需要执行的任务 -- <code>addEventListener</code></li>
</ul>
<p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/aa0ac442c15daaf3.png" alt="image-20220810104344296" tabindex="0" loading="lazy"><figcaption>image-20220810104344296</figcaption></figure>
<p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p>
<p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/4f53367a24118e95.png" alt="异步" tabindex="0" loading="lazy"><figcaption>异步</figcaption></figure>
<p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p>
<blockquote>
<p>面试题：如何理解 JS 的异步？</p>
<p>参考答案：</p>
<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>
<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>
<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>
<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
</blockquote>
<h3> JS为何会阻碍渲染？</h3>
<p>先看代码</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>点击按钮后，会发生什么呢？</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>三秒之后h1文字变更，主线程被阻塞</p>
</div>
<h3> 任务有优先级吗？</h3>
<p>任务没有优先级，在消息队列中先进先出</p>
<p>但<strong>消息队列是有优先级的</strong></p>
<p>根据 W3C 的最新解释:</p>
<ul>
<li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>
在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>
<li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br>
<a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener noreferrer">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li>
</ul>
<blockquote>
<p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>
</blockquote>
<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>
<ul>
<li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li>
<li>微队列：用户存放需要最快执行的任务，优先级「最高」</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>
<p>例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></div>
<blockquote>
<p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>
</blockquote>
<blockquote>
<p>面试题：阐述一下 JS 的事件循环</p>
<p>参考答案：</p>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，<mark>微队列的任务一定具有最高的优先级，必须优先调度执行</mark>。</p>
</blockquote>
<blockquote>
<p>面试题：JS 中的计时器能做到精确计时吗？为什么？</p>
<p>参考答案：</p>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
</blockquote>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/04/11/9e81b88e42fe104f.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 属性计算过程</title>
      <link>https://oragekk.me/Zzh/posts/Web/CSS/calculation.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/CSS/calculation.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">CSS 属性计算过程</source>
      <description>CSS 属性计算过程 你是否了解 CSS 的属性计算过程呢？ 有的同学可能会讲，CSS属性我倒是知道，例如： p{ color : red; }</description>
      <category>CSS</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> CSS 属性计算过程</h1>
<p>你是否了解 CSS 的属性计算过程呢？</p>
<p>有的同学可能会讲，CSS属性我倒是知道，例如：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS 属性。</p>
<p>但是要说 CSS 属性的计算过程，还真的不是很清楚。</p>
<p>没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;">
<p>首先，不知道你有没有考虑过这样的一个问题，假设在 HTML 中有这么一段代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060724.png" alt="image-20220813140724136" style="zoom:50%;">
<p>目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。</p>
<p>那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014216.png" alt="image-20220815094215982" style="zoom:30%;">
<p>答案是**该元素上面会有 CSS 所有的属性。**你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png" alt="image-20220813141516153" tabindex="0" loading="lazy"><figcaption>image-20220813141516153</figcaption></figure>
<p>换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，<strong>大概率可能</strong>会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。</p>
<p>但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014459.png" alt="image-20220815094458940" style="zoom:25%;">
<p>嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。</p>
<p>总的来讲，属性值的计算过程，分为如下这么 <em>4</em> 个步骤：</p>
<ul>
<li>确定声明值</li>
<li>层叠冲突</li>
<li>使用继承</li>
<li>使用默认值</li>
</ul>
<h2> 确定声明值</h2>
<p>首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们声明了 p 元素为红色，那么就会应用此属性设置。</p>
<p>当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-063500.png" alt="image-20220813143500066" tabindex="0" loading="lazy"><figcaption>image-20220813143500066</figcaption></figure>
<p>在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。</p>
<p>这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。</p>
<h2> 层叠冲突</h2>
<p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p>
<p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p>
<ul>
<li>比较源的重要性</li>
<li>比较优先级</li>
<li>比较次序</li>
</ul>
<p>来来来，我们一步一步来看。</p>
<h3> 比较源的重要性</h3>
<p>当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。</p>
<p>那么问题来了，咱们的样式表的源究竟有几种呢？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-100047.png" alt="image-20220823180047075" style="zoom:40%;">
<p>整体来讲有三种来源：</p>
<ul>
<li>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</li>
<li>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</li>
<li>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</li>
</ul>
<p>对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式</p>
<p>更详细的来源重要性比较，可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade</a></em></p>
<p>我们来看一个示例。</p>
<p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-064222.png" alt="image-20220813144222152" tabindex="0" loading="lazy"><figcaption>image-20220813144222152</figcaption></figure>
<p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p>
<h3> 比较优先级</h3>
<p>那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。</p>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，同属于<strong>页面作者样式</strong>，源的重要性是相同的，此时会以选择器的权重来比较重要性。</p>
<p>很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em>。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-071546.png" alt="image-20210916151546500" style="zoom: 40%;">
<p>可以看到，落败的作者样式在 <em>Elements&gt;Styles</em> 中会被划掉。</p>
<p>有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：<em><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</a></em></p>
<h3> 比较次序</h3>
<p>经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。</p>
<p>此时就会进入第三个步骤，比较样式声明的次序。</p>
<p>举个例子：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，同样都是<strong>页面作者样式</strong>，<strong>选择器的权重也相同</strong>，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 <em>20px</em> 这一条属性值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-103928.png" alt="image-20220823183928330" tabindex="0" loading="lazy"><figcaption>image-20220823183928330</figcaption></figure>
<p>至此，样式声明中存在冲突的所有情况，就全部被解决了。</p>
<h2> 使用继承</h2>
<p>层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。</p>
<p>那么如果没有声明的属性呢？此时就使用默认值么？</p>
<p><em>No、No、No</em>，别急，此时还有第三个步骤，那就是使用继承而来的值。</p>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065102.png" alt="image-20220813145102293" tabindex="0" loading="lazy"><figcaption>image-20220813145102293</figcaption></figure>
<p>这里有两个点需要同学们注意一下。</p>
<p>首先第一个是我强调了是<strong>最近的</strong> div 元素，看下面的例子：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065653.png" alt="image-20220813145652726" tabindex="0" loading="lazy"><figcaption>image-20220813145652726</figcaption></figure>
<p>因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是<strong>谁近就听谁</strong>的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。</p>
<p>第二个就是哪些属性能够继承？</p>
<p>关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070148.png" alt="image-20220813150147885" tabindex="0" loading="lazy"><figcaption>image-20220813150147885</figcaption></figure>
<h2> 使用默认值</h2>
<p>好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。</p>
<p>如下图所示：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070825.png" alt="image-20220813150824752" tabindex="0" loading="lazy"><figcaption>image-20220813150824752</figcaption></figure>
<p>前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。</p>
<p>好了，这就是关于 CSS 属性计算过程的所有知识了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;">
<h2> 一道面试题</h2>
<p>好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。</p>
<p>下面的代码，最终渲染出来的效果，a 元素是什么颜色？p 元素又是什么颜色？</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大家能说出为什么会呈现这样的结果么？</p>
<p>解答如下：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-071941.png" alt="image-20220813151941113" tabindex="0" loading="lazy"><figcaption>image-20220813151941113</figcaption></figure>
<p>实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color 属性对应的值，因此会应用此声明值。而在 p 元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于 color 属性是可以继承的，因此最终 p 元素的 color 属性值通过继承来自于父元素。</p>
<p>你答对了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content:encoded>
      <enclosure url="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png" type="image/png"/>
    </item>
    <item>
      <title>你不知道的 CSS 之包含块</title>
      <link>https://oragekk.me/Zzh/posts/Web/CSS/containing-block.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/CSS/containing-block.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">你不知道的 CSS 之包含块</source>
      <description>你不知道的 CSS 之包含块 一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。 但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。 好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</description>
      <category>CSS</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 你不知道的 CSS 之包含块</h1>
<p>一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p>
<p>但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png" alt="image-20220814222004395" style="zoom: 20%;">
<p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;">
<p>包含块英语全称为<strong>containing block</strong>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p>
<p><em><a href="https://drafts.csswg.org/css2/#containing-block-details" target="_blank" rel="noopener noreferrer">https://drafts.csswg.org/css2/#containing-block-details</a></em></p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png" alt="image-20220814222458695" style="zoom:50%;">
<p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p>
<p>那么，这个包含块究竟说了什么内容呢？</p>
<p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p>
<p>来吧，少年，让我们从最简单的 case 开始看。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png" alt="image-20220814223152726" style="zoom: 50%;">
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom: 33%;">
<p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p>
<p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p>
<p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p>
<p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p>
<p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p>
<p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li>
<li>如果 position 属性是 fixed，那么包含块由视口建立。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p>
<p>公布正确答案：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom: 33%;">
<p>怎么样？有没有和你所想象的对上？</p>
<p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p>
<p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p>
<p>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p>
<ul>
<li>transform 或 perspective 的值不是 none</li>
<li>will-change 的值是 transform 或 perspective</li>
<li>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效).</li>
<li>contain 的值是 paint (例如: contain: paint;)</li>
</ul>
<p>我们还是来看一个示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;">
<p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p>
<p>好了，到这里，关于包含块的知识就基本讲完了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;">
<p>我们再把 CSS 规范中所举的例子来看一下。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？</p>
<p>对应的结果如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>body</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody>
</table>
<p>首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。</p>
<p>不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的**块容器（block container）**的内容区域（content area）的边缘建立。</li>
</ul>
<p>没错，因为 em1 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 p2。</p>
<p>接下来添加如下的 CSS：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p>
<p>答案如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody>
</table>
<p>可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p>
<ul>
<li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。</p>
<p>接下来我们继续修改我们的 CSS：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？</p>
<p>没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。</p>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td>
</tr>
<tr>
<td>strong1</td>
<td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td>
</tr>
</tbody>
</table>
<p>好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" alt="image-20220815093518833" style="zoom:33%;">
<p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p>
<p>具体你可以移步到：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a></em></p>
<p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content:encoded>
    </item>
    <item>
      <title>CommonJS，RequireJS，SeaJS 归纳笔记</title>
      <link>https://oragekk.me/Zzh/posts/Web/JavaScript/js-module-loader.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/JavaScript/js-module-loader.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">CommonJS，RequireJS，SeaJS 归纳笔记</source>
      <description>Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog</description>
      <category>JavaScript</category>
      <pubDate>Mon, 25 May 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Foreword</h2>
<blockquote>
<p>Here comes Module!</p>
</blockquote>
<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>
<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>
<hr>
<h2> Catalog</h2>
<ul>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#catalog">Catalog</a></li>
<li><a href="#commonjs--node">CommonJS &amp; Node</a></li>
<li><a href="#history">History</a></li>
<li><a href="#requirejs--amd">RequireJS &amp; AMD</a>
<ul>
<li><a href="#1-%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA">1. <strong>执行时机</strong></a></li>
<li><a href="#2-%E4%B9%A6%E5%86%99%E9%A3%8E%E6%A0%BC">2. <strong>书写风格</strong></a></li>
</ul>
</li>
<li><a href="#seajs--cmd">SeaJS &amp; CMD</a></li>
<li><a href="#amd-vs-cmd">AMD vs CMD</a></li>
<li><a href="#webpack">WebPack</a></li>
</ul>
<h2> CommonJS &amp; Node</h2>
<blockquote>
<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>
</blockquote>
<p>前端模块化的事实标准之一，2009 年 8 月，<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="noopener noreferrer">CommonJS</a> 诞生。</p>
<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>
<p>让我们看看 Node 中的实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>
<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>
<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>
<ul>
<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>
<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>
<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>
</ul>
<p>本文接下来要讨论的典例是：</p>
<ul>
<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>
<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>
</ul>
<h2> History</h2>
<!--<h2 id="history"> History </h2>-->
<blockquote>
<p>此段落参考自玉伯的 <a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener noreferrer">前端模块化开发那点历史</a></p>
</blockquote>
<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="noopener noreferrer">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>
<p>09 年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>
<ol>
<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href="http://wiki.commonjs.org/wiki/Modules/Transport" target="_blank" rel="noopener noreferrer">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>
<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noopener noreferrer">AMD</a> 规范及其实现 <a href="http://requirejs.org/" target="_blank" rel="noopener noreferrer">RequireJS</a>。这个稍后再细说。</li>
<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（<a href="http://flyscript.org" target="_blank" rel="noopener noreferrer">flyscript.org</a>）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>
</ol>
<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>
<h2> RequireJS &amp; AMD</h2>
<p><a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noopener noreferrer">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<blockquote>
<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>
</blockquote>
<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>
</blockquote>
<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The AMD loader will parse out the <code>require('')</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>
<p>AMD 和 CommonJS 的核心争议如下：</p>
<h3> 1. <strong>执行时机</strong></h3>
<p>Modules/1.0:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>AMD: （使用 require 的语法糖时）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>
<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>
<h3> 2. <strong>书写风格</strong></h3>
<p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>
<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> SeaJS &amp; CMD</h2>
<p>CMD (Common Module Definition) 是 <a href="http://seajs.org/docs/" target="_blank" rel="noopener noreferrer">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>
<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>
<ul>
<li>CMD Specification
<ul>
<li><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener noreferrer">English (CMDJS-repo)</a></li>
<li><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener noreferrer">Chinese (SeaJS-repo)</a></li>
</ul>
</li>
</ul>
<p>CMD 主要有 define, factory, require, export 这么几个东西</p>
<ul>
<li>define <code>define(id?, deps?, factory)</code></li>
<li>factory <code>factory(require, exports, module)</code></li>
<li>require <code>require(id)</code></li>
<li>exports <code>Object</code></li>
</ul>
<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>
<ul>
<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>
<h2> AMD vs CMD</h2>
<p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>
<ol>
<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>
</ol>
<ul>
<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>
</ul>
<p>看代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> WebPack</h2>
<blockquote>
<p>working...</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript ES6</title>
      <link>https://oragekk.me/Zzh/posts/Web/JavaScript/js-version.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/JavaScript/js-version.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">JavaScript ES6</source>
      <description>JavaScript 有着很奇怪的命名史。 1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript （当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系） 歪果仁的笑话怎么一点都不好笑 译者注：wikipedia 的 JavaScript 词条 更详细的叙述了这段历史</description>
      <category>JavaScript</category>
      <pubDate>Tue, 22 Sep 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JavaScript 有着很奇怪的命名史。</p>
<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>
<p><small class="img-hint">歪果仁的笑话怎么一点都不好笑</small></p>
<blockquote>
<p>译者注：<a href="https://en.wikipedia.org/wiki/JavaScript#History" target="_blank" rel="noopener noreferrer">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>
</blockquote>
<p>1996 年，网景将 JavaScript 提交给 <a href="http://www.ecma-international.org/" target="_blank" rel="noopener noreferrer">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>
<blockquote>
<p>术语（译者注）：</p>
<ul>
<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>
<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>
</ul>
</blockquote>
<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>
<blockquote>
<p>译者注：<a href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29" target="_blank" rel="noopener noreferrer">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href="https://en.wikipedia.org/wiki/ActionScript" target="_blank" rel="noopener noreferrer">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>
</blockquote>
<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>
<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener noreferrer">decorators（装饰者）</a>，<a href="https://github.com/lukehoban/ecmascript-asyncawait" target="_blank" rel="noopener noreferrer">async-await（async-await 异步编程模型）</a> 和 <a href="https://github.com/jeffmo/es-class-properties" target="_blank" rel="noopener noreferrer">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href="https://babeljs.io/docs/usage/experimental/" target="_blank" rel="noopener noreferrer">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>
<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>
<ul>
<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>
<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>
<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>
<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener noreferrer">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>
<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>
<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>
</ul>
<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>
<h4> 一些资源</h4>
<ul>
<li>TC39 的 <a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener noreferrer">Github 仓库</a>上可以看到所有目前公开的提案</li>
<li>如果你还不熟悉 ES6，Babel 有一个<a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="noopener noreferrer">很不错的特性概览</a></li>
<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href="http://exploringjs.com/" target="_blank" rel="noopener noreferrer">Exploring ES6</a>和 Nicholas Zakas 的 <a href="https://leanpub.com/understandinges6" target="_blank" rel="noopener noreferrer">Understanding ECMAScript 6</a>。Axel 的博客 <a href="http://www.2ality.com/" target="_blank" rel="noopener noreferrer">2ality</a> 也是很不错的 ES6 资源</li>
</ul>
<p><small class="img-hint">来学 JavaScript 吧！</small></p>
<h4> 著作权声明</h4>
<p>本文译自 <a href="http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/" target="_blank" rel="noopener noreferrer">ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?</a><br>
译者 <a href="http://weibo.com/huxpro" target="_blank" rel="noopener noreferrer">黄玄</a>，首次发布于 <a href="http://huangxuan.me" target="_blank" rel="noopener noreferrer">Hux Blog</a>，转载请保留以上链接</p>
]]></content:encoded>
    </item>
    <item>
      <title>通过UserAgent判断设备</title>
      <link>https://oragekk.me/Zzh/posts/Web/JavaScript/judgment.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/JavaScript/judgment.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">通过UserAgent判断设备</source>
      <description>通过 js 判断 moblie 端和 pc 端进而加载不同的 css 或者 js 废话不多说，上代码 &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &amp;quot;ipad&amp;quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &amp;quot;iphone os&amp;quot;; var bIsMidp = sUserAgent.match(/midp/i) == &amp;quot;midp&amp;quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &amp;quot;rv:1.2.3.4&amp;quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &amp;quot;ucweb&amp;quot;; var bIsAndroid = sUserAgent.match(/android/i) == &amp;quot;android&amp;quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &amp;quot;windows ce&amp;quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &amp;quot;windows mobile&amp;quot;; // document.writeln(&amp;quot;您的浏览设备为：&amp;quot;); if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { // alert(&amp;quot;手机浏览！&amp;quot;); } else { // alert(&amp;quot;PC浏览！&amp;quot;); document.write(&amp;quot;&amp;lt;script type=&amp;apos;text/javascript&amp;apos; size=&amp;apos;150&amp;apos; alpha=&amp;apos;0.8&amp;apos; zIndex=&amp;apos;-10&amp;apos; src=&amp;apos;../js/dist/ribbon.js&amp;apos;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;); document.write(&amp;quot;&amp;lt;script type=&amp;apos;text/javascript&amp;apos; color=&amp;apos;0,188,212&amp;apos; opacity=&amp;apos;0.7&amp;apos; zIndex=&amp;apos;-2&amp;apos; count=&amp;apos;99&amp;apos; src=&amp;apos;http://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js&amp;apos;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;); 	} } browserRedirect(); &amp;lt;/script&amp;gt;</description>
      <category>JavaScript</category>
      <pubDate>Tue, 07 Feb 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>通过 js 判断 moblie 端和 pc 端进而加载不同的 css 或者 js</p>
</blockquote>
<h2> 废话不多说，上代码</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 需要注意的是字符转义和引号嵌套的问题</h3>
]]></content:encoded>
    </item>
    <item>
      <title>使用n命令管理node版本</title>
      <link>https://oragekk.me/Zzh/posts/Web/node/node-version.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/node/node-version.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">使用n命令管理node版本</source>
      <description>鉴于使用 ReactNative 时，会需要不同的 node 版本，提供一种版本切换方式 使用 n command 来进行 node 版本管理 概念 n Node version manager 提供了一个更简单的 CLI，用于在 Node 版本之间进行安装和切换。它仅在 Linux 或 Mac 操作系统上受到支持。 安装 如果你已经安装某个版本的 Node 和 npm ，则可以用 npm install -g n 来安装 n，就像安装其他 NPM 包一样。</description>
      <category>Linux</category>
      <pubDate>Fri, 03 Apr 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>鉴于使用 ReactNative 时，会需要不同的 node 版本，提供一种版本切换方式</p>
</blockquote>
<h2> 使用 n command 来进行 node 版本管理</h2>
<h3> 概念</h3>
<p>n Node version manager 提供了一个更简单的 CLI，用于在 Node 版本之间进行安装和切换。它仅在 Linux 或 Mac 操作系统上受到支持。</p>
<h3> 安装</h3>
<p>如果你已经安装某个版本的 Node 和 npm ，则可以用 npm install -g n 来安装 n，就像安装其他 NPM 包一样。</p>
<p>如果你还没有安装 Node 或 npm，可以用 GitHub 中的 bash 脚本安装 n。这是它的样子：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过从 GitHub 下载并运行 n-install 脚本来安装 n。n 默认安装了一个版本的 Node。</p>
<h3> 安装版本 10.17.0</h3>
<p>如果需要指定版本号，可以这样安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 安装最新版本</h3>
<p>安装最新版本使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 切换版本</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显示如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用上下方向键来选择版本，并回车。如果不想选择可以按<code>q</code>退出</p>
<h2> 直接使用 Node 二进制文件</h2>
<p>n 提供了直接调用特定 Node 二进制文件的功能，而无需显式切换到该版本的 Node。 NVM 则没有类似的功能。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，n use 命令所请求的 Node 版本需要由 n 安装。</p>
<p>在某些情况下，这个功能非常有用。例如，有一个构建服务器，用于构建需要不同 Node 版本的程序。可以用 n use 命令触发每个构建，并能够指定该程序所需的 Node 版本。</p>
<h2> 差异化</h2>
<p>NVM for Windows 和 n 有许多常见功能，也有一些独特的功能，这些功能会影响你使用每个工具的方式和位置。以下是一些主要差异的摘要：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>能力</strong></th>
<th style="text-align:center"><strong>NVM for Windows</strong></th>
<th style="text-align:center"><strong>n</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">安装</td>
<td style="text-align:center">Windows 安装程序或独立安装</td>
<td style="text-align:center">Bash 脚本或 npm 包</td>
</tr>
<tr>
<td style="text-align:center">操作系统支持</td>
<td style="text-align:center">Windows（适用于 Linux/Mac 的不同实现）</td>
<td style="text-align:center">仅限 Linux/Mac</td>
</tr>
<tr>
<td style="text-align:center">列出要安装的 Node 的可用版本？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">列出已安装的 Node 版本？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">在不同的 Node 版本之间安装和切换？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">直接访问 Node 二进制文件？</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">选择要安装的架构（x86，x64）？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
</tbody>
</table>
<p>如果你使用 Linux/Mac 那么我很推荐你使用 n，因为它安装方便，并且 API 简单。我还是用过 homebrew 安装两个办版本，使用<code>brew link --overwrite --force node</code>命令来更改版本，很不方便，并且容错率很低</p>
<p>或者你可以在 Windows 上选择 NVM for Windows，同时在 Linux 构建服务器上选择 n</p>
<p>无论怎样，这两种工具都能很好地满足能够动态切换 Node 版本的需求。</p>
<blockquote>
<p>就是这么简单了</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Vue常见优化手段</title>
      <link>https://oragekk.me/Zzh/posts/Web/Vue/optimization.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/Vue/optimization.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Vue常见优化手段</source>
      <description>相关信息 永远不要过早优化，优化也有相应的代价 开发时间变长 开发成本增加 代码难以阅读 增加维护成本 何时优化，因地制宜，是一门艺术，尽量把优化的思想带入写代码的过程中 本文章的优化手段基于vue2</description>
      <category>Vue</category>
      <pubDate>Wed, 17 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>永远不要过早优化，优化也有相应的代价</p>
<ul>
<li>开发时间变长</li>
<li>开发成本增加</li>
<li>代码难以阅读</li>
<li>增加维护成本</li>
</ul>
<p>何时优化，因地制宜，是一门艺术，尽量把优化的思想带入写代码的过程中</p>
</div>
<p>本文章的优化手段基于<code>vue2</code></p>
<!-- more -->
<h2> 服务端渲染 SSR or 预渲染</h2>
<p>客户端渲染：使用 JavaScript 框架进行页面渲染<br>
服务端渲染：服务端将HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。</p>
<p><strong>优点：</strong></p>
<p>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。对客户端渲染的页面来说，简直无能为力，因为返回的HTML是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面。<br>
用户将会更快速地看到完整渲染的页面</p>
<p><strong>缺点:</strong></p>
<p>为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况<br>
由于服务器增加了渲染HTML的需求，使得原本只需要输出静态资源文件的nodejs服务，新增了数据获取的IO和渲染HTML的CPU占用，<br>
服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>
<h3> 如何实现？</h3>
<p>想要在服务器端渲染，我们需要做什么呢？那就是同构我们的项目，Vue.js 是构建客户端应用程序的框架，服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>
<p>当运行在不同环境中时，我们的代码将不会完全相同，同构就是让一份代码，既可以在服务端中执行，也可以在客户端中执行，并且执行的效果都是一样的，都是完成这个html的组装，正确的显示页面。<br>
对于同构应用来说，我们必须实现客户端与服务端的路由、模型组件、数据模型的共享。</p>
<h3> 服务器端渲染注意事项</h3>
<p>为避免造成交叉请求状态污染，每个请求应该都是全新的、独立的应用程序实例。<br>
由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用。<br>
通用代码不可接受像 window 或 document，这种仅浏览器可用的全局变量<br>
浏览器可能会更改的一些特殊的 HTML 结构，例如，浏览器会在</p>
<p>内部自动注入 ，然而，由于 Vue 生成的虚拟 DOM(virtual DOM) 不包含 ，所以会导致无法匹配。</p>
<h2> 使用key</h2>
<p>对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素</p>
<h2> 使用冻结的对象</h2>
<p>冻结的对象不会被响应化，如果对象很多，嵌套结构很深，遍历过程需要花费很多时间，如果对象不需要动态更改，可以使用冻结对象，如：商品列表等纯展示页面，并不会通过用户交互来更改</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>vue在处理过程中，如果发现对象是冻结对象，就不会去遍历对象，不会变成响应式</p>
<h4> 下面是1000000个对象的加载过程</h4>
<p><strong>vue</strong></p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/17/225d8b0bb0b07ab1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>冻结对象</strong></p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/17/3c863e0c03a3a382.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可见vue把对象深度遍历成为响应式，对于大量结构复杂的数据来说，是很耗时间的</p>
<h2> 使用函数式组件</h2>
<p>函数式组件，设置<code>functional:true</code>，函数式组件没有<code>data</code>，这以为它无状态（没有<mark>响应式数据</mark>）</p>
<p>，也没用实例（没有<code>this</code>上下文），所以组件树中不存在函数式组件，一个函数式组件就像这样</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 <code>props</code> 选项是必须的。在 2.3.0 或以上的版本中，你可以省略 <code>props</code> 选项，所有组件上的 attribute 都会被自动隐式解析为 prop。</p>
<p>当使用函数式组件时，该引用将会是 HTMLElement，因为他们是无状态的也是无实例的。</p>
</blockquote>
<p>在 2.5.0 及以上版本中，如果你使用了<a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener noreferrer">单文件组件</a>，那么基于模板的函数式组件可以这样声明：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>组件需要的一切都是通过 <code>context</code> 参数传递，它是一个包括如下字段的对象：</p>
<ul>
<li><code>props</code>：提供所有 prop 的对象</li>
<li><code>children</code>：VNode 子节点的数组</li>
<li><code>slots</code>：一个函数，返回了包含所有插槽的对象</li>
<li><code>scopedSlots</code>：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</li>
<li><code>data</code>：传递给组件的整个<a href="https://v2.cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener noreferrer">数据对象</a>，作为 <code>createElement</code> 的第二个参数传入组件</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 <code>data.on</code> 的一个别名。</li>
<li><code>injections</code>：(2.3.0+) 如果使用了 <a href="https://v2.cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener noreferrer"><code>inject</code></a> 选项，则该对象包含了应当被注入的 property。</li>
</ul>
<p>在添加 <code>functional: true</code> 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 <code>context</code> 参数，并将 <code>this.$slots.default</code> 更新为 <code>context.children</code>，然后将 <code>this.level</code> 更新为 <code>context.props.level</code>。</p>
<p>因为函数式组件只是函数，所以渲染开销(<strong>时间</strong>和<strong>内存</strong>)也低很多。</p>
<p>在作为包装组件时它们也同样非常有用。比如，当你需要做这些时：</p>
<ul>
<li>程序化地在多个组件中选择一个来代为渲染；</li>
<li>在将 <code>children</code>、<code>props</code>、<code>data</code> 传递给子组件之前操作它们。</li>
</ul>
<p>下面是一个 <code>smart-list</code> 组件的例子，它能根据传入 prop 的值来代为渲染更具体的组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用计算属性</h2>
<p>如果模版中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们</p>
<h2> 非实时绑定的表单项</h2>
<p>当使用<code>v-model</code>绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致vue发生重新渲染（<code>rerender</code>），这会带来一些性能的开销。</p>
<p>我们可以通过使用<code>lazy</code>或不使用<code>v-model</code>的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。</p>
<p>vue设计思想是关注的是数据而不是界面，代码的可维护性和可阅读性也很重要，js执行线程和浏览器渲染线程是互斥的，所以运行动画时执行jS线程动画会卡顿</p>
<p>如双向绑定的文本框输入的内容改变，输入abcd，会进行4次重新渲染，可以使用<code>v-model.lazy</code>,监听<code>@change</code>，不使用监听的是<code>@input</code></p>
<h2> 保持对象引用稳定</h2>
<p>在绝大部分情况下，<code>vue</code>出发<code>rerender</code>的时机是其依赖的数据发生<strong>变化</strong></p>
<p>若数据没有发生变化，哪怕给数据重新赋值了，<code>vue</code>也不会做出任何处理的</p>
<p>下面是vue判断数据<strong>没有变化</strong>的源码</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染</p>
<p>对于原始数据类型，保持其值不变即可</p>
<p>对于对象类型，保持其引用不变即可</p>
<h2> 使用v-show替代v-if</h2>
<p>对于频繁切换显示状态的元素，使用v-show可以保证虚拟的dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点及其重要</p>
<h2> 使用延迟装载defer</h2>
<p>首页白屏时间主要受到两个因素的影响：</p>
<ul>
<li>
<p>打包体积过大</p>
<p>巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个<code>&lt;div&gt;</code>，没有可显示的内容</p>
</li>
<li>
<p>需要立即渲染的内容太多</p>
</li>
</ul>
<p>JS传输完成后，浏览器开始执行JS构造页面</p>
<p>但可能一开始要渲染的组件太多，不仅JS的事件很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏loading过久</p>
<p>一个可行的办法就是延迟装载组件，让组件按照指定的先后顺序依次一个一个渲染出来</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>延迟装载是一个思路，本质上就是利用<code>requestAnimationFrame</code>事件分批渲染内容，它的具体实现多种多样</p>
</div>
<p>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">回调函数</a>更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<p><code>callback</code>： 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noopener noreferrer">DOMHighResTimeStamp</a>参数，该参数与<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noopener noreferrer">performance.now()</a>的返回值相同，它表示<code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p>
<p>思路：浏览器渲染1s渲染60次，第一次渲染一部分，第二次一部分，隔开渲染,分批绘制</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用keep-alive</h2>
<p>用于缓存内部组件实例，里面有include和exclude属性，max设置最大缓存数，超过后，自动删除最久没用的。</p>
<p>受到keep-alive影响，其内部的组件都具有两个生命周期，<code>activated</code>和<code>deactivated</code> ,分别再组件激活和失活时触发，第一次<code>activated</code>是在<code>mounted</code>之后。</p>
<p>一般用在需要多个页面频繁操作的场景（导航条）</p>
<h2> 长列表优化</h2>
<p>一般用在app端下拉的时候，或者列表很长的时候，通过一个固定大小的渲染池来解决。通过滚动条等一些操作，减少页面渲染市场，有现成的库，vue-virtual-scroller</p>
<p><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener noreferrer">https://github.com/Akryum/vue-virtual-scroller</a></p>
<p>通过v-once创建低开销的静态组件，渲染一次后就缓存起来了，除非你非常留意渲染速度，不然最好不要用，因为有的开发者不知道这个属性或者看漏了，然后花费好几个小时来找为什么模板无法正确更新。</p>
<h2> 打包体积优化</h2>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>静态资源的优化使用对象存储加CDN</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<h2> 基础优化</h2>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/57/wallhaven-577og5.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Vue2响应式原理解析</title>
      <link>https://oragekk.me/Zzh/posts/Web/Vue/vue2-principle.html</link>
      <guid>https://oragekk.me/Zzh/posts/Web/Vue/vue2-principle.html</guid>
      <source url="https://oragekk.me/Zzh/rss.xml">Vue2响应式原理解析</source>
      <description>前言 首先要知道vue2 是2013年 基于 ES5开发出来的，我们常说的重渲染就是重新运行render函数 vue2 的响应式原理是利⽤ES5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持结合发布订阅模式的⽅式来实现的。</description>
      <category>Vue</category>
      <pubDate>Tue, 16 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">前言</p>
<p>首先要知道vue2 是2013年 基于 ES5开发出来的，我们常说的重渲染就是重新运行<code>render</code>函数</p>
<p>vue2 的响应式原理是利⽤ES5 的⼀个 API ，<code>Object.defineProperty()</code>对数据进⾏劫持结合发布订阅模式的⽅式来实现的。</p>
</div>
<!-- more -->

<h2> 1. 思路</h2>
<p>带入作者的角度思考一下，想要达成响应式的特点应该是:<strong>属性更新，自动调用依赖<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">的函数</a></strong><a class="footnote-anchor" id="footnote-ref1">进行重新渲染</a></p><a class="footnote-anchor" id="footnote-ref1">
<ol>
<li>使用属性描述符<code>Object.defineProperty</code>监听属性的赋值</li>
<li>赋值完成后调用依赖该属性的函数，那如何获取依赖的函数呢？看第三点</li>
<li>由于依赖会调用属性的get方法，所以可以在get方法中<strong>收集依赖</strong></li>
<li>然后在set方法中执行这些依赖的函数，称为<strong>派发更新</strong></li>
</ol>
<p>基于以上思路的简单实现代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a><h2><a class="footnote-anchor" id="footnote-ref1"></a> 2. 原理</h2>
<p>vue2响应式原理简单来说就是vue官网上的这图片</p>
<figure><img src="https://v2.cn.vuejs.org/images/data.png" alt="原理图" tabindex="0" loading="lazy"><figcaption>原理图</figcaption></figure>
<p>通过 <code>Object.defineProperty</code> 遍历对象的每一个属性，把每一个属性变成一个 <code>getter</code> 和 <code>setter</code> 函数，读取属性的时候调用 <code>getter</code>，给属性赋值的时候就会调用 <code>setter</code>.</p>
<p>当运行 <code>render</code> 函数的时候,发现用到了响应式数据，这时候就会运行 <code>getter</code> 函数，然后 watcher（发布订阅）就会记录下来。当响应式数据发生变化的时候，就会调用 <code>setter</code> 函数，watcher 就会再记录下来这次的变化，然后通知 <code>render</code> 函数，数据发生了变化，然后就会重新运行 <code>render</code> 函数，重新生成虚拟 dom 树。</p>
<h2> 3. 深入了解</h2>
<p>我们要明白，响应式的最终目标：<strong>是当对象本身或对象属性发生变化时，会运行一些函数，最常见的就是 render 函数。不是只有 render，只要数据发生了变化后运行了一些函数，就是响应式,比如 watch。</strong></p>
<p>在具体实现上，vue 采用了几个核心部件:</p>
<ol>
<li>
<p><strong>Observer</strong></p>
</li>
<li>
<p><strong>Dep</strong></p>
</li>
<li>
<p><strong>Watcher</strong></p>
</li>
<li>
<p><strong>Scheduler</strong></p>
</li>
</ol>
<h2> 4. Observer</h2>
<p>observer 要实现的目标非常简单，就是把一个普通的对象转换成响应式的对象</p>
<p>为了实现这一点，observer 把对象的每个属性通过 <code>object.defineProperty</code> 转换为带有 <code>getter</code> 和 <code>setter</code> 的属性，这样一来，当访问或者设置属性时，vue 就会有机会做一些别的事情。</p>
<p><mark>在组件的生命周期中，这件事发生在 <code>beforeCreate</code> 之后，create 之前。</mark></p>
<p>具体实现上，他会递归遍历对象的所有属性，以完成深度的属性转换。</p>
<p>但是由于遍历只能遍历到对象的当前属性，无法监测到将来动态添加或者删除的属性，因此 vue 提供了<code>$set</code>和<code>$delete</code> 两个实例方法，但是 vue 并不提倡这样使用，我讲到 dep 的时候我再说为什么。</p>
<p>对于数组的话，vue 会更改它的隐式原型，之所以这样做是因为 vue 需要监听那些可能改变数组内容的方法。</p>
<p>数组 --&gt; vue 自定义的对象 --&gt; Array.prototype</p>
<p>总之，observer 的目标，就是要让一个对象，它属性的读取，赋值，内部数组的变化都要能够被 vue 感知到。</p>
<h3> 4.1. 手动转换响应式对象</h3>
<p>Vue提供了静态方法：<code>Vue.observable()</code> 手动将普通对象转为响应式对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2. data</h3>
<p>Vue不允许动态添加根级响应式属性，所以需要在组件实例化之前通过配置中的 <code>data</code> 字段，声明所有根级响应式属性，哪怕属性值为 <code>null</code>。由此带来的好处有：</p>
<ol>
<li>更易于维护： data对象就像组件的状态结构（schema）, 提前声明所有响应式属性，后期有助于开发者理解和修改组件逻辑。</li>
<li>消除了在依赖项跟踪系统中的一类边界情况。</li>
<li>使Vue实例能够更好的配合类型检查系统工作。</li>
</ol>
<h3> 4.3. 「动态添加或删除属性」</h3>
<p>由于Vue会在初始化实例时，对所有属性（配置里 <code>data</code> 中存在的属性）执行 getter/setter 的转化。</p>
<p>那么对于 <strong>「动态添加或删除」</strong> 的属性，Vue是无法自动检查其变化。</p>
<p>因此，Vue提供了以下方式来手动完成响应式数据。</p>
<ol>
<li>添加：<strong>「Vue.set(target, key, val)」</strong> 或 <strong>「this.$set(target, key, val)」</strong></li>
<li>删除：<strong>「Vue.delete(target, key)」</strong> 或 <strong>「this.$delete(target, key)」</strong></li>
<li>批量操作：<code>this.reactiveObj = Object.assign({}, this.reactiveObj, obj)</code></li>
</ol>
<p>举个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.4. <strong>「关于数组」</strong></h3>
<p>由于js的限制， Vue不能检测到以下数组变动：</p>
<ol>
<li>当利用索引直接改变数组项时， 例如：<code>vm.arr[idx] = newValue</code></li>
<li>当修改数组长度时 ，例如： <code>vm.arr.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了让上述数组操作具有响应式，采用以下方法处理：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了可以通过静态方法 <code>Vue.set()</code> 和 实例方法 <code>this.$set()</code> 响应式的修改数组项的值。还可以使用数组方法 - <code>splice()</code> 。</p>
<p>因为，Vue对一些可以改变数组自身内容的操作API，如：splice()、sort()、push()、pop()、reverse()、shift()、unshift() 等进行了拦截和重写。从而在开发者使用这些API时，可以触发响应式数据，进而更新视图。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. Dep</h2>
<p>这里有两个问题没解决，就是读取属性时要做什么事，属性变化时又要做什么事，这个问题就得需要 dep 来解决</p>
<p>dep 的含义是 dependency 表示依赖的意思。</p>
<p>vue 会为响应式对象中的每一个属性，对象本身，数组本身创建一个 dep 实例，每个 dep 实例都可以做两件事情：</p>
<p>1，记录依赖：是谁在用我</p>
<p>2，派发更新：我变了，我要通知那些用我的人</p>
<p>当读取响应式对象的某一个属性时，他会进行依赖收集，有人用到了我</p>
<p>当改变某个属性时，他会派发更新，那些用我的人听好了，我变了</p>
<p>为什么尽量不要使用<code>$set</code> <code>$delete</code> ?</p>
<p>因为如果模板上没有用到值的话，你凭空加了一个数据,理论上来说应该不会重新运行<code>render</code>函数，但是上一级的dep发现自身发生改变了，所以也会导致重新运行render函数。</p>
<p>所以vue不建议使用<code>$set</code> 和<code>$delete</code>,最好提前先写上数据,哪怕先给数据赋值为 null;</p>
<h2> 6. watcher</h2>
<p>这里又出现了一个问题，就是 dep 如何知道是谁在用我呢</p>
<p>watcher 就解决了这个问题</p>
<p>当函数执行的过程中，用到了响应式数据，响应式数据是无法知道是谁在用自己的</p>
<p>所以，我们不要直接执行函数，而是把函数交给一个 watcher 的东西去执行，watch 是一个对象，每个函数执行时都应该创建一个 watcher，通过 wacher 去执行</p>
<p>watcher 会创建一个全局变量，让全局变量记录当前负责执行的 watcher 等于自己，然后再去执行函数，在函数执行的过程中，如果发生了依赖记录，那么 dep 就会把这个全局变量记录下来，表示有一个 wathcer 用到了我这个属性。</p>
<p>当 dep 进行派发更行时，他会通知之前记录的所有 watcher，我变了。</p>
<h2> 7. Scheduler</h2>
<p>现在还剩下最后一个问题啊，就是 dep 通知 watcher 之后，如果 wathcer 执行重新运行对应的函数，就有可能导致频繁运行，从而导致效率低下，试想，如果一个交给 watcher 的函数，它里面用到了属性 a,b,c,d,那么 a,b,c,d 都会记录依赖，然后这四个值都以此重新赋值，那么就会触发四次更新，这样显然不行啊，所以当 watcher 收到派发更新的通知后，实际上并不是立即执行，而是通过一个叫做 nextTick 的工具方法，把这些需要执行的 watcher 放到事件循环的微队列，nextTick 是通过 Promise then 来完成的。</p>
<p>也就是说，在响应式数据发生变化时，render 函数执行是异步的，并且在微队列中。</p>
<h2> 8. <strong>异步更新队列</strong></h2>
<blockquote>
<p>Vue侦听到数据变化，就会开启一个队列。但是组件不会立即重新渲染，而是先会缓冲在同一个事件循环中的发生的所有数据变化。此时如果同一个watcher被多次触发，只会被推入到队列中一次，这样可以**「避免不必要的计算和DOM更操作」**。<br>
在下一个事件循环”tick“中， Vue刷新队列并执行实际（已去重的）工作（更新渲染）。<br>
为此，Vue提供了异步更新的监听接口 —— <code>Vue.nextTick(callback)</code> 或 <code>this.$nextTick(callback)</code> 。当数据发生改变，异步DOM更新完成后，callback回调将被调用。开发者可以在回调中，操作更新后的DOM。</p>
</blockquote>
<p><strong>「举例1」</strong></p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例，通过一个NextTick组件的渲染，了解下 的用法。为了方便查看组件渲染时，<code>render</code>函数被调用的过程，在组件定义时，直接给出<code>render</code>函数。当点击按钮后，会在数据修改前后，使用<code>nextTick</code>工具方法。分别写入两个读取界面Dom的函数。结果会发现，第一个 <code>$nextTick</code> 回调函数获取的数据为旧数据，第二个 <code>$nextTick</code>回调函数获取的数据为新数据。</p>
<p>分析一下：</p>
<p>按钮点击后，异步队列的添加步骤是：</p>
<ol>
<li>第一个 <code>$nextTick</code> ，会将自己的回调函数（fn1）加入到当前的异步队列中。</li>
<li>修改数据后， 经过派发更新，Scheduler会将包含了watcher队列执行逻辑的函数（fn2）加入到当前的异步队列中。</li>
<li>第二个 <code>$nextTick</code>， 已将自己的回调函数（fn3）加入到当前的异步队列中。</li>
</ol>
<p>当异步队列执行时，会依次执行 fn1 ， fn2，fn3。而当fn2执行后，界面才会更新最新数据，所以fn1，fn3获取的界面数据前者为旧数据，后者为新数据。</p>
<p><strong>「举例2」</strong></p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码，当设置 <code>this.a = 'world'</code> 后，访问DOM元素内容，但完成未更新。此时，立即使用 <code>this.$nextTick()</code> 监听DOM更新，并在监听回调调用时，获取更新后的DOM内容。</p>
<p>另外， <code>this.$nextTick()</code> 其内部尝试使用原生的 <code>Promise.then</code>、<code>MutationObserve</code>、<code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout</code> 替代。并且最终返回一个<code>Promise</code>对象，所以可以使用 <code>async/await</code> 语法替代 <code>callback</code>的写法。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9. 总流程图</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/16/6ebf6f55fe1cd59e.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>依赖：某个函数在运行期间用到这个属性的get方法 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/5w/wallhaven-5wmyo8.jpg" type="image/jpeg"/>
    </item>
  </channel>
</rss>
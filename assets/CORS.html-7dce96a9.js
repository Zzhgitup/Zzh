import{_ as o,r as t,o as i,c as p,a as s,b as n,d as a,e}from"./app-bebbc25d.js";const r={},c=s("h3",{id:"什么是跨域",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#什么是跨域","aria-hidden":"true"},"#"),n(" 什么是跨域")],-1),d=s("p",null,[n("浏览器有一个重要的安全策略，称之为[同源策略]"),s("br"),n(" 其中，源=协议+主机+端口源=协议+主机+端口源=协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域。")],-1),b=s("p",null,"比如：",-1),u=s("thead",null,[s("tr",null,[s("th",null,"源 1"),s("th",null,"源 2"),s("th",null,"是否同源")])],-1),y={href:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"},m={href:"http://www.baidu.com/news",target:"_blank",rel:"noopener noreferrer"},h=s("td",null,"是",-1),B={href:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.baidu.com",target:"_blank",rel:"noopener noreferrer"},_=s("td",null,"否",-1),f={href:"http://localhost:5000",target:"_blank",rel:"noopener noreferrer"},g={href:"http://localhost:7000",target:"_blank",rel:"noopener noreferrer"},A=s("td",null,"否",-1),C={href:"http://localhost:5000",target:"_blank",rel:"noopener noreferrer"},F={href:"http://127.0.0.1:5000",target:"_blank",rel:"noopener noreferrer"},x=s("td",null,"否",-1),w={href:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"},k={href:"http://baidu.com",target:"_blank",rel:"noopener noreferrer"},E=s("td",null,"否",-1),O=s("tr",null,[s("td",null,"同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制"),s("td"),s("td")],-1),q=s("tr",null,[s("td",null,[s("img",{src:"https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093517.jpg",alt:"",loading:"lazy"})]),s("td"),s("td")],-1),j=s("tr",null,[s("td",null,[n("同源策略对 ajax 的跨域限制的最为"),s("em",null,"凶狠"),n("，默认情况下，它不允许 ajax 访问跨域资源")]),s("td"),s("td")],-1),T=s("tr",null,[s("td",null,[s("img",{src:"https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093619.jpg",alt:"",loading:"lazy"})]),s("td"),s("td")],-1),S=s("tr",null,[s("td",null,"所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响"),s("td"),s("td")],-1),P=s("tr",null,[s("td",null,"有多种方式解决跨域问题，常见的有："),s("td"),s("td")],-1),R=e(`<ul><li>代理，常用</li><li>CORS，常用</li><li>JSONP<br> 无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</li></ul><h3 id="跨域解决办法-1-代理" tabindex="-1"><a class="header-anchor" href="#跨域解决办法-1-代理" aria-hidden="true">#</a> 跨域解决办法 1-代理</h3><p>对于前端开发而言，大部分的跨域问题，都是通过代理解决的</p><p>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</p><p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211093737.jpg" alt="" loading="lazy"></p><p>在实际开发中，只需要对开发服务器稍加配置即可完成</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// vue 的开发服务器代理配置</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// vue.config.js</span></span>
<span class="line"><span style="color:#E5C07B;">module</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">exports</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">devServer</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 配置开发服务器</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">proxy</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#7F848E;font-style:italic;">// 配置代理</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#98C379;">&quot;/api&quot;</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">// 若请求路径以 /api 开头</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">target</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;http://dev.taobao.com&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#7F848E;font-style:italic;">// 将其转发到 http://dev.taobao.com</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">    },</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解决跨域问题方法-2-jsonp" tabindex="-1"><a class="header-anchor" href="#解决跨域问题方法-2-jsonp" aria-hidden="true">#</a> 解决跨域问题方法 2-JSONP</h3><p>在 CORS 出现之前，人们想了一种奇妙的办法来实现跨域，这就是 JSONP。<br> 要实现 JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br> JSONP 的做法是：当需要跨域请求时，不使用 AJAX，转而生成一个 script 元素去请求服务器，由于浏览器并不阻止 script 元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段 JS 代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p><figure><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094003.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="跨域解决方法-3-cors" tabindex="-1"><a class="header-anchor" href="#跨域解决方法-3-cors" aria-hidden="true">#</a> 跨域解决方法 3-CORS</h3><p>CORS 是基于 http1.1 的一种跨域解决方案，它的全称是 Cross-Origin Resource Sharing，跨域资源共享。<br> 它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094034.jpg" alt="" loading="lazy"><br> 而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p><p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p><p>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p><ul><li>简单请求</li><li>需要预检的请求</li><li>附带身份凭证的请求<br> 这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br> 下面分别说明三种请求模式的具体规范。</li></ul><p><code>简单请求</code><br> 当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p><h3 id="简单请求的判定" tabindex="-1"><a class="header-anchor" href="#简单请求的判定" aria-hidden="true">#</a> 简单请求的判定</h3><p>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p><ol><li>求方法属于下面的一种：</li></ol><ul><li>get</li><li>post</li><li>head</li></ul><ol start="2"><li>请求头仅包含安全的字段，常见的安全字段如下：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>DownLink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul><ol start="3"><li>请求头如果包含 Content-Type，仅限下面的值之一：</li></ol><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded<br><code>如果以上三个条件同时满足，浏览器判定为简单请求。</code></li></ul><h3 id="简单请求的交互规范" tabindex="-1"><a class="header-anchor" href="#简单请求的交互规范" aria-hidden="true">#</a> 简单请求的交互规范</h3><p>当浏览器判定某个 ajax 跨域请求是简单请求时，会发生以下的事情</p>`,26),H=s("br",null,null,-1),N=s("code",null,"http://my.com/index.html",-1),M=s("br",null,null,-1),D={href:"http://crossdomain.com/api/news",target:"_blank",rel:"noopener noreferrer"},J=s("br",null,null,-1),L=e(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">GET</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">/</span><span style="color:#E06C75;">api</span><span style="color:#56B6C2;">/</span><span style="color:#E06C75;">news</span><span style="color:#56B6C2;">/</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">HTTP</span><span style="color:#56B6C2;">/</span><span style="color:#D19A66;">1.1</span></span>
<span class="line"><span style="color:#E06C75;">Host</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">crossdomain</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">com</span></span>
<span class="line"><span style="color:#E06C75;">Connection</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">keep</span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;">alive</span></span>
<span class="line"><span style="color:#ABB2BF;">...</span></span>
<span class="line"><span style="color:#E06C75;">Referer</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">http</span><span style="color:#ABB2BF;">:</span><span style="color:#7F848E;font-style:italic;">//my.com/index.html</span></span>
<span class="line"><span style="color:#E06C75;">Origin</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">http</span><span style="color:#ABB2BF;">:</span><span style="color:#7F848E;font-style:italic;">//my.com</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到最后一行没，Origin 字段会告诉服务器，是哪个源地址在跨域请求 2. 服务器响应头中应包含 Access-Control-Allow-Origin<br> 当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加 Access-Control-Allow-Origin 字段<br> 该字段的值可以是：</p>`,2),z=s("li",null,"*：表示我很开放，什么人我都允许访问",-1),I={href:"http://my.com",target:"_blank",rel:"noopener noreferrer"},V=e(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">实际上，这两个值对于客户端http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span>
<span class="line"><span style="color:#abb2bf;">当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span>
<span class="line"><span style="color:#abb2bf;">为了避免后续的麻烦，强烈推荐响应具体的源</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),G=s("br",null,null,-1),K=s("br",null,null,-1),W=s("br",null,null,-1),X=s("br",null,null,-1),Q={href:"http://my.com",target:"_blank",rel:"noopener noreferrer"},U=s("br",null,null,-1),Y=e(`<p>消息体中的数据<br><code>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作 下图简述了整个交互过程 ![](https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094943.jpg)</code>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。\`\`<br> 但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p><ul><li>浏览器发送预检请求，询问服务器是否允许</li><li>服务器允许</li><li>浏览器发送真实请求</li><li>服务器完成真实的响应<br> 比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">fetch</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;http://crossdomain.com/api/user&quot;</span><span style="color:#ABB2BF;">, {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">method</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;POST&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#7F848E;font-style:italic;">// post 请求</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">headers</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 设置请求头</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#98C379;">&quot;content-type&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;application/json&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">body</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">JSON</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">stringify</span><span style="color:#ABB2BF;">({ </span><span style="color:#E06C75;">name</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;袁小进&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">age</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">18</span><span style="color:#ABB2BF;"> }), </span><span style="color:#7F848E;font-style:italic;">// 设置请求体</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p><ol><li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">OPTIONS /api/user HTTP/1.1</span></span>
<span class="line"><span style="color:#abb2bf;">Host: crossdomain.com</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;">Origin: http://my.com</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Request-Method: POST</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Request-Headers: a, b, content-type</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p><p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p><p>预检请求没有请求体，它包含了后续真实请求要做的事情<br> 预检请求有以下特征：</p><ul><li>请求方法为 OPTIONS</li><li>没有请求体</li><li>请求头中包含 - 请求方法为 OPTIONS<br> 没有请求体<br> 请求头中包含 - Access-Control-Request-Method：后续的真实请求将使用的请求方法 - Access-Control-Request-Headers：后续的真实请求会改动的请求头</li></ul><ol start="2"><li>服务器允许<br> 服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#abb2bf;">Date: Tue, 21 Apr 2020 08:03:35 GMT</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Allow-Origin: http://my.com</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Allow-Methods: POST</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Allow-Headers: a, b, content-type</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Max-Age: 86400</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p><ul><li>Access-Control-Allow-Origin：和简单请求一样，表示允许的源</li><li>Access-Control-Allow-Methods：表示允许的后续真实的请求方法</li><li>Access-Control-Allow-Headers：表示允许改动的请求头</li><li>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li></ul><ol start="3"><li>浏览器发送真实请求<br> 预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">POST /api/user HTTP/1.1</span></span>
<span class="line"><span style="color:#abb2bf;">Host: crossdomain.com</span></span>
<span class="line"><span style="color:#abb2bf;">Connection: keep-alive</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;">Referer: http://my.com/index.html</span></span>
<span class="line"><span style="color:#abb2bf;">Origin: http://my.com</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span>
<span class="line"><span style="color:#abb2bf;">{&quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 18 }</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>服务器响应真实请求</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">Date: Tue, 21 Apr 2020 08:03:35 GMT</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;">Access-Control-Allow-Origin: http://my.com</span></span>
<span class="line"><span style="color:#abb2bf;">...</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span>
<span class="line"><span style="color:#abb2bf;">添加用户成功</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，当完成预检之后，后续的处理与简单请求相同<br> 下图简述了整个交互过程<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211095559.jpg" alt="" loading="lazy"></p><p><code>一个额外的补充</code><br> 在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">Access-Control-Expose-Headers: authorization, a, b</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="学习总结" tabindex="-1"><a class="header-anchor" href="#学习总结" aria-hidden="true">#</a> 学习总结</h3><p>本周主要还是以考试复习为重，学习了 CORS 关于跨域的产生和解决办法</p>`,23);function Z($,ss){const l=t("ExternalLinkIcon");return i(),p("div",null,[c,d,b,s("table",null,[u,s("tbody",null,[s("tr",null,[s("td",null,[s("a",y,[n("www.baidu.com"),a(l)])]),s("td",null,[s("a",m,[n("www.baidu.com/news"),a(l)])]),h]),s("tr",null,[s("td",null,[s("a",B,[n("http://www.baidu.com"),a(l)])]),s("td",null,[s("a",v,[n("https://www.baidu.com"),a(l)])]),_]),s("tr",null,[s("td",null,[s("a",f,[n("http://localhost:5000"),a(l)])]),s("td",null,[s("a",g,[n("http://localhost:7000"),a(l)])]),A]),s("tr",null,[s("td",null,[s("a",C,[n("http://localhost:5000"),a(l)])]),s("td",null,[s("a",F,[n("http://127.0.0.1:5000"),a(l)])]),x]),s("tr",null,[s("td",null,[s("a",w,[n("www.baidu.com"),a(l)])]),s("td",null,[s("a",k,[n("baidu.com"),a(l)])]),E]),O,q,j,T,S,P])]),R,s("ol",null,[s("li",null,[n("求头中会自动添加 Origin 字段"),H,n(" 比如，在页面"),N,n("中有以下代码造成了跨域"),M,n(" fetch('"),s("a",D,[n("http://crossdomain.com/api/news"),a(l)]),n("');"),J,n(" 请求发出后，请求头会是下面的格式：")])]),L,s("ul",null,[z,s("li",null,[n("具体的源：比如"),s("a",I,[n("http://my.com"),a(l)]),n("，表示我就允许你访问")])]),V,s("p",null,[n("假设服务器做出了以下的响应："),G,n(" ``HTTP/1.1 200 OK"),K,n(" Date: Tue, 21 Apr 2020 08:03:35 GMT"),W,n(" ..."),X,n(" Access-Control-Allow-Origin: "),s("a",Q,[n("http://my.com"),a(l)]),U,n(" ...")]),Y])}const ls=o(r,[["render",Z],["__file","CORS.html.vue"]]);export{ls as default};

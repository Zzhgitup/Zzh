const e=JSON.parse('{"key":"v-a358c682","path":"/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97.html","title":"promise解决回调函数嵌套","lang":"zh-CN","frontmatter":{"title":"promise解决回调函数嵌套","date":"2022-03-13T11:16:14.000Z","icon":"blog","tag":["javascript"],"category":["记录"],"description":"所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的 ajax 的异步造成的问题，还要在回调函数中去绑定事件，有了 promise 这些都不是事，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 promise 对象代表一个异步操作，有三种状态 pending(进行中)，fulfilled(已成功)，rejected(\\"已失败\\")，异步操作的结果决定这个对象的状态， 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。","head":[["meta",{"property":"og:url","content":"https://oragekk.me/Zzh/blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97.html"}],["meta",{"property":"og:site_name","content":"ZiHao Blog"}],["meta",{"property":"og:title","content":"promise解决回调函数嵌套"}],["meta",{"property":"og:description","content":"所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的 ajax 的异步造成的问题，还要在回调函数中去绑定事件，有了 promise 这些都不是事，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 promise 对象代表一个异步操作，有三种状态 pending(进行中)，fulfilled(已成功)，rejected(\\"已失败\\")，异步操作的结果决定这个对象的状态， 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-23T03:49:02.000Z"}],["meta",{"property":"article:author","content":"ZiHao"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:published_time","content":"2022-03-13T11:16:14.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-23T03:49:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"promise解决回调函数嵌套\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-13T11:16:14.000Z\\",\\"dateModified\\":\\"2023-07-23T03:49:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ZiHao\\",\\"url\\":\\"https://orgaekk.me\\"}]}"]]},"headers":[],"git":{"createdTime":1690084142000,"updatedTime":1690084142000,"contributors":[{"name":"Zzhgitup","email":"99540215+Zzhgitup@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.84,"words":852},"filePathRelative":"blog/学习笔记/promise解决回调函数嵌套.md","localizedDate":"2022年3月13日","excerpt":"<!--more-->\\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的 ajax 的异步造成的问题，还要在回调函数中去绑定事件，有了 promise 这些都不是事，有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>\\n<p>promise 对象代表一个异步操作，有三种状态 pending(进行中)，fulfilled(已成功)，rejected(\\"已失败\\")，异步操作的结果决定这个对象的状态，</p>\\n<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>","copyright":{"author":"ZiHao","license":"CC BY-NC-SA 4.0"},"autoDesc":true}');export{e as data};
